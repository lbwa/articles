{"title":"客户端跨域解决方案","date":"2018 APR 19","author":"Bowen","tags":["前端开发","网络请求"],"errno":0,"to":"writings/cross-domain-solution","content":"\r\n## 什么是跨域\r\n\r\n跨域，指的是浏览器当前页面不能执行其他网站的脚本。它是由浏览器的**同源策略**造成的，是浏览器对 JavaScript 脚本施加的安全限制。\r\n\r\n所谓`同源`是指，**域名，协议，端口**都相同。浏览器执行 JavaScript 脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。\r\n\r\n## 对跨域的基本理解\r\n\r\n1. 跨域只存在于浏览器客户端，在服务端是不存在跨域的。\r\n\r\n2. 跨域时的 ajax 请求并不是没有发出去，此时跨域请求**仍能发出**，且服务端能够收到请求，并返回相应的结果，只是结果在客户端解析时，**被拦截**了。这一点可在请求后的控制台 `network` 选项卡验证，在报错跨域时，仍然能够看到返回的数据结果 `response`。\r\n\r\n浏览器在数据返回时会验证是否是同源数据，若不是同源数据，将会进一步**验证数据头部**是否带有 `access-control-allow-origin: *` ，以此来判断返回数据的服务器是否开启了 `CORS` ，并且检查当前源中**允许的源**是否包括了请求源，并作出解析或拒绝解析返回数据的判断。\r\n\r\n![跨域请求][cross-domain-solution-img1]\r\n\r\n[cross-domain-solution-img1]:https://assets.set.sh/2018/180419-cross-domain-solution/detect-cors.png\r\n\r\n## 解决方案\r\n\r\n跨域的常见解决方法:\r\n\r\n目前为止，跨域请求都必须依靠服务端进行相关配置来处理跨域请求。\r\n1.  window.name + iframe 需要目标服务器响应 window.name。\r\n1.  window.location.hash + iframe 同样需要目标服务器作处理。\r\n1.  html5 的 postMessage + iframe 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。\r\n1.  JSONP 需要目标服务器配合一个 callback 函数。\r\n1.  CORS 需要服务器设置 header：Access-Control-Allow-Origin。\r\n1.  服务器（如，自建 nginx 服务器）反向代理，这种方法可以不用目标服务器配合，但是必须搭建一个**中转服务器**，用于转发请求。此法亦可伪造 header 来绕过 JSONP 的 header 验证\r\n\r\n现在一般常用的是方法是 4，5，6。\r\n\r\n## 拓展：关于 ajax 的同源限制\r\n\r\n简短来说，客户端的 ajax 请求只能请求同源数据。\r\n\r\n举例来说，a 网站有一个 ajax 请求 x，a 在没有配置后端的情况下，b网站是不能直接使用 ajax 跨域请求 a 网站的请求 x（浏览器同源策略），只有当 a 网站的请求 x 是 JSONP 请求时，b 网站才能通过 ajax 代理 JSONP 请求并伪造 header 请求 x。或将b网站的 ajax 请求由中转服务器转发去请求 x。\r\n\r\n## 反向代理解决需要跨域的 ajax\r\n\r\n反向代理原理：浏览器有同源限制，但**服务器没有同源限制**，那么可以利用这一特性来使用本地服务器来转发请求\r\n\r\n前后端分离开发过程中，webpack-dev-server （基于 express 的实现）设置 [devServer.before][devServer.before] 来实现反向代理，示例配置[点我][fanxiandaili]\r\n\r\n[fanxiandaili]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L28-L116\r\n\r\n[devServer.before]:https://doc.webpack-china.org/configuration/dev-server/#devserver-before\r\n\r\n## 反向代理解决需要验证 header 的 JSONP\r\n\r\n现象：JSONP 本身是不具有模拟 headers 的功能的。\r\n\r\n原理：当目标是需要验证 header 的 JSONP 请求时。使用中转服务器的 axios 请求模拟目标 JSONP 请求及其 header。返回的数据格式是携带有目标数据的回调函数。\r\n\r\n典型的需要验证 header 的 JSONP 请求模拟[示例][the-recommend.js-jsonp]\r\n\r\n```js\r\nexport function getJSONPData (recommendId) {\r\n  const data = {\r\n    ...commonParams,\r\n    ...{\r\n      type: 1,\r\n      json: 1,\r\n      utf8: 1,\r\n      // ... some request params\r\n    }\r\n  }\r\n\r\n  // 在没有 header 验证的情况下直接使用 jsonp 请求 url，否则使用后端 ajax 代理转发 JSONP 请求\r\n  // return jsonp(TARGET_URL, data, {\r\n  //   ...options,\r\n  //   // https://github.com/webmodules/jsonp/blob/master/index.js#L50\r\n  //   prefix: '', // 回调函数前缀，默认值为 __jp\r\n  //   name: 'playlistinfoCallback' // 回调函数名，默认值为从 0 开始的计数器\r\n  // })\r\n\r\n  return axios.get(TARGET_URL, {\r\n    params: data\r\n  }).then(res => res.data)\r\n}\r\n```\r\n\r\n中转服务器示例配置(express 为例)[点我][aqjhddm]\r\n\r\n```js\r\n// devServer.before(它是一个 express API)\r\n\r\napp.get('/api/getJSONPData', (req, res) => {\r\n  const url = 'https://example.com'\r\n\r\n  axios.get(url, {\r\n    // 伪造 JSONP 的 headers\r\n    headers: {\r\n      referer: 'https://example.com',\r\n      host: 'https://example.com'\r\n    },\r\n    params: req.query\r\n  }).then(response => {\r\n    let ret = response.data\r\n\r\n    // 提取返回的 JSONP 数据中的回调函数中的参数（即目标数据）\r\n\r\n    if (typeof ret === 'string') {\r\n      // 该正则不具有普适性\r\n      const reg = /^\\w+\\(({.+})\\)$/\r\n      const matches = ret.match(reg)\r\n\r\n      if (matches) {\r\n        ret = JSON.parse(matches[1])\r\n      }\r\n    }\r\n    res.json(ret)\r\n  }, err => {\r\n    throw Error(`Proxy failed, ${err}`)\r\n  })\r\n})\r\n```\r\n\r\n以上两个配置对比普通的 JSONP 请求，可看出，当（**前提条件**） JSONP 有 header 验证时，转为使用 后端代理 ajax 请求 JSONP 数据，（**返回数据的处理方法**）返回的数据是包含之前 JSONP 的回调函数名的，可在 [剔除回调函数][tchdhs] 看出，需要对返回的数据剔除回调函数名，并转为 JSON 正确格式\r\n\r\n## 反向代理适用场景\r\n\r\n### 场景一：目标服务器返回 JSON 格式\r\n\r\n在后端代理请求返回数据格式为 JSON 的情况下，api 不要使用 JSONP 访问后端中转服务器的 url ，尽管 api 能收到正确的数据内容，但格式是错误 `(Uncaught SyntaxError: Unexpected token :)` 的！！因为中转服务器 axios 请求目标服务器返回的数据是 JSON 格式。中转服务器会将目标服务器返回的数据转发回 api ，那么 JSONP 是**无法正确解析** JSON 格式的（JSON 格式没有回调函数）。即请求的类型数据格式要对应相应的请求类型。\r\n\r\n### 场景二：目标服务器返回 JSONP 格式\r\n\r\n当目标服务器返回的是 JSONP 格式时，***仍然使用 axios 请求中转服务器***，不同于场景一的是，在返回的 JSONP 数据中需要**剔除回调函数并转化为 JSON 格式**。\r\n\r\n那么可总结为，使用 axios 转发模拟带 headers 验证的 JSONP 时，***必须以 ajax 请求中转服务器***。我们根据目标服务器返回给中转服务器的数据类型来决定是否在中转服务器中添加**剔除回调函数并转化为 JSON 格式**这一数据处理的步骤。\r\n\r\n[header-refer-JSONP]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L47-L71\r\n\r\n[the-recommend.js-jsonp]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L33-L59\r\n\r\n[aqjhddm]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L74-L100\r\n\r\n[tchdhs]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L85-L95\r\n\r\n### 易错点：反向代理转发请求时返回错误格式\r\n\r\n现象：[链接][fxdlgscw]高亮处 JSONP 请求中转服务器，返回格式错误\r\n\r\n原因：目标服务器只接受 ajax 请求（返回的数据不会有回调函数包裹）时，我们的网页也只能以 ajax 请求中转服务器，中转服务器转发 ajax 请求。若我们的网页使用 JSONP 来请求中转服务器，那么我们最后收到的是 ajax 类型的返回数据，并没有一个回调函数来包裹返回数据，那么就没有可执行的回调函数。即造成了格式错误。\r\n\r\n[fxdlgscw]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L49-L55\r\n\r\n解决方案：[使用 axios 请求][axios-request]后端中转服务器，返回正确格式\r\n\r\n[axios-request]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L56-L59\r\n\r\n\r\n## JSONP\r\n\r\nJOSNP 意为 `JSON with padding`，本质是动态创建 script 标签的 src 属性来请求数据，因为 `<script>` 的 `src` 属性是可以**跨域的。**\r\n\r\n原理：\r\n\r\n1. 首先是利用 `<script>` 的 `src` 属性来实现跨域。\r\n\r\n1. 通过将前端方法作为**参数**传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。客户端在收到返回数据时，就会执行被回调函数包裹的目标数据。\r\n\r\n1. 由于使用 script 标签的 src 属性，因此**只支持get方法**\r\n\r\n**直接**使用 jsonp 方法访问源地址，这在**没有 referer 验证的情况下**可返回正确的数据，若需要 referer 验证(在 Chrome Devtool network 选项直接点击链接是否能返回正确数据)，那么使用 axios 后端代理转发请求。因为 JSONP 本身不能伪造 headers ，反向代理的目的是**伪造 header。**\r\n\r\n典型的 JSONP 请求[点我][jsonp-example]\r\n\r\n[jsonp-example]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-artist.js#L4-L20\r\n\r\n### JSONP 的局限性\r\n\r\n1. 只支持 GET 请求\r\n\r\n1. 因为是通过 `<script>` 的 `src` 属性来实现跨域的，那么我们是无法验证请求数据的安全性，那么我们必须确保请求的域的安全性\r\n\r\n1. 必须另外添加计时器来判断是否请求成功\r\n\r\n## 参考\r\n\r\n[MDN Same-Origin Policy][browser]\r\n\r\n[HTML Standard Concept-origin][browser1]\r\n\r\n[我知道的跨域与安全][all-I-know-about-cross-domain]\r\n\r\n[ajax 跨域解决方案][CORSajaxky]\r\n\r\n[如何解决前后端分离中的 ajax 跨域问题][rhjjqhdflzdkywt]\r\n\r\n[常见 jsonp 出现格式错误的原因][cjjcxgscw]\r\n\r\n[cjjcxgscw]:https://www.zhihu.com/question/264546160\r\n\r\n[CORSajaxky]:https://segmentfault.com/a/1190000012469713#articleHeader12\r\n\r\n[all-I-know-about-cross-domain]:https://juejin.im/post/5a6320d56fb9a01cb64ee191\r\n\r\n[rhjjqhdflzdkywt]:https://www.zhihu.com/question/265985355\r\n\r\n[browser]:https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\r\n\r\n[browser1]:https://html.spec.whatwg.org/multipage/origin.html#concept-origin\r\n"}