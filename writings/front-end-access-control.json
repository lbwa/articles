{"title":"前端权限控制的基本实现","date":"2018 OCT 10","author":"Bowen","tags":["前端开发"],"errno":0,"to":"writings/front-end-access-control","content":"\n## 基于 vue-router 的前端路由权限控制\n\n在常见的中台 `dashboard` 业务实现中，必不可少的权限控制需求。现阶段，`SPA` 应用下的权限路由控制，是经由前端路由结合后端的权限验证来实现。\n\n基本思路是：\n\n1. 若本地存储中存在 `token` 则进入第二步，否则获取当前用户的 `token`。\n\n2. 验证当前用户的 `token` 以获得当前用户的 `access`，并以 `role` 变量临时存储该 `access`。\n\n    - 此处值得注意的是，我们将用户登陆与获取用户的 `access` 操作是分离开来，这样利于功能解耦。在用户登陆时，仅返回用户对应的 `token`。\n\n3. 根据之前获得的 `role` 过滤本地的 `dynamic routes map`（一个初始路由表，并不参与初始路由的构建） 来获得当前用户可访问的路由表动态私有部分。\n\n4. 将过滤后私有的动态路由表和本地公有的静态路由表合并组成最终的全局路由表（或者服务端动态返回当前用户的路由表并与本地的静态路由表合并形成最终路由表）。\n\n5. 根据生成的全局路由表，使用递归组件实现路由列表的动态渲染。\n\n## 权限控制的基本实现\n\n```js\nimport commonRoutes from 'ROUTER/routes/common' // ROUTER is an alias name\nconst LOGIN_PATH = '/login'\n\n// 前端路由的全局前置导航守卫\nrouter.beforeEach((to, from, next) => {\n  // 过滤特定页面的权限检测，如首页，登陆页等\n  if (to.path === '/') {\n    next()\n    return\n  }\n\n  // 验证本地存储是否存在相应的 token，即判断用户是否已经登陆\n  if (getTokenFromLocal()) {\n    if (!store.getters['login/role'].length) {\n      store.dispatch('login/fetchUserRole')\n        .then({ data } => {\n          store.commit('login/SET_ROLE', data.role)\n          return data.role\n        })\n\n        // 通过响应的数据 role 来过滤私有动态路由表，形成当前用户的私有路由表 addRoutes\n        .then(role => store.dispatch('login/createExtraRoutes', role))\n\n        // 添加私有路由表至全局路由表中，并存储于临时变量 store.state.login.routes 中\n        // 借助 router.addRoutes(store.state.login.routes) 实现动态添加路由表\n        .then(() => store.dispatch(\n          'login/createGlobalRoutes',\n          // 消除函数副作用，显式地传入依赖\n          {\n            addRoutes: store.getter['login/addRoutes'],\n            router\n          },\n        ))\n        .catch(console.error)\n\n        // 路由递归组件中存在对 store.state.login.routes 的依赖，那么递归组件此时将动\n        // 态渲染出当前用户的有效路由\n    }\n  } else {\n    // 无法获取当前用户 token 时，重定向至登陆页\n    next({\n      path: `${LOGIN_PATH}?${to.path}`,\n      replace: true\n    })\n  }\n})\n```\n\n## 响应数据的动态路由表的合并\n\n```js\nconst ADMINISTRATOR = 'admin'\n\nexport default {\n  /**\n   * @description 根据服务端响应的 access 来过滤前端动态路由表\n   * @param {String[]} role 服务端响应的当前用户 access\n   */\n  createExtraRoutes ({ commit }, role) {\n    // 在当前用户获得 `admin` 时，将默认获取所有的私有动态路由，即跳过动态路由过滤\n    const addRoutes = role.includes(ADMINISTRATOR)\n      ? dynamicRoutes\n      : filterRoutes(dynamicRoutes, role)\n\n    commit('SET_ADD_ROUTES', addRoutes)\n  },\n  createGlobalRoutes ({ commit, dispatch }, { addRoutes, router }) {\n    // SET_ROUTES is a mutation type in module `login`\n    /**\n     * 1. 将过滤后的 addRoutes 与静态公有路由表合并为全局的最终路由表\n     * 2. SET_ROUTES mutation 将在当前会话中临时存储动态的私有路由表 addRoutes 和\n     * 全局最终的路由表 routes，全局的 routes 将用于递归组件的 UI 渲染，addRoutes 将\n     * 用于传入 router.addRoutes 添加路由\n     */\n    commit('SET_ROUTES', addRoutes)\n    router.addRoutes(addRoutes)\n  }\n}\n\n/**\n * @param {Object[]} routes 路由表\n * @param {String[]} role 服务端响应的当前用户 access\n */\nfunction filterRoutes (routes, role) {\n  const formatRoutes = []\n  routes.forEach(route => {\n    // 使用副本传递，而非引用，避免引用同一路由对象\n    const routeCopy = { ...route }\n    if (hasAccess(route, role)) {\n      if (route.children && route.children.length !== 0) {\n        routeCopy.children = filterRoutes(routeCopy.children, role)\n      }\n      formatRoutes.push(routeCopy)\n    }\n  })\n}\n\n/**\n * @param {Object} route 单个路由\n * @param {String[]} role 服务端响应的当前用户 access\n */\nfunction hasAccess (route, role) {\n  // 当在预设默认动态路由表中不存在 meta.role 设置时，将默认为对所有权限开放\n  return role.meta && Array.isArray(role.meta.role)\n    ? role.some(item => route.meta.role.includes(item))\n    : true\n}\n```\n\n在前端路由的全局前置导航守卫 `createExtraRoutes` 被调用时，将过滤当前用户的私有列表，并相继调用创建全局最终路由表的 `createGlobalRoutes` 的 `actions` 得到最终的全局路由表 `routes` 和私有列表 `addRoutes`。在前端路由中，`vue-router` 在初始化路由实例之后，支持通过调用实例方法 `router.addRoutes` 来向当前路由表添加私有列表 `addRoutes`。而之前合并生成的的全局路由表此时就与路由实例中的路由表保持了 ***同步***。而此时临时存储在 `vuex` 中的全局路由表将在后续被递归组件调用，实现动态地路由列表渲染。\n\n## 动态渲染路由列表\n\n在经过上节的路由表合并之后，将结果路由表存储在 `store.state.login.routes` 中。在多个递归组件中注入 `routes` 路由表的单项，即可实现动态渲染出动态 `aside menu`。\n\n循环生成多个递归组件，通过 `props` 注入向单个递归组件注入对应单个 `route` ，以实现递归渲染子列表。\n\n```html\n<!-- Aside.vue -->\n<template>\n  <!-- 只列出关键 props -->\n  <el-menu\n    :router=\"true\"\n  >\n    <recursive-list\n      v-for=\"route of routes\"\n      :key=\"route.path\"\n      :route=\"route\"\n      :basic-route=\"route.path\"\n    ></recursive-list>\n  </el-menu>\n</template>\n\n<script>\nimport RecursiveList from '@/RecursiveList'\nimport { mapState } from 'vuex'\n\nexport default {\n  computed: {\n    ...mapState('login', [\n      'routes'\n    ])\n  }\n}\n</script>\n```\n\n在递归组件内部实现以下递归渲染逻辑：\n\n```html\n<template>\n  <!-- meta.hidden 用于自定义需要排除渲染的列表项 -->\n  <div class=\"list-item__wrapper\" v-if=\"!route.meta.hidden\">\n    <template v-if=\"!route.children\">\n      <el-menu-item\n        :index=\"resolvePath(route.path)\"\n      >{{route.meta.title}}</el-menu-item>\n    </template>\n\n    <el-submenu v-else :index=\"route.path\">\n      <!-- 菜单名 -->\n      <template slot=\"title\">\n        <i class=\"el-icon-menu\"></i>\n        <span slot=\"title\">{{route.meta.title}}</span>\n      </template>\n\n      <!-- 递归模板，核心 -->\n      <template v-for=\"child of route.children\">\n      <!-- 当子路由存在子路由时，递归组件 -->\n        <recursive-list\n          :key=\"child.path\"\n          v-if=\"child.children\"\n          :route=\"child\"\n          :basic-route=\"resolvePath(child.path)\"\n        />\n        <el-menu-item\n          v-else\n          :key=\"child.path\"\n          :index=\"resolvePath(child.path)\"\n        >{{child.meta.title}}</el-menu-item>\n      </template>\n    </el-submenu>\n  </div>\n</template>\n\n<script>\n// SFC 经 webpack 编译，那么可传入 node 编译环境中的 path 来作为工具函数\nimport path from 'path'\n\nexport default {\n  // name 用于递归调用\n  name: 'recursive-list',\n\n  props: {\n    route: {\n      type: Object,\n      required: true\n    },\n\n    // 用于传递给子组件，拼接子路由\n    basicRoute: {\n      type: String,\n      default: ''\n    }\n  },\n\n  methods: {\n    resolvePath (target) {\n      return path.resolve(this.basicRoute, target)\n    }\n  }\n}\n</script>\n```\n\n## 注销后的全局路由表重置\n\n```js\n// login/actions.js\n\nexport default {\n  // replace 为编程式导航方法，即 router.replace\n  // eg. 在 SFC 中以 this.$store.dispatch(\n  //  'login/logout',\n  // this.$router.replace.bind(this.$router)) 的形式调用\n  logout ({}, replace) {\n    removeTokenFromLocal()\n\n    // 切换至登陆页\n    replace('/login')\n\n    // vue-router v3.0.1 仅支持动态添加路由方法 addRoutes，并不支持删除路由信息\n    location.reload()\n  }\n}\n```\n\n值得注意的是，在当前 `vue-router` 版本 `v3.0.1` 中，并未支持动态删除路由。那么要在当前 `tab` 中实现删除路由就必须实现重置全局 `routes map`。另外在用户注销时，需要一并重置本地存储与临时存储（如 `vuex`）。那么，最终用户注销的实现是在调用编程式导航方法 `replace` 切换至目标页之后，调用 `location.reload()`实现全局 `routes map` 与全局状态重置。\n\n另外，若在当前 `APP` 中使用 `sessionStorage` 来存储用户的 `token` 时，需要注意在同一 `tab` 中刷新页面时，不会清空 `sessionStorage`。那么也就是说当调用 `location.reload()` 时，并不会清空本地存储 `sessionStorage`。那么此时需要手动清除 `sessionStorage`。\n\n## 总结\n\n至此，以上是实现中台应用中前端的权限管理的一种方式。最为核心的地方即是实现公有路由表与私有路由表的合并，即根据当前用户的 `token` 验证得到用户的 `access`，在根据 `access` 得到最终用户可访问的路由。后续，将最终的路由用户路由列表递归渲染，而过滤得到的私有路由则因通过路由实例的 `addRoutes` 方法添加到现有的路由表中，以实现私有路由的切换。\n"}