{"title":"理解 this 的指向","date":"2018-02-06T00:00:00.000Z","author":"Bowen","tags":["前端开发","JavaScript"],"erron":0,"content":"\r\n> The abstract operation ResolveThisBinding determines the binding of the keyword this using the LexicalEnvironment of the running execution context.\r\n\r\nJS 中的 `ResolveThisBinding` 操作将会绑定 [this][keyword] 关键字为当前执行上下文的词法作用环境。\r\n\r\n[keyword]:https://www.ecma-international.org/ecma-262/#sec-resolvethisbinding\r\n\r\n# 一、ES5中this的值\r\n\r\n## 1.1 定义：this，指函数的调用上下文。\r\n\r\n在函数没有被调用的时候是无法确定函数中的this值的指向，只有当函数调用时才能确定函数中this值的指向。\r\n\r\n当函数被调用时，理解this值的指向有以下四种情况（函数中存在this）：\r\n\r\n**情况一**：函数没有被上一级对象调用时，那么他函数体内的this值指向window。\r\n\r\n**注**：在严格模式中默认的this值不是window，而是undefined。\r\n\r\n```js\r\nlet num = () => {\r\n   a = 10;\r\n   console.log(this);\r\n};\r\nnum();     // window\r\n```\r\n\r\n在上面的函数中，定义了一个函数num，在调用函数时，实际上是调用的window的属性num。\r\n\r\n**情况二**：函数被上一级（一个）对象调用时，那么该this值指向的是调用的对象，即指向上一级对象。\r\n\r\n```js\r\nlet num = {\r\n  a: 10,\r\n  fn: function() {\r\n    console.log(this);\r\n  }\r\n};\r\nnum.fn();    // num\r\n```\r\n\r\n在上面的代码中，fn只被对象num包围，在调用fn时，this指向调用fn的上一级对象，也就是对象num。\r\n\r\n**情况三**：函数外有多个对象包围时，尽管函数是被最外层的对象调用，那么函数中的this值只指向上一级对象。\r\n\r\n```js\r\nlet num = {\r\n  a: 10,\r\n  b: {\r\n    fn: function() {\r\n      console.log(this);\r\n    }\r\n  }\r\n};\r\nnum.b.fn();  // 对象b\r\n```\r\n\r\n　　由上可知，函数fn被对象b包围，而b又是对象num的属性之一，尽管是最外层对象num调用了函数fn（执行了这个调用行为的开端），而函数fn中的this值只会指向离他最近的上一级对象，也就是对象b。\r\n\r\n**情况四：先赋值，后执行**\r\n\r\n```js\r\nlet num = {\r\n  a: 10,\r\n  b: {\r\n    fn: function() {\r\n      console.log(this);\r\n    }\r\n  }\r\n};\r\nlet digit = num.b.fn\r\ndigit() // window   与情况三的差别在于，先赋值，后调用\r\n```\r\n\r\n　　this值始终指向最后调用它的对象，且只在调用函数时才能确定this的指向。这里首先是把num.b.fn函数赋值给digit，虽然fn是被对象b所引用，但并没有直接执行函数，而执行digit时才确定了this的指向，window调用了digit，所以指向window。\r\n\r\n```js\r\nvar length = 10;\r\nfunction fn() {\r\n  console.log(this.length)\r\n}\r\nvar obj = {\r\n  length: 5,\r\n  method: function (fn) {\r\n    fn() // 10\r\n    arguments[0]() // 2\r\n    fn.call(obj, 12) // 5\r\n  }\r\n};\r\nobj.method(fn, 1);\r\n```\r\n\r\n　　在上面的示例中，`obj.method(fn, 1);`执行的本质是`fn();` `arguments[0]();` `fn.call(obj, 12);`这三句。先理解三个语句，因为单线程的缘故，所以是在method中给栈添加任务执行三个函数，此时，method任务执行完成，下一个任务执行调用fn，此时，没有显示的指定的对象调用fn，故fn中的this指向window，所以结果为10。下个任务`arguments[0]()`; 表示调用method的参数对象arguments的第一项并执行，此时，arguments对象（只是类数组，并非Array实例）开始调用它的第一项，即fn，此时，fn有显示的调用对象，即arguments对象，此时，fn中的this指向arguments对象，因为arguments对象有两项，故返回2。第三句，显示的指明this指向obj对象，故返回obj.length，即5。\r\n\r\n**结论：**\r\n\r\n1. （个人理解）在函数a内执行函数b时，确切来说**真正调用执行b的还是window对象**，此时函数b内的this是指向window对象，函数a的作用是**告知引擎添加一个执行b的任务**。\r\n\r\n2. 当函数c是arguments对像的第 i 项时，`arguments[i]()`中的this指向的是arguments对象。\r\n\r\n**补充：**\r\n\r\n　　在`《JavaScript语言精粹》修订版`P28中，对于没有显式的调用对象的函数调用，该被调用的函数内的this指向全局对象。作者认为这是JavaScript设计上的一个“错误”。\r\n\r\n　　作者认为此时的函数调用中的this应该指向外部函数的this变量。其中当函数A内调用函数B时，首先执行函数A的语句，当执行到调用函数B语句时，暂停函数A内的语句执行，将控制权转交给函数B，先执行完函数B，然后再继续执行函数A（`《JavaScript语言精粹》修订版`P27）。\r\n\r\n**构造函数中的this**\r\n\r\n```js\r\nfunction Fn(){\r\n    this.user = \"Jack\";\r\n}\r\nvar a = new Fn();\r\nconsole.log(a.user); // Jack\r\n```\r\n\r\n　　根据官方文档[new运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)中Description第2点的解释，使用new运算符调用构造函数时，构造函数中的this会指向实例化的对象。\r\n\r\n实践也可证明：\r\n\r\n```js\r\nfunction Foo() {\r\n  this.name =  'Jack';\r\n  console.log(this);\r\n}\r\nnew Foo(); // Foo {name:'Jack'}\r\n```\r\n\r\n　　此时控制台返回对象Foo {name:'Jack'} 2次，一个是 console.log(this); 的返回值，一个是实例化的返回值，即 this 在实例化时指向了实例化的对象（或者理解为new运算符将构造函数中的this值绑定到实例化对象上）。\r\n\r\n**结论**：函数体中的this始终指向最后调用它的那个对象。在构造函数中，this指向实例化的对象。\r\n\r\n## 1.2 实例化时，构造函数的this是如何绑定到实例化对象的呢？\r\n\r\n- 据`《JavaScript高级程序设计》第三版`P145，解释如下：\r\n\r\n创建新实例时，必须使用new运算符，创建会经历以下四个阶段：\r\n\r\n1. 创建一个新对象；\r\n\r\n2. 将构造函数和的作用域赋给新对象（因为这个新对象调用了构造函数，所以this就指向了这个新对象）；\r\n\r\n3. 执行构造函数中的代码（目的是为了给这个新对象添加属性）；\r\n\r\n4. 返回新对象。\r\n\r\n\r\n- 据`《JavaScript语言精粹》修订版`P47，使用new操作符去调用一个函数时，函数的执行方式将被修改，可将new操作符理解为一个方法，则有:\r\n\r\nNote:\r\n\r\n1. 下文Function.method(name,fn)表示给Function函数添加一个new的方法（method为书中自定义函数，并非JavaScript原生函数，表示给调用的对象添加一个名为name的方法（fn））\r\n\r\n2. 代码中的注释讨论的this是构造函数调用new这个方法时的this。　\r\n\r\n代码如下：\r\n\r\n```js\r\nFunction.method('new', function() {\r\n  // 创建一个新对象（对象that）， that和构造函数共用同一个对象\r\n  // this 指向（与new连用的）构造函数，Object.create()创建一个以参数为原型对象的对象\r\n  var that = Object.create(this.prototype);\r\n\r\n  // 调用构造器函数，绑定 -this- 到新对象（指that）上\r\n  // 此处存在apply方法，this 指向（与new连用的）构造函数，则以下语句表示，that调用以\r\n  // arguments对象为参数对象的构造函数（指定构造函数中的this值为that），目的是给that\r\n  // 添加属性（或方法）\r\n  // 此处根据构造函数的函数体，函数体内可能有（或没有）return语句，则other可能是对象、\r\n  // 基本类型值、undefined、null\r\n  var other = this.apply(that, arguments);\r\n\r\n  // 如果它返回的不一个对象，就返回该(that)新对象，即优先返回构造函数中return语句返回\r\n  // 的对象，若return返回的不是对象，则忽视return返回值\r\n  return (typeof other === 'object' && other) || that;    // 1.3解释\r\n})\r\n```\r\n\r\n在以上代码中，that是一个中间对象，that的作用是执行Function构造函数，并将指向构造函数原型的指针复制给other（实例化对象）。\r\n\r\n回到之前的代码：\r\n　\r\n```js\r\nfunction Fn(){\r\n    this.user = \"Jack\";\r\n}\r\nvar a = new Fn();\r\nconsole.log(a.user); // Jack\r\n\r\n```\r\n\r\n由两本文献可知，实例化过程中，经历了以下过程：\r\n\r\n（由`var a = new Fn();`可知变量a复制了指向Fn()实例对象的指针，以下就以变量a指代Fn的实例。）\r\n\r\n1. 创建了一个新对象a（指向构建函数的原型对象），此时对象为空；\r\n\r\n2. 复制构造函数的作用域给新对象a；\r\n\r\n3. 然后执行构造函数，这是为了给新对象添加属性（因为在构造函数Fn中直接将属性赋给了this对象），那么是如何添加的呢？此时因为是新对象a调用了构造函数，所以构造函数内的this指向了新对象a，此时新对象a就获得了Fn的属性user；\r\n\r\n4. 返回新对象a。\r\n\r\n以上过程展示了在构造函数实例化的过程中，this的值是如何绑定在实例化的对象上的。\r\n\r\n## 1.3 在有return语句中的函数中this的值\r\n\r\n(据1.2创建实例经历的四个阶段，可得当存在变量a等于{ user:\"Jack\"}时，可认为构造函数的this指向构造函数的实例。)\r\n\r\n当函数的return语句返回一个对象时：　\r\n\r\n```js\r\nfunction Fn(){\r\n    this.user = \"Jack\";\r\n    return {};\r\n}\r\nvar a = new Fn(); // 返回的不是Fn的实例\r\nconsole.log(a.user); // undedined\r\nconsole.log(a); // {} 此时a并没有继承Fn的user属性，可见Fn函数内this并未指向a\r\n```\r\n\r\n当函数的return语句返回一个基本类型值时\r\n\r\n```js\r\nfunction Fn(){\r\n    this.user = \"Jack\";\r\n    return 1;\r\n}\r\nvar a = new Fn();\r\nconsole.log(a.user); // \"Jack\"\r\nconsole.log(a); // {user: \"Jack\"} 此时a继承Fn的user属性，可见Fn函数内this指向a\r\n```\r\n\r\n当函数的return语句返回null时\r\n\r\n```js\r\nfunction Fn(){\r\n    this.user = \"Jack\";\r\n    return null; // null是特殊对象值，但此时this仍指向构造函数实例a\r\n}\r\nvar a = new Fn();\r\nconsole.log(a.user); // \"Jack\"\r\nconsole.log(a); //  {user: \"Jack\"} 此时a继承Fn的user属性，可见Fn函数内this指向a\r\n```\r\n\r\n**结论**：构造函数本身也是函数，所以可以设置return语句的返回值，那么当函数的return语句返回一个对象时，this会指向这个return语句返回的对象，不会指向函数的实例。当return语句返回一个基本类型值（或null）时，会忽略这个基本类型值，指向函数的实例。\r\n\r\n# 二、箭头函数（ES6）中的this值\r\n\r\n箭头函数可以让this绑定定义时所在的作用域，而不是指向运行时所在的作用域。\r\n\r\n```js\r\nfunction foo() {\r\n  setTimeout(() => {\r\n    console.log('id:', this.id);\r\n  }, 100);}\r\n\r\nvar id = 21;\r\n\r\nfoo.call({ id: 42 }); // id: 42\r\n```\r\n\r\n　　在以上示例中，setTimeout参数中是一个箭头函数，定义生效时就是函数生成时，而真正的执行在100毫秒（因为JavaScript是单线程，所以在执行完foo后，由全局对象调用执行setTimeout参数中的函数）之后。若是普通函数的话，因为是全局对象调用，所以此时的this值指向window，foo.call({ id: 42 }); 返回21。在示例中，因为是箭头函数，所以this值在定义时就已经确定，总是指向定义生效时所在的对象，这里是{id:42}，所以返回 42。\r\n\r\n**推广：箭头函数可以让this指向固定化，这种特性很有利于封装回调函数**。\r\n\r\n一次在实践单例的过程中遇到的问题：\r\n\r\n简化代码如下：\r\n\r\n```js\r\nlet foo = () => {\r\n      let a = 111;\r\n      return {\r\n        a: a,\r\n        fn: () => {\r\n          console.log(this); // window对象\r\n          // 在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代\r\n          // 表是什么。若找到，搜索停止。若没有，则该变量未声明\r\n          // fn中对变量a的赋值本质是，向上在作用域链中搜索，找到位于foo中的变量a，并在\r\n          // fn中对foo的变量a进行赋值\r\n          a = 222;\r\n        },\r\n        num: () => {\r\n          console.log(this); // foo对象\r\n          console.log(a); // 222\r\n        }\r\n      };\r\n    };\r\nlet ins = foo();\r\nins.fn();\r\nins.num();\r\n```\r\n\r\n在以上箭头函数fn中，this指向函数定义时的外部环境。\r\n\r\n实际上在箭头函数中，自身并没有this对象，它所使用的this是外层代码块的this。实际上箭头函数可以起到绑定this值的作用。　　\r\n\r\n**推广：在箭头函数中，不存在真正属于他自己的this、arguments对象，因为不存在自己的this，所以不能使用call()、apply()、bind()方法修改箭头函数中的this值。**\r\n\r\n若要让num方法中的this指向foo，就使用原有的function声明代替箭头函数。这样在调用num方法时，最后调用该方法的对象是foo，所以此时的num方法中的this指向foo。\r\n\r\n```js\r\nlet foo = () => {\r\n      let a = 111;\r\n      return {\r\n        a: a,\r\n        fn: () => {\r\n          console.log(this); // window对象\r\n          a = 222;\r\n        },\r\n        num: function() {\r\n          console.log(this); // foo对象\r\n          console.log(a); // 222\r\n        }\r\n      };\r\n    };\r\nlet ins = foo();\r\nins.fn();\r\nins.num();\r\n```\r\n\r\n　　另外，**要将作用域中的变量和对象的属性和区分开，作用域只与函数定义时的位置有关，与运行过程无关**。在num方法中要输出变量a，则先在当前num方法中寻找变量a，若没有找到则沿着作用域链向上搜索变量a，则在foo的活动对象中找到变量a，然后返回输出变量a。要注意的一个细节是，a:111是foo的属性，不是变量，不要弄混淆了。\r\n"}