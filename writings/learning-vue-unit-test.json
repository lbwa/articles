{"title":"总结如何进行单元测试","date":"2018-04-21T00:00:00.000Z","author":"Bowen","tags":["前端开发","Vue.js","应用测试"],"erron":0,"content":"\r\n# 关于单元测试应该了解的知识\r\n\r\n## 测试原则\r\n\r\n首先最应该搞明白的是，我们要测什么？测试的目的是什么？\r\n\r\n单元测试，侧重点在\"单元\"。在单元测试中更应该注重**单个**单文件组件的功能实现，而不是过多纠缠于组件之间的数据传递(这是端到端测试的内容，即 e2e，测试整个应用的功能展现)和组件中的功能实现过程。\r\n\r\n我们不论是在单元测试中还是 e2e 测试的重点都应该是，测试单个组件（或由多个组件组成的整个应用）的渲染或功能的**结果**，而不是过程！！即侧重**黑盒测试**，至于是怎样实现的，并不是测试的内容。\r\n\r\n注重结果测试的好处就是，并不限制结果的实现方式，为后期的优化和拓展提供了更多的可能性。\r\n\r\n比如，测试一个函数的功能，就看这个函数需要什么数据，然后提供测试的原始数据，之后我在调用该函数(可通过直接调用或事件触发)。断言函数的返回结果。这些就是我们的测试内容。至于该函数是如何处理数据的，并不是测试内容。\r\n\r\n## Vue.js 单元测试工具箱\r\n\r\n1. [vue-test-utils][vue-test-utils] - 官方\r\n\r\n- karma 单元测试环境\r\n- Mocha 单元测试框架\r\n- [Chai][Chai] 断言库\r\n\r\n2. [ElementFE Vue.js test utils][ElementFE Vue.js test utils]\r\n\r\n[vue-test-utils]:https://vue-test-utils.vuejs.org/zh-cn/\r\n\r\n[ElementFE Vue.js test utils]:https://github.com/lbwa/vue-unit-test/blob/master/test/unit/util.js\r\n\r\n[vue-test-utils 高级技巧]:https://vue-test-utils.vuejs.org/zh-cn/guides/common-tips.html\r\n\r\n[Matt O'Connell]:http://slides.com/mattoconnell/deck#/\r\n\r\n[Chai]:http://www.chaijs.com/guide/styles/#assert\r\n\r\n# 单元测试技巧\r\n\r\n## 测试异步行为\r\n\r\n首先需要了解的是 `vue-test-utils` 是同步应用 DOM 更新的，那么在 `Mocha` 的 `expect()` 中存在异步操作且还未完成异步操作时，就可能已经调用 `expect()` 来断言了。\r\n\r\n在 `Jest` 和 `Mocha` 等单元测试库都定义了一个回调函数 `done()` 来标明测试用例的完成时机。有了该 `done()` 回调函数即表明了，该处代码块是异步操作（具体原理见下文）。我们可以和 `$nextTick` 或 `setTimeout` 结合 `done()` 来保证异步操作在断言之前完成。\r\n\r\n`done()`实际用例：[用例一][example-done-1]，[用例二][example-done-2]\r\n\r\n## 测试异步行为的原理\r\n\r\n结论： `done()` 保证了断言是在下一个事件循环被执行，那么在断言之前的所有异步操作均已完成。\r\n\r\n在单元测试库中通过一个 `done()` 回调函数来标明了测试用例的执行时机，其意义在于，只有等到当前事件循环中的所有任务执行（包含了当前事件循环中的所有异步操作的执行）完成后，单元测试库才会调用 `done()` 回调，用于执行断言。此时的，断言已经开启了新的事件循环队列。\r\n\r\n之所以，当前事件循环中的异步操作全部被执行的原因是，在一个事件循环中，首先从 marco-task 队列提取第一个任务，在执行这个任务过程中，产生的所有**异步操作**的**回调函数**调用（如，Promise.then()中的参数对象），都将进入 micro-task 队列等待执行。待当前 marco-task 这一任务完成，开始依次执行 micro-task 队列中的任务，直至**清空**该 micro-task 队列。只有等到当前事件循环中的 micro-task 清空后才会进入下一个事件循环，即开启下一个 marco-task 的执行。此时，即是 `done()` 的执行时机，即正因为有了 `done()` 才保证了断言是在下一个事件循环中被执行，那么，在此之前的所有异步操作的回调函数早就已经执行完成了。\r\n\r\n以上原理更多的具体分析，可点击查看我的另一篇博文——[《理解 event loop 机制》][event-loop]。\r\n\r\n## 测试键盘、鼠标及其他 DOM 事件\r\n\r\n（以官方单元测试工具为例）\r\n\r\n## 测试环境中的事件触发与监听\r\n\r\n```js\r\nit('测试点击 todo 单项事件 - refreshThisCompleted', done => {\r\n    const wrapper = mount(ContentItem, {\r\n      propsData: {\r\n       // ...\r\n      }\r\n    })\r\n    const button = wrapper.find('.toggle')\r\n\r\n    button.trigger('click') // 官方库包装了事件触发以及事件的监听的过程\r\n\r\n    // ...\r\n  })\r\n```\r\n`button.trigger('click')` 是官方库的事件触发 API，其包含了事件初始化，事件派发，事件监听等一系列过程。\r\n\r\n注：在原本的测试环境中 `Vue.js` 的 watcher 是不能被触发的，其中的 watcher 都是需要手动触发的。\r\n\r\n```js\r\n// 创建事件并触发\r\nconst evt = new window.Event('click') // Event() 代替 Document.createEvent() 成为标准\r\nbutton.dispatchEvent(evt)\r\n// 手动触发 watcher\r\nvm._watcher.run() // vm 表示测试环境中的 Vue 实例\r\n```\r\n\r\n特别地，特定按键的事件触发如下:\r\n\r\n```js\r\nit('刷新显示的 todo 单项 - refreshItems', () => {\r\n    const wrapper = mount(LayoutContent)\r\n    const inputBox = wrapper.find('.add-item')\r\n\r\n    inputBox.element.value = 'Test content'\r\n    inputBox.trigger('keyup.enter') // 与 Vue.js 中的特定事件触发写法相似\r\n    // ...\r\n})\r\n```\r\n\r\n参考：[测试环境中的事件][dom-events]\r\n\r\n[dom-events]:https://vue-test-utils.vuejs.org/zh-cn/guides/dom-events.html\r\n\r\n## 测试环境中的 evt.target\r\n\r\n一般情况下 `wrapper.trigger()` 可携带一个对象作为载荷，传递给监听器。但是，这个对象**不能**设置事件 evt.target 对象。原因：[点我][trigger]\r\n\r\n那么在需要取得某个元素的 value 值的情况下，我们可以有以下的实现：\r\n\r\n```js\r\nconst input = wrapper.find('input')\r\ninput.element.value = 100\r\ninput.trigger('click')\r\n```\r\n在调用 `trigger()` 方法之前就设置好该元素的 value 值。\r\n\r\n具体使用案例：[点我][trigger1]\r\n\r\n[trigger]:https://vue-test-utils.vuejs.org/zh-cn/api/wrapper/trigger.html\r\n\r\n[trigger1]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/LayoutContent.spec.js#L38-L50\r\n\r\n## 重要事项\r\n\r\nVue Test Utils 是同步触发事件。因此 Vue.nextTick 不是必须的。\r\n\r\n[example-done-1]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/ContentItem.spec.js#L61-L64\r\n\r\n[example-done-2]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/LayoutContent.spec.js#L104-L107\r\n\r\n[event-loop]:https://set.sh/blog/writings/event-loop/\r\n\r\n# travis CI\r\n\r\n## .travis.yml 中\r\n\r\n在 travis CI 集成时，调用 Chrome 的[必须选项][chrome-options]：\r\n\r\n```yaml\r\nsudo: required\r\n\r\naddons:\r\n    chrome: stable\r\n\r\nbefore_install:\r\n  - export CHROME_BIN=chromium-browser\r\n  - export DISPLAY=:99.0\r\n  - sh -e /etc/init.d/xvfb start\r\n```\r\n\r\n`export CHROME_BIN=chromium-browser` 表示指定测试时使用的 Chrome 浏览器(最好字指明，还有 `google-chrome` 可选)。\r\n\r\n在 `karma.conf.js` [示例配置][karma.conf.js]中调用 `Chrome` 等**界面浏览器**时，以下两项是***必须项***。\r\n\r\n`export DISPLAY=:99.0` 指定一个 GUI 测试。[出处][display-origin]\r\n\r\n`sh -e /etc/init.d/xvfb start` 指定一个在 `travis CI` 中测试时的图形界面。[出处][xvfb-origin]\r\n\r\n特别地，在 travis CI 中调用不需要图形界面的 ChromeHeadless 版本（[示例配置][ChromeHeadless]）的时候，那么以上两项就***不是必须的***。\r\n\r\n[ChromeHeadless]:https://github.com/lbwa/vue-ssr/blob/master/test/unit/karma.conf.js#L19-L23\r\n\r\n## karma.conf.js 中\r\n\r\n在 `karma.conf.js` [示例配置][karma.conf.js]中将部分配置修改如下：\r\n\r\n```js\r\nmodule.exports = function karmaConfig (config) {\r\n  config.set({\r\n    // browsers: ['PhantomJS'], 结合 vue-test-utils 挂载时 执行 mount() 会报错\r\n    // browsers 数组有多项时，将同时调用数组内的所有浏览器开始 unit test\r\n    browsers: process.env.TRAVIS ? ['Chrome_travis_ci'] : ['Chrome'], // 浏览器\r\n    customLaunchers: {\r\n      Chrome_travis_ci: {\r\n        base: 'Chrome',\r\n        // https://github.com/karma-runner/karma-chrome-launcher\r\n        flags: process.env.TRAVIS ? ['--no-sandbox'] : ['']\r\n      }\r\n    },\r\n    // ...\r\n    coverageReporter: { // karma-coverage配置，配置测试覆盖率的输出目录及格式\r\n      dir: './coverage',\r\n      reporters: [\r\n        { type: 'lcov', subdir: '.' }, // 输出 Icov.info\r\n        { type: 'text-summary' }, // 输出 网页报告 Icov-report\r\n        { type: 'json', subdir: '.' } // 输出 coverage-final.json\r\n      ]\r\n    }\r\n  })\r\n}\r\n```\r\n\r\n在配置中使用 `process.env.TRAVIS` 来判定当前的测试环境，因为在 travis CI 环境中调用 Chrome 时有[权限的限制][chrome-options]，在 travis CI 使用 Chrome 的 `--no-sandbox` 模式来进行单元测试。\r\n\r\n另外一种根据不同环境使用 Chrome 的不同模式的**方法**就是，去掉配置中的环境判断，在添加同样的 `customLaunchers` 配置下，根据 [karma-chrome-launcher API][karma-chrome-launcher] 来在 node script 添加 CLI 命令以指定测试的浏览器。\r\n\r\n```bash\r\n$ cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run --browsers Chrome_travis_ci\r\n```\r\n\r\n添加 `--browsers Chrome_travis_ci` 来指定在 travis CI 中的浏览器，因为我们在 [karma.conf.js][karma.conf.js] 中定义了 `customLaunchers` ，那么此时启动的**浏览器及其模式**将会**匹配**我们定义的 `customLaunchers` 项。\r\n\r\n# 参考\r\n\r\n[vue-test-utils 高级技巧][vue-test-utils 高级技巧]\r\n\r\n[Matt O'Connell 关于 Vue.js 的单元测试的演讲][Matt O'Connell]\r\n\r\n[How to run JavaScript tests in Chrome on Travis][JS-on-Travis]\r\n\r\n[travis CI 默认环境变量][Default Environment Variables]\r\n\r\n[JS-on-Travis]:https://swizec.com/blog/how-to-run-javascript-tests-in-chrome-on-travis/swizec/6647\r\n\r\n[karma.conf.js]:https://github.com/lbwa/vue-unit-test/blob/master/test/unit/karma.conf.js\r\n\r\n[karma-chrome-launcher]:https://github.com/karma-runner/karma-chrome-launcher\r\n\r\n[chrome-options]:https://docs.travis-ci.com/user/chrome\r\n\r\n[display-origin]:https://docs.travis-ci.com/user/languages/javascript-with-nodejs#Ember-Apps\r\n\r\n[xvfb-origin]:https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\r\n\r\n[Default Environment Variables]:https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables\r\n"}