{"title":"学习 Vue.js 可复用性和组合","subtitle":"理解 Vue.js 进阶思维 —— 可复用性&组合","date":"2018-03-12T00:00:00.000Z","author":"Bowen","tags":["前端开发","JavaScript","Vue.js"],"errno":0,"to":"writings/vue.js-reusability-and-composition","content":"\n# 混入\n\n## 基础\n\n混入可理解为在一个组件中调用另外一个包含组件选项的**对象**。可类比 Sass 中的 `@mixin` 混合宏、DOM 中的 `DocumentFragment` 类型。这里可以得到，混入是为了增强 Vue 中的选项复用性。\n\n在创建 Vue 实例时，使用`mixins`选项来引入混入对象。\n\n```js\nconst CustomMixin = {\n  created () {\n    this.hello()\n  },\n  methods: {\n    hello () {\n      console.log('App is running now !')\n    }\n  }\n}\n\nnew Vue({\n  el: '#app',\n  mixins: [CustomMixin],  // 使用 mixins 选项来引入混入对象\n})\n```\n\n## 选项合并\n\n1. 在混入时，各个选项的合并是**浅合并**（如，指向对象的指针就只会复制指针而不是复制对象，并没有开辟新的内存地址），在选项发生冲突时以组件数据优先。\n1. 同名钩子函数将混合为一个数组，因此**都**将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。\n1. 值为对象的选项，例如 `methods`, `components` 和 `directives`，将被混合为**同一个**对象。两个对象键名冲突时，取组件对象的键值对。\n\n\n## 全局混入\n\n谨慎使用全局混入，因为一旦混入，将影响到**所有**之后创建的 Vue 实例。\n\n# 自定义指令\n\n使用 `Vue.directive()` 来创建全局自定义指令。在创建 Vue 实例时使用 `directive` 选项来创建局部自定义指令。\n\n格式如下：\n\n```js\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {   // 调用时加前缀 V-\n  // 当被绑定的元素插入到 DOM 中时\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n// 局部自定义指令\ndirectives: {\n  focus: {   // 调用时加前缀 V-\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n``` \n\n``` html\n<input v-focus>\n```\n\n# 渲染函数 & JSX\n\n## 基础\n\n渲染函数的作用是**渲染视图**，又称为`render 函数`。\n\n在 `vue-cli` 的 `webpack` 模板中的 `main.js` 中有以下声明：\n```js\nnew Vue({\n  el: '#app',\n  components: { App },  // 表示实例中有哪些组件可用\n  template: `<App/>`    // 表示要渲染哪些可用组件，这里形如 <App></App>\n})\n```\n以上代码中，\n\ncomponents 选项，包含 Vue 实例可用组件的哈希表。即 `components` 选项表示声明了实例中存在哪些组件。（参考[官方 issue][template-role]、[API:components选项][api-components]）\n\ntemplate 选项，表示选项的值`一个字符串模板`作为 Vue 实例的标识使用。模板将会**替换**挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。即该选项`表示要渲染哪些组件`。（参考[官方 issue][template-role]、[API:template选项][api-template]）\n\n以对 `components` 和 `template` 两个选项作用的理解，那么 `渲染函数` 代替的是 `template` 选项的作用，达到**定制化渲染**的作用。\n\n## 虚拟 DOM \n\nVue 通过建立一个**虚拟DOM**对真实的DOM发生的变化保持追踪。在 `render 函数` 中传入一个 `createElement 函数(简写为 h)`（[vue-JSX 使用文档][h-injection]、[Vue 文档][JSX]）来生成模板。\n\n`createElement 函数` 返回的是 `虚拟节点 VNode`， 它包含的信息会告诉 Vue 页面上需要渲染什么样的节点，以及子节点。\n\n## createElement 参数\n\n`createElement` 参数至多包含 3 个部分。\n\n**一个**要创建的元素标签名（类型：字符串/对象/函数返回值）；\n\n**一个**包含模板相关属性的 data 对象（类型：对象）；\n\n**一个**子节点（类型：字符串/数组），且这个子节点也是由另外的 `createElement 函数` 构成。\n\n其中，data 对象和子节点为可选参数。\n\n格式如下：\n\n```js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签字符串，组件选项对象，或者一个返回值\n  // 类型为 String/Object 的函数，必要参数\n  'div',\n\n  // {Object}\n  // 一个包含模板相关属性的数据对象\n  // 这样，可以在 template 中使用这些属性。可选参数。\n  {\n    // 此处写入数据对象\n    // https://cn.vuejs.org/v2/guide/render-function.html#深入-data-对象\n  },\n\n  // {String | Array}\n  // 子节点 (VNodes)，由 `createElement()` 构建而成，\n  // 或使用字符串来生成“文本节点”。可选参数。\n  [\n    '先写一些文字',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {  // 组件 props\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n## JSX\n\nJSX 最初出现在 `React.js` 中。JSX 语法指在 JS 代码中**直接**嵌入 HTML。JSX 的出现颠覆了以往的 MVC 思想，MVC 是侧重视觉上分离，注重 HTML 与 JS 的分离。但局限性就是，当有大量的 JS 和 HTML 模板时，其中错综复杂的逻辑将导致难以维护。\n\nReact 官方认为应该**侧重于关注组件整体**，应该**从功能上**将各个组件分离开来，组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化。正是基于侧重`从功能上分离组件`的思维，诞生了 JSX 语法。JSX 把 HTML 模板直接嵌入到 JS 中，侧重的是从功能上将各个组件分离，注重的是组件整体。JS 本身不支持直接包含 HTML 的语法，所以要通过工具将 JSX 编译(在 Vue 中使用[babel 插件][babel-plugin-transform-vue-jsx])输出为 JS 代码才能使用。\n\n在 Vue 中使用 JSX 可缓解大量调用 `render 函数`的情况。\n\n[Vue-JSX 使用文档][vue-jsx]\n\n\n\n[template-role]:https://github.com/vuejs-templates/webpack/issues/575\n\n[api-components]:https://cn.vuejs.org/v2/api/#components\n\n[api-template]:https://cn.vuejs.org/v2/api/#template\n\n[h-injection]:https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection\n\n[JSX]:https://cn.vuejs.org/v2/guide/render-function.html#JSX\n\n[vue-jsx]:https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage\n\n[babel-plugin-transform-vue-jsx]:https://github.com/vuejs/babel-plugin-transform-vue-jsx\n"}