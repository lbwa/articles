---
title:      "比较 CommonJS 与 ES6 Module 语法"
subtitle:   "简要分析了CommonJS与ES6 Module语法的异同之处"
date:       2018-02-27
author:     "Bowen"
tags:
    - 前端开发
    - JavaScript
    - 模块
---

> 在学习`Vue.js`中模块开发时，遇到一些关于 `CommonJS` 与`ES6`模块语法加载机制异同的相关知识欠缺的问题，经过查阅后补全知识缺口。现将自己对二者的异同之处的理解总结复盘如下。

# CommonJS 简介

在 CommonJS 中每一个文件都是一个**模块**。

### 定义模块

在每个模块（文件）内，module 变量表示当前模块，module变量的 exports 属性即为当前模块暴露给外部的数据接口，该值为一个对象。

### 加载模块

在 CommonJS 中，加载模块即是调用用`module.exports`变量的**值的副本**。

使用`require('模块名或地址')`来加载模块。其中参数类型为字符串，默认参数文件类型为`.js`。

> `/` 表示从根目录开始，是相对于根目录的路径（对于项目来说，这是[绝对路径][0]）。例如，`/dist`表示**根目录**下的`dist`文件夹。可类比`HTML`文档中的`<base>`标签，其所在文档之后的标签中的`/`表示从`<base>`指定的默认地址（指定了根目录）开始查找。

> `./` 表示相对路径，即当前模块所在目录下。

> `../` 表示相对路径，即当前模块的上一级父目录。

### 入口文件（模块之间的调用是如何开始的）

一般有一个主文件（入口文件），在项目文件夹下的`index.html`中引入加载该文件，之后在入口文件中会触发加载其他模块。

### 模块缓存/加载机制

CommonJS 模块的重要特性是**加载时执行**，即脚本代码在调用`require()`加载模块的时候，就会全部执行模块，然后在内存生成一个对象（该对象包含如模块id，该模块输出对象等等一系列信息）。

第一次加载某个模块时，Node 会**缓存**该模块的输出值。在加载该模块输出值时调用的是**缓存**中该模块的`module.exports`值的**副本**。即使再次执行`require()`，也不会再次执行该模块，而是到**缓存**之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。即**CommonJS模块可多次加载，但只执行一次。**

# CommonJS 与 ES6 模块的异同

## 共同点

### 模块之间同步加载

CommonJS 加载模块是同步的，只有当前模块加载完毕，才会开始加载下一个模块。

ES6 模块[加载规则][1]在浏览器中是模块之间是同步的，对于渲染DOM是异步的。即浏览器中`<script>`的`type="module"`相当于默认开启了`<script>`的`defer`属性（不阻塞DOM渲染，在渲染完成后执行模块），在 Node 中的 ES6 模块加载机制与在浏览器中的处理方法是**相同**的。

二者模块加载的顺序是**按照代码出现的顺序同步加载**的。

### 查找模块

>目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。

如果模块名不含路径，那么 `import` 命令会去`node_modules`目录寻找这个模块。

在使用`vue-cli`构建`vue`单文件组件时，有部分JavaScript文件有以下一行代码：

```js
// 在构建时，若只有模块名，则将会去 node_modules 目录下寻找vue模块
// 当前模块的 Vue 变量将被赋值被加载模块的默认输出对象（即export default {...}）
import Vue from 'vue'
// 另一种写法如下
import Vue from "../node_modules/vue/dist/vue.min.js"
// 上面import语句与下句调用require方法，作用相同
// 不同之处在于import只能用在模块开头，require方法可用在模块任意位置
const vue = require('vue')
```

如果模块名包含路径，那么`import`命令会按照路径去寻找这个名字的脚本文件。

如果脚本文件省略了后缀名，比如`import './foo'`，Node 会依次尝试四个后缀名：`./foo.mjs`、`./foo.js`、`./foo.json`、`./foo.node`。如果这些脚本文件都不存在，Node 就会去加载`./foo/package.json`的main字段指定的脚本。如果`./foo/package.json`不存在或者没有main字段，那么就会依次加载`./foo/index.mjs`、`./foo/index.js`、`./foo/index.json`、`./foo/index.node`。如果以上四个文件还是都不存在，就会抛出错误。

在webpack设置模块（`webpack.config.js`）中的输出对象（`module.exports = {...}`）中的路径查找（如对象中的output选项），`__dirname`（最前是两个下划线，如同ES6中`__proto__`属性）表示当前模块文件所在的文件夹路径，`__filename`表示当前模块文件所在的文件夹路径加文件名。

> 拓展：Node原生提供一些核心模块：http、fs、os、path、url、querystring等，Node在加载核心模块时，不需要传入路径，因为`Node.js`已经将核心模块的文件代码编译到了二进制可执行文件中，核心模块在Node中加载的优先级是最高的。

### 作用域

他们每个模块都具有自己独立的作用域，模块中的代码是在模块内部的作用域执行的。模块中的顶层变量外部是不可见的。
　　
## 不同点

### 对被加载模块的输出值的引用方式不同

>CommonJS 模块输入的是被加载模块**输出值的副本**，ES6 模块输入的是被加载模块**输出值的引用**。

具体解释为 CommonJS 输入的是 Node 缓存中被加载模块的输出值的副本，那么在被加载模块中值的变化将**不会影响**到输入值。此时，模块的引入值与被加载模块的输出值已经没有直接的联系。

> 拓展：将CommonJS被加载模块的输出值设为输出一个**取值函数**，而不是一个静态值，那么此时，该输出值可起到动态引用被加载模块内部变量的作用。这与ES6 模块的输出效果相同。

ES6 模块中**不会缓存**第一次加载模块的结果，而是动态地去被加载的模块取值。当前模块引入变量总是**绑定**在其所在模块（被加载模块）。模块引入的变量是**只读**的，且本质为一个被加载模块的输出值的**引用**。

### 二者的运行机制的差异

>CommonJS 模块是运行是加载，ES6 模块是编译时的输出接口。

ES6 模块在遇到加载命令`import`就会生成一个**只读引用**，等到脚本真正执行至取值语句时，再根据这个只读引用，到被加载的那个模块中取值。即**使用值时才取值，否则只建立数据引用**。

CommonJS 模块的加载机制详见前文[模块缓存/加载机制][2]

## 参考

[ECMAScript 6 入门][3]

[0]:https://stackoverflow.com/questions/24028561/relative-path-in-html

[1]:http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99

[2]:https://lbwa.github.io//blog/writings/180227-compare-commonjs-with-esm/#模块缓存-加载机制

[3]:http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99
