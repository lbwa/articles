[{"to":"180707-pwa-fundamentals","data":"\n`PWA` 意为 `progressive web application`，即渐进式网络应用。\n\n## 解决的问题\n\n### 对于 `web App`\n\n1. `PWA` 可离线访问应用，体验接近 `Native App`，2017 年 `twitter` 的 `PWA` 显著降低了用户跳出率。\n\n2. `PWA` 具备推送消息的能力，可即时加载和定期更新。\n\n### 对于 `Native App`\n\n1. `PWA` 因存在 `manifest` 清单而具有 `SEO` 增强，可被搜索引擎发现，可安装于移动端桌面。\n\n    - `native app` 天生是封闭的环境，故不存在 `SEO` 能力，`PWA` 在浏览器环境下运行，存在 `manifest` 清单,故具有 `native app` 所不具有的 `SEO` 能力。\n\n2. `PWA` 无需借助应用商店安装，可直接使用。\n\n3. `PWA` 无需手动更新，它借助 `Service Worker` 保持最新状态。\n\n### 对于以上二者\n\n1. `PWA` 兼容任何具有浏览器的设备。因为它只依赖于支持 `Service Worker` 的浏览器运行。\n\n## 基本架构\n\n### `App shell`\n\n`App shell` 是驱动 `PWA` 的 ***最小*** `HTML`，`CSS`，`JS`的集合。可理解为 `App shell` 是 `PWA` 运行的 ***基础架构***。`PWA` 中所有的数据层内容都将在 `App shell` 中运行。\n\n`App shell` 架构将应用核心架构与 UI 和 数据层 分离。应用核心架构与 UI （即 `App shell` ）在初次加载时就被缓存。在后续加载应用时， ***只需要*** 请求更新的数据层内容即可。应用的核心架构和 UI 是从 ***本地缓存*** 中读取，避免了多次重复请求应用核心和 UI。此时的 `PWA` 因仅需要请求数据层数据而具备了快速启动的能力。\n\n### `Server Worker`\n\n`Service Worker`（又称[服务工作线程][service-worker]）运行在 ***独立*** 于浏览器主线程的 `ServiceWorkerGlobalScope` 上下文环境（即浏览器后台）中。它现阶段支持 ***离线体验***，包含推送通知和后台同步等功能。\n\n1. 它属于 JS 工作线程的一种，但 ***不具备*** 访问 `DOM` 的能力。它通过 `postMessage` 接口来与控制的页面通信。\n\n2. 本质是一种可编程的网络代理。可控制页面所发网络请求的处理方式。\n\n3. 它在闲置时会被终止，在有需要时重启。所以不应依赖 `Service Worker` 的 `onfetch` 和 `onmessage` 处理全局状态。\n\n4. 它是基于 `Promise` 对象的实现。\n\n\n***notice***: `./service-worker.js` 的 `register` 注册路径是基于 ***应用*** 的 ***根路径***，而不是相对于以上注册程序代码的路径。因为 `Service Worker` 的作用域是由应用的根路径文件夹所定义的。（[Google Developers][cache sw]）\n\n另附截止至本文发表之时 `Service Worker` 的兼容性列表 —— [Is Service Worker ready][Is Service Worker ready]。\n\n### `Service Worker` 与 `App shell`\n\n基于 `Service Worker` 的可离线使用，消息推送，网络请求代理等特性，我们可以使用 `Service Worker` 来缓存 `App shell` 来实现 `PWA` 的渐进增强。\n\n## `Service Worker` 的生命周期\n\n`Service Worker` 的生命周期完全独立于网页。`Service Worker` 在第一次打开应用页面界面时， 在页面的 JS 脚本中注册。（[Google Developers][sw-lifecycle-google docs]，[MDN][sw-api-mdn]）\n\n![sw-lifecycle](https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/pwa-fundamentals/sw-lifecycle.png)\n\n### Install event\n\n该事件主要用于缓存 `App shell`。\n\n- 在安装 `Service Worker` 时，第一个触发的事件就是 [install][sw-lifecycle-install] 事件，在该事件完成后，可认为 `Service Worker` 安装完成。\n\n```js\n// app.js\n// 注册 Service worker\n// https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_14\nif ('serviceWorker' in navigator) {\n  navigator.serviceWorker\n    .register('./service-worker.js')\n    .then(() => console.log('Service Worker registered !', reg.scope))\n    .catch((err) => console.error('Service Worker registered unsuccessfully !', err))\n}\n```\n\n```js\n// service-worker.js\nconst cacheName = 'PWA-application'\nconst filesToCache = [\n  '/',\n  '/index.html',\n  // ...\n]\n\nself.addEventListener('install', evt => {\n  console.log('[ServiceWorker] Install')\n  // ExtendableEvent.waitUntil() 用于延长时间的寿命从而阻止浏览器在事件中的异步操作\n  // 完成之前终止服务工作线程\n  evt.waitUntil(\n    // caches 对象是用于开辟存储容器。另注，是调用 caches 开辟容器而不是 Cache 或 cache\n    // caches.open 返回匹配 cacheName 的 cache 对象的 Promise。\n    caches.open(cacheName).then(cache => {\n\n      // cache 参数即为匹配的 cache 对象\n      console.info('[ServiceWorker] Caching app shell')\n\n      // addAll 用于缓存当前 URL 数组（即 request[]）中每一项。\n      return cache.addAll(filesToCache)\n    })\n  )\n})\n```\n\n在示例代码中 [cache][caches] 对象为缓存的 `Request / Response` 对象提供 ***存储容器***。`cache.addAll` 方法具有原子性，任意一个文件缓存失败，整个缓存步骤也将失败。\n\n### Activate event\n\n该事件主要用于更新 `cache` 容器。\n\n- 在安装事件完成后，会触发一个 [activate][sw-lifecycle-activate] 激活事件，`activate` 事件会在新的 `Service Worker` 启动时触发（旧版本 `Service Worker` 不触发该事件）。它触发时会清理与之前版本的 `Service Worker` 相关联的旧资源与旧缓存。\n\n```js\n// service-worker.js\n// 只在不存在或旧版本 `Service Worker` 不再与任何页面关联时触发，否则进入 `waiting\n// to activate` 阶段。\nself.addEventListener('activate', e => {\n  console.log('[ServiceWorker] Activate')\n  e.waitUntil(\n    // 循环所有的 cache 容器\n    caches.keys().then(keyList => {\n      return Promise.all(keyList.map(key => {\n        // 删除所有除当前 cache 容器以外的所有容器，又因为 activate 事件仅在新版本\n        // `Service Worker` 使用时才被调用，即可保证 Service Worker 在 App shell 更\n        // 改时更新 cache 容器，删除旧容器\n        if (key !== cacheName) {\n          console.log('[Service worker] Removing old cache', key)\n          // caches.delete 用于删除开辟的 cache 容器\n          return caches.delete(key)\n        }\n      }))\n    })\n  )\n  return self.clients.claim()\n})\n// 以上代码保证在 App shell 更新时，即启用新的 `Service Worker` 时更新 cache 缓存容器。\n// 另外必须在 `Service Worker` 文件顶部重新定义 `cacheName` 变量。\n```\n\n***Notice***: 如果现有的 `Service Worker` 已启用，那么新版本仅会在后台安装，但 ***不会*** 被激活，此时被称为 [worker in waiting][sw-lifecycle-waiting-stage]。直到已加载的页面不再使用旧的 `Service Worker` 才会激活新的 `Service Worker`。只要旧版本的 `Service Worker` 不再与任何页面关联。那么新版本就会替代旧版本的 `Service Worker` 成为 `active worker`。旧版本及其关联资源（缓存）就会被清除。\n\n[service-worker]:https://developers.google.com/web/fundamentals/primers/service-workers/\n\n[Is Service Worker ready]:https://jakearchibald.github.io/isserviceworkerready/\n\n[cache sw]:https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/#_15\n\n[caches]:https://developer.mozilla.org/zh-CN/docs/Web/API/Cache\n\n[sw-lifecycle-google docs]:https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn\n\n[sw-api-mdn]:https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API\n\n[sw-lifecycle-install]:https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#install\n\n[sw-lifecycle-activate]:https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#activate_1\n\n[sw-lifecycle-waiting-stage]:https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle?hl=zh-cn#waiting\n\n## 读取 App shell 缓存\n\n`Service Worker` 通过拦截 `PWA` 请求来决定从缓存中读取 `App shell`。仅当缓存中不存在 `App shell` 时，`Service Worker` 才会默认使用原生 `fetch` API 来请求源服务器获得一个副本。\n\n```js\nself.addEventListener('fetch', evt => {\n  console.log('[ServiceWorker] Fetch', evt.request.url)\n  evt.respondWith(\n    // caches.match 评估是否存在 evt.request 缓存\n    caches.match(evt.request).then(response => {\n      return response || fetch(evt.request)\n    })\n  )\n})\n```\n\n![sw-fetch](https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/pwa-fundamentals/sw-fetch.png)\n\n当 `Cache storage` 中不存在指定 `cacheName` 的 `cache` 容器时，将发起网络请求，最终将缓存新的 `App shell` 于指定的 `cache` 容器中。\n\n![sw-offline](https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/pwa-fundamentals/sw-offline.png)\n\n`Service Worker` 存在指定的 `App shell` 时，将从指定的 `cache` 容器中读取。\n\n### 边界情况\n\n1. 缓存取决于为每次更改更新缓存容器键名\n\n以上 `Service Worker` 读取 `App shell` 时，仅当 `cacheName` 发生改变时，才会更新 `App shell`。否则将保持使用旧的缓存。即缓存取决于缓存键名。\n\n2. 更新容器却更新了整个缓存容器\n\n这样有一个缺点，就是只要一个文件发生变化时，为了更新缓存就不得不使整个 `cache` 容器失效，而重新下载新的 `App shell`。这样是有很大的性能浪费的。\n\n解决方案可以是将 `cacheName` 指定为根据内容而生成的文件名。即 `content hash` 文件名。\n\n3. 浏览器自身缓存可能阻止 `Service Worker` 的缓存更新\n\n在初次安装处理程序时（`install handler`）浏览器将不会返回从浏览器缓存中返回数据，而是一定会执行 `HTTPS` 请求（补充：`Service Worker` 除本地服务器外仅支持 `HTTPS` 协议。）。这样做的目的就是为了保证安装的 `App shell` 一定是最新版。否则，浏览器将在初次安装 `App shell` 时使用旧版本 `App shell`。这将导致 `Service Worker` 永远得不到更新。因为浏览器在该情境下在一直循环使用旧版本。\n\n推荐的方案是在安装 `App shell` 时总是请求源服务器。\n\n4. 谨慎地在生产环境中执行缓存优先策略（`cache-first`）\n\n在生产环境中执行缓存优先策略时，将导致任何读取缓存的时候都不会查询网络。这将导致只要本地有缓存，就几乎不可能更新本地的 `Service Worker` 配置中的 `App shell`。\n\n因为 `Service Worker` 配置是取决于定义注册该 `Service Worker` 的 ***那个*** 文件，而不是服务器。（本文中指的是当时注册该 `Service Worker` 的 `./service-worker.js`）（此处原文为 `Since the configuration depends on where it was defined`）\n\n处理以上四点边界情况推荐使用 [sw-precache] 或 [workbox]（Google 推荐 `workbox`） 之类的内容库来管理缓存。\n\n[sw-precache]:https://github.com/GoogleChrome/sw-precache\n\n[workbox]:https://github.com/GoogleChrome/workbox\n\n## Reference\n\n- [Your first progressive web app]（Google Developers）\n\n- [Service Worker]（Google Developers）\n\n- [Service Worker lifecycle]（Google Developers）\n\n- [Debugging service workers]（Google Developers）\n\n- [Using service worker]（MDN）\n\n- [CacheStorage.open]（MDN）\n\n- [CacheStorage.delete]（MDN）\n\n- [CacheStorage.keys]（MDN）\n\n- [Cache.addAll]（MDN）\n\n[Your first progressive web app]:https://developers.google.com/web/fundamentals/codelabs/your-first-pwapp/\n\n[Service Worker]:https://developers.google.com/web/fundamentals/primers/service-workers/\n\n[Service Worker lifecycle]:https://developers.google.com/web/fundamentals/primers/service-workers/lifecycle\n\n[Debugging service workers]:https://codelabs.developers.google.com/codelabs/debugging-service-workers/#0\n\n[using service worker]:https://developer.mozilla.org/zh-CN/docs/Web/API/Service_Worker_API/Using_Service_Workers\n\n[CacheStorage.open]:https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/open\n\n[CacheStorage.delete]:https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/delete\n\n[CacheStorage.keys]:https://developer.mozilla.org/zh-CN/docs/Web/API/CacheStorage/keys\n\n[Cache.addAll]:https://developer.mozilla.org/zh-CN/docs/Web/API/Cache/addAll\n"},{"to":"180612-js-design-pattern","data":"\n本文是 《[Learning JavaScript Design Patterns][Learning JavaScript Design Patterns]》的读书笔记。该书的作者是谷歌工程师的 `Addy Osmani`。撰写本文的目的就是为了学习参考前辈的编程开发思维，并结合自己的理解来加强自己的知识体系。另外，这本书中提到的 `GoF book` 即 `Gang Of Four book` 指的是 `Design Patterns` 这本书。该书列举了编程领域常见的 23 种编程模式和相应的设计原则。\n\n[Learning JavaScript Design Patterns]:https://addyosmani.com/resources/essentialjsdesignpatterns/book/\n\n|创造性设计模式| 描述 |\n|---|---|\n|factory method|可根据不同的参数数据或参数事件对象而实例化生成不同的实例。|\n|prototype|一个包含类的所有实例共享的属性和方法的对象。|\n|builder|将对象的构建方法和表象形式分离，并重视创建相同类型的对象。|\n|singleton|在全局作用域中只有唯一的一个实例的类。|\n|abstract factory|在没有具体类的详细细节的情况下创建多个相似的类的实例，即可传入具体类来让工厂决定是否实例化。|\n|abstract class|一个永不会被实例化为具体对象的类。如 `水果` 是抽象概念，即抽象类，`苹果` 有实物，即具体类。|\n\n抽象类（[wiki][wiki-class]）既可包含抽象方法也可包含具体方法。只有当抽象类的所有抽象方法都被子类实现后，子类才能被实例化。\n\n[wiki-class]:https://zh.wikipedia.org/wiki/类_(计算机科学)#抽象类\n\n```js\n/**\n * 抽象类存在的意义：\n * 1. 抽象类表明一个功能的抽象集合，它不能被直接实例化，因为它仅用于在思维方面，表示功能\n * 设计架构上的一个抽象化概念。如 `水果` 这一抽象概念，`水果` 这一 `事物本身` 在现实中\n * 没有实物对应。\n * 2. 抽象方法，它表示继承的抽象类的子类 必须 实现的（或理解为功能）方法。在实现抽象类的\n * 所有方法（功能）之后，子类即实现了将抽象类所有功能在现实世界中的具体化。此时子类才能\n * 被真正的实例化。如 `苹果` 实现了 `水果` 在现实世界中的具体体现，它是抽象类 `水果` 的\n * 一个子类，并实现了  `水果` 的抽象方法（比如吃），那么 `苹果` 这一子类即可实现实例化为\n * 一个苹果。\n */\n\n// Vehicle 类是抽象类，不能直接实例化，仅表示 `载具` 这一抽象化概念\nclass Vehicle {\n  // 抽象方法，表示在思考分析方面，抽象类的某一个功能，可以根据不同的子类有不同的实现方法。\n  // 必须被子类实例化，否则子类不应该被实例化\n  detail () {\n    throw new Error('你应该在子类中定义该方法。')\n  }\n}\n\nclass Car extends Vehicle {\n  constructor (options) {\n    super()\n    this.brand = options.brand || 'Default brand'\n    this.color = options.color || 'Default color'\n  }\n\n  // 在子类中实现抽象类的功能，每个子类都可以有自己的功能实现。\n  // 原理：原型链（对于对象来说）与作用域链（对于变量来说），使用子类的同名原型方法来屏\n  // 蔽抽象类的同名原型方法\n  detail () {\n    console.log(`Vehicle\\'s brand is ${this.brand}.`)\n    console.log(`Vehicle\\'s color is ${this.color}.`)\n  }\n}\n\nconst car = new Car({\n  brand: 'Benz',\n  color: 'sliver'\n})\n\ncar instanceof Car // true\ncar instanceof Vehicle // true\n```\n\n## 工厂模式\n\n关键词：解耦实例化与类、包含固定类（与抽象工厂对比）。\n\n即 `Factory Pattern`。\n\n工厂模式的 `工厂` 是创建 `产品` 的地方，其目的是将产品的创建于产品的使用 ***分离***。实际中，是对构造方法封装的抽象（`abstract`），是对一个功能的抽象集合。它以特定接口实现对创建对象的具体类进行封装，由工厂来决定是否执行实例化或执行哪一个实例化路径。微观上，该模式提高了代码复用性，避免创建相似对象时产生大量重复代码；宏观上，使得被封装功能与应用整体比较时，工厂将被抽象为一个概念。这样在架构应用时整体思考只需要考虑抽象化后的功能，而不必过于纠结该功能的具体实现。\n\n外部调用者只关心该工厂所暴露给外部的使用接口。即外部使用者只关心调用该工厂即可完成特定的相似对象创建或相似的功能实现，并不关心其中的内部实现。\n\n### 实现\n\n```js\n// 以下 Car 类和 Truck 类也可以是抽象类，即不能被实例化的类，子类来实现抽象类的接口（原型方法）\nclass Car {\n  constructor (options) {\n    this.type = 'car'\n    this.brand = options.brand || 'Default brand'\n    this.color = options.color || 'Default color'\n  }\n}\n\nclass Truck {\n  constructor (options) {\n    this.type = 'truck'\n    this.brand = options.brand || 'Default brand'\n    this.color = options.color || 'Default color'\n  }\n\n  transport () {\n    return `I can transport vehicle`\n  }\n}\n\n// 外部只关心调用该工厂方法即可实现特定功能\nclass CarFactory {\n  constructor () {\n    // 默认类\n    Reflect.defineProperty(this, '_vehicle', {\n      enumerable: false,\n      writable: true,\n      value: Car\n    })\n  }\n\n  createVehicle (options) {\n    // 将类的实例化统一集中管理，通过传入的参数选择不同的实例化路径\n    if (options.type === 'truck') this._vehicle = Truck\n\n    return new this._vehicle(options)\n  }\n}\n\n```\n\n外部调用工厂方法：\n\n```js\n// 外部调用只关心工厂方法的结果\nconst ins = new CarFactory()\n\nconst car = ins.createVehicle({\n  type: 'car',\n  brand: 'Panda',\n  color: 'rainbow'\n})\ncar instanceof Car // true\n\nconst truck = ins.createVehicle({\n  type: 'truck',\n  brand: 'Benz',\n  color: 'sliver'\n})\ntruck instanceof Truck // true\n```\n\n以上示例代码展示了根据传参不同，而执行不同的实例化路径。代码中将判断路径的这个行为封装为一个工厂方法，实行集中管理。后续若需要修改某一类时，只需要修改工厂方法即可。\n\n若不使用该工厂方法，那么在后期需要删除该类时，需要修改所有引用该类的地方，而使用了工厂方法后，删除该类只需要修改工厂方法即可，即将该构造类与其他代码解耦，将该构造类的实例化通过工厂模式来抽象为一个功能模块。\n\n### 实际应用\n\n适用场景：\n\n1. 在创建对象或模块会涉及高复杂度逻辑时，可使用工厂模式解耦（创建者与使用者）并简化创建逻辑。\n\n2. 需要根据不同的传入参数来实现不同的实例化路径时。\n\n3. 当我们需要建立大量具有相似属性的对象或组件时。\n\n4. （与 1 相似）当我们需要使用一些对象去与另一些对象实例组合时，可通过工厂模式实现简洁的组合接口。在组合时，调用这些工厂接口，可以解耦组合者与被组合者。\n\n### 工厂模式利弊\n\n- 优势\n\n    1. 以一个基础结构创建无限个新的结构相似的实例，解决了创建相似对象的问题。\n    \n    2. 以一个工厂类封装可能被复用的操作，避免重复代码。\n\n    3. 解耦功能接口（即具体类的实例）与调用者。通过工厂实例将二者联系。\n\n- 弊端\n\n    1. 每次增加、删除、修改功能，都要去修改具体类（可以是抽象类的子类）和工厂类（违背遵循 `开放封闭原则`）。若是增加功能，即在工厂内部添加新的原型方法，那么在一定程度上增加了不必要的应用复杂度。\n        \n        - 除非创建结构相似的对象并提供一个接口是代码设计的目标（指上文的工厂模式适用场景，如以抽象化功能为目标），否则都应该显式地使用构造函数来创建对象。这样可以避免不必要的性能开销（`unnecessary overhead`）。\n\n    2. 基于创建对象的行为通过接口被抽象化这一事实，那么这可能会为单元测试带来一些困难（因为外部无法感知内部实现）。至于有多困难取决于被抽象化的行为有多复杂。\n\n## 抽象工厂模式\n\n关键词：抽象实例化过程、本身不包含固定类、传入类、选择性实例化。\n\n即 `Abstract Factory`。\n\n### 含义\n\n1. 抽象工厂用于将一组相互独立的且他们有共同目标的工厂进行封装。从他们的一般用例（`their general usage`）中分离出对象的实现细节。\n\n2. 抽象工厂会 ***筛选*** 出符合条件的类，最终抽象工厂的具体工厂（`concrete factories`，即能够被实例化的工厂类）将只实例化符合条件的具体类。\n\n### 适用场景\n\n在系统必须独立于创建对象的方式或需要使用多种类型对象的情况下，应该使用抽象工厂。\n\n### 实现\n\n一个简单且容易理解的示例是下面的载具工厂示例 `AbstractVehicleFactory`。它实现了得到载具类型方法 `getVehicle` 和注册载具类型方法 `registerVehicle`。这个抽象工厂允许定义类似 `car` 或 `truck` 这样的载具类型，并且最终只有符合特定条件的载具类才能被具体工厂实现。\n\n```js\nclass AbstractVehicleFactory {\n  constructor () {\n    // 缓存载具类\n    Reflect.defineProperty(this, '_types', {\n      enumerable: false,\n      writable: true,\n      value: {}\n    })\n  }\n\n  // 静态方法常用于实现构造函数的某个功能，但该功能应该仅限在构造函数上被调用的情形下。\n  static getVehicle (type, customization) {\n    const Vehicle = this._types[type]\n\n    // 若存在已经注册的载具类，那么执行该载具类\n    return Vehicle ? new Vehicle(customization) : null\n  }\n\n  static registerVehicle (type, Vehicle) {\n    // 获取传入的载具类的原型对象\n    const proto = Vehicle.prototype\n\n    // 只有符合特定条件的载具类才能被注册（注册之后才能实例化载具类）\n    if (proto.drive && proto.breakDown) {\n      // 注册符合特定条件的载具类，该类将用于具体工厂 getVehicle 中执行实例化\n      this._types[type] = Vehicle\n    }\n\n    // 启用级联，用于链式调用\n    return this\n  }\n}\n```\n\n调用结果如下：\n\n```js\nAbstractVehicleFactory\n  .registerVehicle('car', Car)\n  .registerVehicle('truck', Truck)\n\n// 基于 Vehicle 抽象类实例化 Car 类\nconst car = AbstractVehicleFactory.getVehicle('car', {\n  brand: 'Panda'\n  color: 'red'\n})\n\n// 基于 Vehicle 抽象类实例化 Truck 类\nconst truck = AbstractVehicleFactory.getVehicle('truck', {\n  brand: 'Benz',\n  color: 'sliver'\n})\n```\n\n## 构造函数模式\n\n关键词：类实例化、原型对象、原型链。\n\n即 `Constructor Pattern`。\n\n解决创建多个结构相似的对象的问题。每次构造函数被实例化，都会在内存中开辟新的存储区域，即每次都会创建一个新的对象。\n\n```js\nclass Person {\n  constructor (name, age, gender) {\n    this.name = name\n    this.age = age\n    this.gender = gender\n  }\n}\n\nconst john = new Person('John', 20, 'male')\nconst mary = new Person('Mary', 20, 'female')\n\n// 构造函数模式通过 constructor 原型属性解决了 `不知道是谁的实例` 的弊端。\njohn.__proto__.constructor === Person // true\nmary.__proto__.constructor === Person //true\n\njohn instanceof Person // true\nmary instanceof Person // true\n```\n\n### 与原型对象结合\n\n将 `构造函数模式` 与 `原型对象` 相结合，那么可以实现基于构造函数对象的原型对象创建出不同的构造函数实例，即根据子类的不同可创建出不同的原型继承链。\n\n```js\nclass Person {\n  constructor (name, age, gender) {\n    this.name = name\n    this.age = age\n    this.gender = gender\n  }\n\n  // 原型方法，它被所有 Person 的实例以及 Person 的子类所共享\n  say (property) {\n    const detect = `${property}` in this\n    if (!detect) {\n      throw new Error('parameter must be a string of `name, age, gender`')\n      return\n    }\n\n    return this[property]\n  }\n}\n\nclass SuperPerson extends Person {\n  constructor (name, age, gender) {\n    super(name, age, gender)\n  }\n\n  // ... 子类的原型方法\n}\n\nconst jack = new SuperPerson('Jack', 20, 'male')\nconst lily = new SuperPerson('Lily', 20, 'female')\n\n// say 方法是父类原型方法，能被任何子类实例通过原型链访问\n'say' in jack // true\n'say' in jack.__proto__ // true\njack.hasOwnProperty('say') // false\njack.__proto__.hasOwnProperty('say') // false\n\n'say' in lily // true\n'say' in lily.__proto__ // true\nlily.hasOwnProperty('say') // false\nlily.__proto__.hasOwnProperty('say') // false\n```\n\n以上代码实现了基于原型链的继承方案实现。使得创建的每个 `SuperPerson` 实例都继承过了父类 `Person` 的原型方法。\n\n## 原型模式\n\n关键词：共享属性、共享方法、原型链。\n\n即 `Prototype Pattern`。\n\n以一个对象作为原型对象，该对象包含所有实例所共有的属性和方法。\n\n```js\nconst car = {\n  name: 'Benz',\n\n  drive () {\n    console.log('I am driving!')\n  }\n}\n\nconst yourCar = Object.create(car)\n\nyourCar.name // 'Benz'\nyourCar.drive // 'I am driving!'\n```\n\n示例代码中，`Object.create` 指定了以参数对象为新对象的原型对象。那么由 `Object.create(car)` 创建的所有新对象都共享 `car` 对象的所有属性和方法。\n\n## 模块模式\n\n关键词：私有变量、公共接口。\n\n与外观模式不同的是，模块模式侧重私有变量的保护。外观模式侧重内部系统的抽象。\n\n即 `Module Pattern`。\n\n在 JS 中实现模块（即一个拥有公共接口的封闭命名空间）的方式：\n\n1. 模块模式\n\n2. 对象字面量\n\n3. AMD 模块\n\n4. CommonJS 模块\n\n5. ES 模块语法\n\n### 对象字面量\n\n```js\nconst myModule = {\n  property: 'some value',\n\n  fu () {\n    console.log('I\\'m a function in Object')\n  }\n}\n\nmyModule.property // some value\nmyModule.fn // I'm a function in Object\n```\n\n- 利：示例代码中 `myModule` 构成了一个功能集合（模块），方便调用。\n- 弊：模块中的键值对可被外部任意修改，不具有安全性。\n\n### 模块模式\n\n为了解决对象字面量的无法实现私有变量的问题，模块模式利用 ***闭包***（作用域链）原理实现私有变量，保护模块内部变量无法从模块外部修改。\n\n```js\nconst myModule = (function () {\n  // 私有变量，只能被模块内部修改，对外部不可见。\n  let counter = 0\n\n  // 公有方法和属性，是模块外部访问内部变量的唯一渠道。\n  return {\n    running () {\n      return ++counter\n    },\n    reset () {\n      counter = 0\n      return counter\n    }\n  }\n})()\n```\n\n示例代码中，私有变量 `counter` 因公有方法保持了对其引用，故在函数执行完成后，仍存在于内存中直至公有方法或属性的生命周期结束。\n\n模块模式在 `jQuery` 等一些 `JS` 库中都有广泛的应用。\n\n另外还存在一种模块模式的变种模式。\n\n1. 传入参数\n\n```js\nconst myModule = (function (jQuery, lodash) {\n  function reviseHtml () {\n    jQ('.container').html('test')\n  }\n\n  function printMin () {\n    console.log(_.min([1, 2, 3]))\n  }\n\n  return {\n    revise: reviseHTML,\n    print: printMin\n  }\n\n  // 传入参数\n})(jQuery, _)\n```\n\n2. 返回模块对象\n\n```js\nconst myModule = (function () {\n  let module = {}\n  const privateVariable = 'Hello'\n  function privateFn () {}\n\n  module.publicVariable = 'World'\n  module.publicFn = function () {\n    privateFn()\n    console.log(privateVariable)\n  }\n\n  return module\n})\n```\n\n模块模式的应用技巧，将所有私有方法和属性统一，只通过公有接口暴露其键名。这样可直观展示出该模块的公有接口及其与私有方法或属性的关系。\n\n```js\nconst customModule = (function () {\n  let counter = 0\n\n  function addFunction () {\n    counter++\n    console.log(`Counter is ${counter}.`)\n  }\n\n  function minusFunction () {\n    counter--\n    console.log(`Counter is ${counter}.`)\n  }\n\n  function resetFunction () {\n    counter = 0\n    console.log(`Counter is ${counter}.`)\n  }\n\n  // 清晰展示了公有接口及其与内部变量的关系\n  return {\n    add: addFunction,\n    minus: minusFunction,\n    reset: resetFunction\n  }\n})()\n```\n\n### 模块模式利弊\n\n- 优势\n\n    1. 基于面向对象编程使得功能逻辑更为清晰。\n    \n    2. 保护了模块内部变量，该变量只能通过公有方法修改，无法通过模块外部修改。\n\n- 劣势\n\n    1. 可拓展性差，没有遵循设计模块的 ***开（放）（封）闭原则***（对拓展开放，对修改封闭）。该模块一旦建立，其功能就被固定，后期拓展该模块必须修改模块本身，这是违背开闭原则中的 `对拓展开放`。\n\n    2. 除非需要创建一个不希望后期被拓展的封闭模块，那么 1 就是劣势。\n\n    3. 模块模式的公有接口有被修改的风险。\n\n\n## 单例模式\n\n关键词：缓存实例、实例唯一。\n\n即 `Singleton Pattern`。\n\n在 `模块模式` 基础上发展而成的 `单例模式`，在实例化时，最多在全局只创建一个该类的实例。\n\n```js\nconst singleton = (function () {\n\n  // 实例化方法，可以是一个构造函数或模块\n  // （可选）可分离出 singleton 模块\n  // init 模块\n  function init () {\n    let privateNum = 10\n    const privateFn = function () {}\n\n    return {\n      num: privateNum,\n      fn: privateFn\n    }\n  }\n\n  // singleton 类的实例的缓存容器，必须以私有变量的形式存在于 singleton 模块中\n  let _instance = null\n\n  // singleton 类的公有方法\n  return {\n    // 该方法通过闭包形式保持了对实例缓存容器的引用，只有在不存在实例时才执行 init 初始化\n    getInit () {\n      // 缓存实例\n      _instance = _instance ? _instance : init()\n      // or _instance = _instance ? _instance : new Initialize()\n      return _instance\n    }\n  }\n})()\n\nconst ins1 = singleton.getInit() // { num: 10, fn: function () {} }\nconst ins2 = singleton.getInit() // { num: 10, fn: function () {} }\n\nins1 === ins2 // true\n```\n\n单例模式通过模块内部的一个变量 `instance` 来作为实例的缓存容器，通过判断是否存在实例缓存来决定是否执行实例化。据此实现全局只存在唯一一个 `singleton` 的实例的逻辑。\n\n### 单例模式适用场景\n\n1. 作用域中只应存在唯一一个具有公共接口的类的实例，比如创建弹窗。\n\n    ```js\n    const createDiv = (function () {\n      let div = null\n\n      return function () {\n        if (!div) {\n          div = document.createElement('div')\n          div.innerText = 'Hello world'\n          div.style.display = 'none'\n          document.body.appendChild(div)\n        }\n        return div\n      }\n    })()\n\n    document.querySelector('.btn').addEventListener('click', evt => {\n      // 即使是多次点击也是只有一个弹窗被创建\n      const div = createDiv()\n      div.style.display = 'block'\n    })\n    ```\n    以上代码保证了即使存在多次点击，也只会在第一次点击时创建弹窗元素。另外该效果也可使用函数防抖（[extension][debounce-function]）来实现，不同的是，只有在有限时间内的最后一次点击生效。但是超过有限时间仍然会创建多个弹窗元素。\n\n[debounce-function]:https://github.com/lbwa/lbwa.github.io/issues/10\n\n2. 在单例通过子类拓展后，使用者可以调用该拓展后的单例而不用修改使用者本身的代码。\n\n    ```js\n    singleton.getInit = function () {\n      if (this._instance === null) {\n        // 判断是否拓展单例\n        if (doSomething()) {\n          // 拓展单例\n          this._instance = new SubSingleton()\n        } else {\n          // 初始化单例\n          this._instance = new BasicSingleton()\n        }\n      }\n      return this._instance\n    }\n    ```\n\n     示例代码中，`SubSingleton` 是 `BasicSingleton` 的子类，具有与 `BasicSingleton` 相同的数据接口。\n\n### 通用的单例模式\n\n```js\nconst getInit = function (fn) {\n  let cache = null\n\n  return function (...args) {\n    // this 为调用该匿名包装函数的对象\n    // args 为调用该匿名包装函数时传入的 rest 参数\n    return cache || (cache = fn.apply(this, args))\n  }\n}\n```\n\n创建单例弹窗：\n\n```js\nconst createDiv = function (text) {\n  const div = document.createElement('div')\n  div.innerText = `${text}`\n\n  return div\n}\n\nconst initDiv = getInit(createDiv)\n\ndocument.querySelector('.btn').addEventListener('click', evt => {\n  // 匿名包装函数内 this 指向 .btn 元素，args 为 ['hello world']\n  initDiv('hello world')\n})\n```\n\n### 单例模式利弊\n\n- 优势\n\n    1. 使得类的实例化过程可控，即控制类的实例数量，保证作用域内只存在唯一的实例。实际上，在应用中只需要一个单例就可协调其他模块运作的情况下，都应该使用单例模式。\n\n    2. 单例可通过子类任意拓展，使用者在调用该拓展后的单例时也不用修改使用者本身的代码。\n\n### 单例模式的风险\n\n当在应用中经常使用单例时，这时应该重新评估自己的代码结构。这通常表明该单例模块要么过于与其他模块的逻辑耦合，要么在应用中过于分散。过度使用单例将导致范围过大的依赖关系，即 `debug` 成本增加。后期如要将单例修改为多个实例或移除单例都会很麻烦。\n\n## 观察者模式\n\n关键词：主体对象、观察者\n\n即 `Observer Pattern`。\n\n观察者模式：一个主体对象（`subject`）维护一个观察者对象（`observers list`）列表，并且主体对象对状态的任何修改都会被观察者对象 ***自动通知***。对主体对象修改状态的行为感兴趣的对象只需要接受观察者的通知即可。\n\n|基本概念|描述|\n|-------|----|\n|`Subject` 主体对象| 维护一个观察者列表，并能够添加或移除观察者。|\n|`Observer` 观察者 | 提供通知状态更新方法，在主体对象有任何修改状态的改变时，观察者将发出通知。|\n|`ConcreteSubject`|存储 `ConcreteObserver`。在主体对象状态改变时，向观察者广播通知。|\n|`ConcreteObserver`|存储对 `ConcreteSubject` 的引用，实现一个通知更新的接口，该接口将用于保持与 `ConcreteSubject` 的状态一致。|\n\n### 实现\n\n```js\n// 观察者缓存容器（列表）\nclass ObserverList {\n  constructor () {\n    this.observerList = []\n  }\n\n  add (observer) {\n    return this.observerList.push(observer)\n  }\n\n  remove (index) {\n    return this.observerList.splice(index, 1)\n  }\n\n  get (index) {\n    return this.observerList[index]\n  }\n\n  len () {\n    return this.observerList.length\n  }\n\n  indexOf (observer, startIndex = 0) {\n    const len = this.observerList.length\n    for (let i = startIndex; i < len; i++) {\n      if (this.observerList[i] === observer) {\n        return i\n      }\n    }\n    return -1\n\n    // same as `return this.observerList.indexOf(observer, startIndex)`\n  }\n}\n\n// 主体\nclass Subject {\n  constructor () {\n    // Subject 实例通过 observers 属性来维护观察者列表\n    // 即观察者缓存容器\n    this.observers = new ObserverList() // { observerList: [] }\n  }\n\n  addObserver (observer) {\n    this.observers.add(observer)\n  }\n\n  removeObserver (observer) {\n    // 传入的是某个之前被加入观察者容器中的 Observer　实例的引用的变量，故存在 index\n    const index = this.observers.indexOf(observer, 0)\n    return  this.observers.remove(index)\n  }\n\n  // 参数 context 可选，非重点。\n  // 此处重点是 Subject 实例状态改变时，触发容器中每个观察者的更新函数，即让他们发出通知。\n  notify (context) {\n    const len = this.observers.len()\n    for (let i = 0; i < len; i++) {\n      this.observers.get(i).update(context)\n    }\n  }\n}\n\n// 观察者\nclass Observer {\n  // 观察者通知类型原型方法，可在其中加入回调，以向这些对观察者通知感兴趣的对象发起通知\n  update (context) {\n    console.log('observer has been updated.')\n  }\n}\n```\n\n实例化如下：\n\n```js\n// concrete Subject\nconst sub = new Subject()\n\n// Concrete Observer\nconst obs = new Observer()\n\nsub.addObserver(obs)\n\n// 其中有几个 Observer 实例，update 就被调用几次\nsub.notify()\n// observer has been  updated.\n\nsub.removeObserver(obs)\n// 返回被删除的 obs 观察者实例\n```\n\n***注***：一个隐藏的弊端就是，以上代码中并未实现有·选择性的触发 `Observer` 实例的 `update` 函数。`notify` 函数是触发所有的 `Observer` 实例。\n\n示例代码中三者之间的关系如下图：\n\n![observer-pattern][observer-pattern]\n\n[observer-pattern]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/js-design-pattern/observer-pattern.svg\n\n## 发布/订阅模式\n\n关键词：发布者、`topic/event channel`、订阅者\n\n即 `Publish/Subscribe Pattern`。\n\n发布/订阅模式是观察者模式的变种。不同与观察者模式的是发布/订阅模式实现了一个 `主体/事件通道` ，它用于发布者和订阅者之间通信，解耦发布者和订阅者。\n\n### 实现\n\n```js\nclass Pub {\n  constructor () {\n    // 订阅者缓存容器，其中包含各类消息的缓存队列\n    this.caches = []\n\n    Reflect.defineProperty(this, '_uid', {\n      enumerable: false,\n      writable: true,\n      value: -1\n    })\n  }\n\n  publish (evt, ...args) {\n    if (!this.caches[evt]) return false\n\n    const subscribers = this.caches[evt]\n    let len = subscribers ? subscribers.length : 0\n    while (len--) {\n      subscribers[len].callback.apply(subscribers[len], args)\n    }\n\n    return this // pub 实例，启用级联，用于链式调用\n  }\n\n  subscribe (evt, callback) {\n    // 初始化消息类型为 evt 的缓存容器\n    if (!this.caches[evt]) this.caches[evt] = []\n\n    this.caches[evt].push({\n      uid: ++this._uid,\n      callback\n    })\n    // caches[evt]: [{uid: 0, fn}, {uid: 1, fnn}, ...]\n  }\n\n  unsubscribe (evt, uid) {\n    const cache = this.caches[evt]\n    const len = this.caches[evt].length\n\n    for (let i = 0; i < len; i++) {\n      if (cache[i].uid === uid) {\n        return cache.splice(i, 1)\n      }\n    }\n\n    return this // 启用级联，用于链式调用\n  }\n}\n```\n\n实例化后：\n\n```js\nconst pub = new Pub()\n\npub.subscribe('hello',() => console.log('I\\'m from hello'))\npub.subscribe('index',() => console.log('I\\'m from index'))\n\n// 只调用 hello 类别中的订阅者，而不是像观察者模式那样触发所有订阅者\npub.publish('hello') // I'm from hello\n\n// 只调用 index 类别中的订阅者\npub.publish('index') // I'm from index\n```\n\n***关键点***：示例代码中，`evt` 变量即是作为 `主题/事件通道` 的存在，它分离出了不同类型的消息通道，使得发出通知时只会触发相同类型下的订阅者。\n\n![publish-subscribe][publish-subscribe]\n\n[publish-subscribe]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/js-design-pattern/publish-subscribe.svg\n\n### 实际应用\n\n一个典型应用是 `Vue.js` 中的依赖收集与更新（[我的解析][vue-reactive]）。其中定义了一个 `subs` 变量维护 `主题/事件` 通道。`Watcher` 实例作为订阅者，`Dep` 实例作为发布者。\n\n另一个典型应用 `Vue.js` 中 `event bus`。\n\n```js\n// eventBus.js\nimport Vue from 'vue'\nexport default new Vue({}) // 该 Vue 实例将暴露在全局中\n\n// a.vue\nimport eventBus from '@/eventBus'\neventBus.$emit('goPublish', payload) // publish by publisher\n\n// b.vue\nimport eventBus from '@/eventBus'\nfunction handler (payload) { // callback in b.vue\n  // do something\n}\neventBus.$on('goPublish', handler) // subscribe by subscriber\neventBus.$off('goPublish', handler) // unsubscribe\n```\n\n[vue-reactive]:https://github.com/lbwa/vue-reactive\n\n### 观察者模式和发布/订阅模式的差异\n\n1. 观察者模式\n\n    1. 观察者模式要求希望接受通知的 `观察者对象` 必须订阅它所感兴趣的发起事件的 `主体对象`（`the object firing the event(the subject)`） 。\n    \n    2. 观察者必须 ***直接*** 订阅主体对象，此举导致二者形成 ***耦合***。主体对象广播时，所有观察者中回调都将被 ***同步*** 执行。\n\n2. 发布/订阅模式\n\n    1. 二者最大的差异是 `发布/订阅模式` 建立了一个 `主题/事件通道`。该通道是位于 `订阅者 subscribers`（希望接受通知的对象，`Observer`）和 `发布者 publisher`（发布通知/事件的对象，`Subject`）之间，作为二者的通信桥梁。\n    \n    2. 该事件系统（`主题/事件通道`）允许通过应用中包含自定义参数值的特殊事件来 ***区分订阅者***。这样做的目的是 ***选出*** 特定的订阅者用于单独执行回调（可形成一个消息队列），即 ***解耦*** 了订阅者和发布者之间的依赖关系（上文 1.2）。\n\n    3. 观察者是通过 `主题/事件通道` ***间接*** 订阅主体对象。\n\n与观察者模式不同的是，`发布/订阅模式` 允许任何的订阅者执行一个适当的事件处理程序用于注册和接受通过发布者广播的通知。即 `发布/订阅模式` 可单独执行某类消息下的订阅者的回调。而不是像 `观察者模式` 一样每次都执行全部类别消息下的观察者的事件回调。\n\n### 观察者模式和发布/订阅模式的优劣\n\n- 优势\n\n    1. 观察者模式和发布/订阅模式鼓励我们去思考应用中不同模块之间的关系。它们帮助我们用主体对象和观察者对象的集合来代替包含直接关系的逻辑层。最终使得我们的应用更加倾向于轻量，***松耦合***，并改善代码的潜在复用性。\n\n    2. 观察者模式使得 `主体对象` 与 `观察者对象` 形成动态联系。此举在应用中互不相关的模块之间存在强耦合时，提供了一种灵活性高的解耦解决方案。\n\n    3. 观察者模式和发布/订阅模式是设计解耦系统的最佳工具之一，推荐使用。\n\n- 劣势\n\n    1. 在发布/订阅模式中，解耦了发布者和订阅者，那么它们二者之间是没有直接关系的。那么发布者发起事件，通过 `主题/事件通道` 传递给订阅者，在订阅者接受事件之后，触发订阅者回调时，发布者此时是没有方法知道订阅者的回调是否执行成功的。\n\n    2. 发布者与订阅者二者之间的动态关系（动态体现在并不一一对应，可能触发一个或多个订阅者）也导致了 ***难以追踪*** 其中的执行过程。\n\n## 建造者模式\n\n关键词：抽象复杂 `DOM` 对象的构建、解耦复杂对象的表象与构建。\n\n即 `Builder Pattern`。\n\n该模式专注于将复杂对象的构建与表象分离。\n\n当我们使用 `DOM` 时，我们经常需要动态地创建新的元素对象。这个过程应用复杂度会随着我们所添加标签特性，元素对象属性，和元素标签多寡而增加。\n\n当我们既希望能够灵活地使用字面量来定义元素的最终标记（`markup`），又可以调用一个可读的面向对象的路由（`route`）来实现构建复杂对象时，建立一个独立于复杂 `DOM` 元素对象本身的机制即是最佳的解决方案。这也正是 `Builder Pattern` 为我们所提供的内容，`Builder` 将负载对象的构建与表象 ***解耦***，二者将通过 `builder` 维系。\n\n`Builder` 允许我们只通过指定元素的对象类型和对象内容即可创建复杂的对象，并且屏蔽了我们显式地创建或表示对象的过程。一切复杂对象的创建和表示工作都由 `builder` 来完成，我们只需要提供创建对象所需的对象类型和对象属性即可。\n\n在 `jQuery` 中，`$()` 方法即是 `builder` 对复杂的 `jQuery` 对象创建的封装，我们在使用该方法时，只需要提供特定的参数即可完成复杂的 `jQuery` 对象的创建。\n\n```js\n// 传入特定字符串完成 jQuery 对象的创建\n$('<div class=\"app\">this is a element.</div>')\n$('.app')\n```\n\n个人认为，建造者模式和外观模式较为相似。外观模式侧重复杂操作的抽象，建造者模式侧重剥离复杂对象的构建（亦可理解为对复杂的构建过程的抽象），他们都向外暴露公共接口，以将模块内部与外部调用者解耦（建造者是构建与表象解耦）。\n\n## 外观模式\n\n关键词：抽象子系统接口、暴露 `facade` 公共接口。\n\n与模块模式不同的是，模块模式侧重私有变量的保护。外观模式侧重内部系统的抽象。\n\n|结构性设计模式|描述|\n|-------------|----|\n|facade|一个隐藏了整个子系统的复杂实现的类|\n\n即 `Facade Pattern`。\n\n该模式专注于对外提供一个高级别且便捷的接口，以用于隐藏内部的复杂实现。该模式所暴露的接口是对内部实现的抽象概括。\n\n`Facade Pattern` 模式常见于 JS 库中，尽管该模式实现了具有广泛性为的方法，但是只有这些内部方法的 `facade`（可理解为内部方法的有限抽象）被提供给外部使用。\n\n这允许我们直接与 `facade` 交互，而不是内部的子系统。每当我们调用 `jQuery` 的 `$(el).css()` 之类的方法时，我们实际调用的是 `facade`（它是避免为了实现某一行为而直接使用 `jQuery` 内部核心的多个方法的公共接口）。这也直接避免了我们与 `DOM` 的 `API` 直接交互，也不用维护因直接交互而产生的状态变量。\n\n### 实现\n\n```js\nconst addListener = function (el, evt, callback) {\n  if (el.addEventListener) {\n    el.addEventListener(evt, callback, false)\n  } else if (el.attachEvent) {\n    el.attachEvent(`on${evt}`, callback)\n  } else {\n    el[`on${el}`] = callback\n  }\n}\n```\n\n示例代码中，`addListener` 的参数即是对外暴露的给元素添加事件处理程序的接口。我们只需要传入三个参数就可以给对应的标签对象 `el` 添加监听 `evt` 事件的 `callback` 事件监听器。整个过程都被整体简化，同时也避免我们直接接触内部实现代码。\n\n常见地，`Facade Pattern` 模式可与其他设计模式整合，比如 `module pattern`。\n\n### 适用场景\n\n- 在应用设计初期，应有意识地将不同层分离，比如将数据层与表现层分离，在二者之间通过加入 `facade` 层来解耦。\n\n- 在开发阶段，当子系统越来越复杂时，可加入一个 `facade` 层来提供简化后的接口，并解耦复杂的子系统与其他模块的耦合。\n\n- 在维护阶段，当存在一个难以维护的系统时，加入一个 `facade` 层以简化抽象该系统的接口，让其他模块与该系统交互时，转而与 `facade` 交互。这样接口即清晰也便于系统功能拓展。\n\n### 外观模式利弊\n\n- 优势\n\n    1. 该模式既简化了某个目标类的内部接口，也将该类与调用它的模块解耦，中间由  `facede` 这一抽象接口维系。\n\n    2. 避免我们直接与 `Facade Pattern` 所形成的子系统（模块内部）直接交互。间接交互也降低了与子系统交互时意外引入 `bug` 的风险。\n\n    3. `Facade Pattern` 模式更为显著的特点是易用性高，且通常实现该模式的代码量体积小。\n\n- 弊端\n\n    1. 性能问题。在 `Facade Pattern` 模块被确定时，即其内部实现已确定，那么不论我们传入何种参数，其内部总会实现其所有判断逻辑（如有）。那么这就可能带来一些隐性的性能消耗。\n    \n        - 比如使用了 `Facade Pattern` 的公共接口 `$(el)`（其内部通过 `document.querySelector` 实现查找元素）对比 `document.getElementById` 将有更高的性能损耗。因为 `document.getElementById` 只专注于元素 id 查找，而 `document.querySelector` 接受任何元素选择器，那么这其中执行判断逻辑（判断以何种方式查找元素）就会带来性能损耗。\n"},{"to":"180608-http-request","data":"\n`HTTP` 请求首部 ***不具有强约束***。它将与 `server` 端进行内容协商（[source][content-negotiation]），`server` 端将依托与请求首部对应的响应首部返回对应的内容协商结果。即可能不执行请求首部的请求值，而在对应的响应头中返回其他值。\n\n[content-negotiation]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\n\n## Cookie\n\n- 通过 `server` 端响应首部 `Set-Cookie` 设置本地 `HTTP Cookie`。在每次请求时，会通过 `Cookie` 请求首部携带 `HTTP Cookie`（[extension][extension-cookie]）传输至 `server` 端验证，用于确认当前用户等同源信息。\n\n在 `client` 发起一个 `HTTP` 请求时，最多只能有一个 `Cookie` 头部被建立，但 `HTTP Cookie` 不具有唯一性，可以有多个。当 `client` 设置禁用 `Cookie` 后，请求时将完全忽略 `Cookie` 首部的建立。\n\n（拓展阅读: `HTTP 响应首部` - [Set-Cookie][set-cookie]）\n\n[set-cookie]:https://lbwa.github.io/blog/writings/180607-http-response/#set-cookie\n\n## Connection/长连接\n\n- 值为 `keep-alive` 或 `close`。\n\n- 用于构建 `HTTP` 长连接，复用同一客户端下的 `TCP` 通道。即用于告知 `server` 端在此次请求完成后，是否应该保持 `TCP` 通道开启，以用于该 `client` 下次请求可跳过 `三次握手` 直接进行 `TCP` 传输。\n\n    - 注：此举不具有强约束，那么 `server` 端 ***可能*** 有自己的实现并返回不同值的 `Connection` 响应头，而不遵循 `Connection` 请求头的值。\n\n    - 在建立 `HTTP` 长连接后，若没有新的请求，在有效期后 `server` 将会关闭当前 `TCP` 连接通道。\n\n### 资源请求与加载\n\n（拓展阅读: [浏览器工作原理][how-browsers-work]）\n\n以 `Chrome ` 为示例，在控制台 `Network` 选项卡的 `Connection ID` （原理介绍[source][chrome-connection-id]）条目中，相同 ID 的连接即是使用的同一 `TCP` 通道。\n\n（更多的 `Chrome` 的 1. `waterfall` 文档：[source][chrome-water-fall]。2. 控制台官方文档（[source][chrome-console-drawer]））\n\n  1. 在 `HTTP 1.1` 中 `TCP` 通道本身是串行请求的，即一个 `TCP` 通道内每次只执行一次请求，但该 `TCP` 连接通道是可以被同一 `client` 的不同请求复用的（此处应与浏览器允许多个 `TCP` 并发进行区分）。\n\n      - 在 `HTTP 2` 中可进行并发请求。即在请求时，所有请求可并发复用同一个 `TCP` 通道。\n\n  2. `client` 在请求 ***同域*** 的情况下会尽量复用同一 `TCP` 通道。超出限定时间后未有新的请求时，`server` 会关闭当前 `TCP` 连接通道。\n\n  3. `Chrome` 现阶段最大并发数为 6，那么即最多有 6 个 `TCP` 请求（通道开启）同时进行，超出的请求将在队列中等待（[source][chrome-water-fall]）。\n\n[how-browsers-work]:https://www.html5rocks.com/en/tutorials/internals/howbrowserswork/\n\n[chrome-connection-id]:https://stackoverflow.com/questions/34184994/chrome-developer-tools-connection-id\n\n[chrome-water-fall]:https://developers.google.com/web/tools/chrome-devtools/network-performance/understanding-resource-timing\n\n[chrome-console-drawer]:https://developers.google.com/web/tools/chrome-devtools/\n\n整体加载时，`waterfall` 图例：\n\n（注：以下浏览器默认添加 `Connection: keep-alive` 请求头。）\n\n![waterfall1][waterfall1]\n\n上图中，首先加载 `HTML` 文件，在 DOM 树构建完成后，加载外部资源，那么表现为前六个外部资源 `TCP` 请求是并发的，所以他们之间的 `Connection ID` 是不同的。\n\n当其中某一外部资源加载完成，那么请求队列中的请求开始复用之前的 `TCP` 通道，这点可从后续请求的 `Connection ID` 可以看到。\n\n![waterfall2][waterfall2]\n\n单个外部资源 `waterfall` 详细对比：\n\n![initial][initial]\n\n上图中经历过 `HTTP` 三次握手的初始化请求的 `waterfall` 中都有一栏桔黄色条目 `Initial connection`，表示 `三次握手` 所经历的时间。而经过复用 `TCP` 通道的请求时没有这一栏的，即不会经过 `三次握手`。\n\n[waterfall1]:https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/waterfall-integrity1.png\n\n[waterfall2]:https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/waterfall-integrity2.png\n\n[initial]:https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/waterfall-initial.png\n\n## Accept/内容协商\n\n与 `Content-Type` 响应首部对应。\n\n表示 `client` 可处理的内容类型（`MIME`类型）。与 `Content-Type` 响应头对应。\n\n`MIME` 类型对应的文件拓展名：[source][mime-reference]\n\n[mime-reference]:http://tool.oschina.net/commons\n\n## Content-Type/客户端数据传输\n\n与响应首部中的 `Content-Type`（[source][response-content-type]）进行区分。请求首部的 `Content-Type` 表示传输给 `server` 端的数据内容的 `MIME` 类型，该请求首部可用于提交 `Form` 表单的 `POST` 请求中。\n\n[response-content-type]:https://lbwa.github.io/blog/writings/180607-http-response/#content-type-内容协商\n\n### 通过标签的默认行为提交\n\n```html\n<!-- enctype 默认只有三种类型，其他 MIME 类型可另使用 ajax 定义 -->\n<!-- 必须指定 method 否则浏览器默认执行 GET 方法，则数据会以查询参数传递，而不是数据内容 -->\n<form action=\"/target-url\" method=\"POST\" enctype=\"application/x-www-form-urlencoded\">\n  <input type=\"text\" name=\"username\">\n  <input type=\"password\" name=\"password\">\n  <input type=\"submit\">\n</form>\n```\n\n`enctype` 的值选项：\n\n  - `application/x-www-form-urlencoded`: 如果属性未指定时的默认值。\n\n  - `multipart/form-data`: 该值针对 `<input type=file\"\">` 元素。表现为拆分上传内容，上传内容（包含输入文本）将以 ***二进制***（主要是因为上传文件必须以二进制传输） 传输至 `server` 端，而不是以字符串传输。\n\n  - `text/plain` (HTML5)\n\n注：在 `Chrome` 中，使用 `multipart/form-data` 时，不会在控制台 `network` 显示 `Request Payload`，除非使用 `Ajax` 提交表单。\n\n### 通过 Ajax 提交\n\n```html\n<form action=\"/target-url\" id=\"form\" method=\"POST\" enctype=\"multipart/form-data\">\n  <input type=\"text\" name=\"username\">\n  <input type=\"password\" name=\"password\">\n  <input type=\"file\" name=\"file\" id=\"file-functions\">\n  <input type=\"submit\">\n</form>\n\n<script>\n  const form = document.getElementById('form')\n  form.addEventListener('submit', evt => {\n    // 阻止标签的默认提交，即标签中的 method 提交\n    evt.preventDefault()\n    const formData = new FormData(form)\n\n    // fetch API 可根据 form 信息自动添加 Content-Type 请求头，不用主动声明\n    fetch('/target-url', {\n      method: 'POST',\n      body: formData\n    })\n  })\n</script>\n```\n\n## Accept-Encoding\n\n与 `Content-Encoding` 响应首部对应。\n\n表示 `Client` 可接受的编码类型（通常是以某种压缩算法实现）。`client` 通过与 `server` 进行内容协商后，`server` 会通过 `Content-Encoding` 响应头的方式告知 `client` 端 `server` 端最终所选择的编码方式。\n\n### 值\n\n`gzip` 表示采用 `Lempel-Ziv coding (LZ77)` 压缩算法，以及32位CRC校验的编码方式。\n\n`compress` 采用 `Lempel-Ziv-Welch (LZW)` 压缩算法，已被大部分浏览器弃用。\n\n`deflate` 采用 `zlib` 结构和 `deflate` 压缩算法。\n\n`br` 表示采用 `Brotli` 算法的编码方式。\n\n`identity` 用于指代自身，如未经过压缩或修改。\n\n`*` 匹配任意未在请求首部中列出的编码方式。\n\n`;q=` 表示 ***权重***，即编码方式的优先顺序。\n\n## Accept-Language\n\n与 `Content-Language` 响应首部对应。\n\n表示 `client` 端所能理解的自然语言，如中文、en。\n\n## User-Agent\n\n表示当前 `client` 端的信息。即 `navigator.userAgent` 的值。\n"},{"to":"180607-http-response","data":"\n`HTTP` 响应首部即 `Response Headers`。它将与 `HTTP` 请求首部内容协商（[source][content-negotiation]），再根据 `server` 端的内部实现并依托 `HTTP` 响应首部来返回实际的协商结果。故返回的值可能不匹配 `HTTP` 请求头的值。\n\n[content-negotiation]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\n\n## Access-Control-Allow-Origin\n\n- 常用于 HTTP 请求跨域解决方案之一 —— `CORS` 。表示指定了该响应资源只允许被给定的 `Origin` 共享。该值设置为 `*` 时，表示允许所有源都具有访问该资源的权限（[source][access-control-allow-origin]）。\n\n- 该属性只能指定一个 ***唯一值***，不接受多个值。\n\n    - 若有多个源需要通过 CORS 跨域，那么可配置一个模块。该模块在 `server` 端设置该头部前配置筛选出 URL 是否为白名单内源，若是白名单内源，那么就配置头部 `Access-Control-Allow-Origin`，否则不配置该头部。\n\n详见我的另一篇博文👉[客户端跨域解决方案][客户端跨域解决方案]\n\n[access-control-allow-origin]:https://fetch.spec.whatwg.org/#http-access-control-allow-origin\n\n[客户端跨域解决方案]:http://lbwa.github.io/blog/writings/180419-cross-domain-solution/\n\n## Access-Control-Allow-Headers\n\n- 常用于标记超出 `CORS` 限定配置的 `request headers` 是否合法。表示指定在 `CORS` 请求中除限定配置外额外被允许的请求头（[source][access-control-allow-headers]）。\n\n### CORS 请求限制\n\n  - 默认允许的 `CORS` 请求方法（[source][CORS-methods]）\n\n      - 只允许 `GET`、`POST`、`HEAD` 方法。使用其他请求方法都需要经过 `CORS` 预请求。\n\n  - 默认允许的 `CORS` 请求头（[source][cors-safelisted-request-header]）\n\n      - `Accept`\n      - `Accept-Language`\n      - `Content-Language`\n      - `Content-Type` 中仅包含 `text/plain`、`multipart/form-data`、`application/x-www-form-urlencoded` 三种 `MIME` 类型值。\n\n  - 其他限制\n\n      1. `XMLHttpRequestUpload` 对象均没有注册任何事件监听程序。\n\n      2. 请求中没有使用 `ReadableStream` 对象。\n\n***总结***:使用其他超出以上 `CORS` 请求所限定的配置都将需要经过 `CORS` 预请求检测 `CORS` 请求头的合法性。\n\n### CORS 预请求\n\n`CORS` 预请求的 `Request Method` 值为 `OPTIONS`。\n\n在浏览器即将发起超过 1 中限定配置的 `CORS` 请求时，将触发浏览器 `CORS` 预请求策略。该策略用于在发起正式的 `CORS` 请求之前确认 `CORS` 请求中超出限定配置的部分是否合法。仅当超出默认配置的默认配置被 `server` 端认可时，浏览器才会真正 ***解析*** CORS 正式请求返回的数据。\n\n  - 不论 `CORS` 预请求是否合法，浏览器均会发出正式的 `CORS` 请求，合法性检测的意义在于浏览器 ***是否解析*** 返回的数据（该原理类似浏览器对跨域资源的解析策略（[extension][extension-cross-domain-solution]））。\n\n  ```js\n  // server1.js\n  const http = require('http')\n  const fs = require('fs')\n\n  http.createServer(function (request, response) {\n    console.log('request.url :', request.url)\n\n    const html = fs.readFileSync('cross-domain-solution.html', 'utf8')\n    response.writeHead(200, {\n      'Content-type': 'text/html',\n    })\n    response.end(html)\n  }).listen(8888)\n\n  console.info('server listening at port 8888')\n  ```\n  ```js\n  // client.html\n  // client 跨域请求 server2 数据\n  fetch('http://127.0.0.1:8800', {\n    method: 'POST',\n    headers: {\n      // 请求头类型不在 CORS 请求限定配置内，触发 CORS 预请求检测该请求头合法性\n      'X-Test-Cors': 'test custom headers in CORS preflight'\n    }\n  })\n    .then(res => {\n      target.innerText = 'check your network tag in console drawer'\n    })\n    .catch(err => console.error(err))\n  // 不论 CORS 预请求是否合法，client 均会发起 CORS 正式请求。\n  ```\n\n  当被请求的 `server2` 没有配置 `Access-Control-Allow-Headers` 或目标值不在该值中时，`client` 将在预请求响应后报错，但仍发起正式 `CORS` 请求，但拒绝解析正式 `CORS` 请求返回的数据。\n\n  ```js\n  // server2.js\n  const http = require('http')\n\n  http.createServer(function (request, response) {\n    console.log('request.url :', request.url)\n\n    response.writeHead(200, {\n      // 允许跨域请求\n      'Access-Control-Allow-Origin': '*',\n      // 允许除限定配置外额外的合法请求头的值\n      'Access-Control-Allow-Headers': 'X-Test-Cors'\n    })\n    response.end('server response')\n  }).listen(8800)\n\n  console.log('server listening at port 8800')\n  ```\n\n[CORS-methods]:https://fetch.spec.whatwg.org/#methods\n\n[cors-safelisted-request-header]:https://fetch.spec.whatwg.org/#cors-safelisted-request-header\n\n[access-control-allow-headers]:https://fetch.spec.whatwg.org/#http-access-control-allow-headers\n\n[extension-cross-domain-solution]:https://lbwa.github.io//blog/writings/180419-cross-domain-solution/#对跨域的基本理解\n\n## Access-Control-Allow-Methods\n\n该响应头的使用方法与原理于 `Access-Control-Allow-Headers` 相似。\n\n- 常用于标记超出 `CORS` 限定配置情况下的 `Request Method` 是否合法（[source][access-control-allow-methods]）。\n\n  ```js\n  response.writeHead(200, {\n    // 允许跨域请求\n    'Access-Control-Allow-Origin': '*',\n    // 允许除限定配置外额外的合法 `Request Method` 的值\n    'Access-Control-Allow-Methods': 'PUT, DELETE'\n  })\n  ```\n\n[access-control-allow-methods]:https://fetch.spec.whatwg.org/#http-access-control-allow-methods\n\n## Access-Control-Max-Age\n\n- 表示当次预请求检测 `Access-Control-Allow-Methods` 和 `Access-Control-Allow-Headers` 的缓存有效期，即在有效期内，即使有超出限定配置的 `CORS` 请求也不需要再进行 `CORS` 预请求来检测其合法性（[source][access-control-max-age]）。\n\n[access-control-max-age]:https://fetch.spec.whatwg.org/#http-access-control-max-age\n\n## Cache-Control/缓存头\n\n- 用于指定在 `request` 或 `response` 链中缓存当前请求数据，该指令是单向指令（[source][http1.1-cache-control]）。\n\n### 可缓存性\n\n  1. `public` 表示响应链中所有缓存都可存储当前响应数据，如发送客户端，中转服务器等。\n\n  2. `private` 表示当前响应数据只能单个用户缓存，即中转服务器不能缓存该响应数据。\n\n  3. `no-cache` 表示在使用本地缓存之前，必须首先请求原 `server` 端验证当前缓存的数据是否可用。\n\n  ![cache-control][img-cache-control]\n\n[img-cache-control]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/cache-control.svg\n\n### 缓存有效期\n\n  1. `max-age=<seconds>` 于 `server` 端设置响应数据在 `client` 端的缓存有效期，始于请求时间点。在有效期内，`client` 将读取缓存数据而不是请求数据。即使在 `server` 端该数据已经被更新，也不会改变 `client` 在有效期内读取缓存的策略，因为 `client` 在有效期内当前请求 URL 未改变的情况下就不会去请求该数据，所以 `client` 并不知道该数据已经在 `server` 端被更新了。\n\n      - ***拓展应用***：根据静态资源的 ***内容*** 打包生成的 `contentHash` 码来命名常缓存文件。只要 `server` 端该静态资源文件被更新，那么该资源的 `contentHash` 一定变化，即请求 URL 改变，那么 `client` 知晓当前静态资源请求 URL 改变后，即使在缓存有效期内，也会重新请求该资源。这样做的目的是最大限度使用缓存文件，且规避在有效期内即使 `server` 端数据被更新但仍使用缓存文件的问题。\n\n  ```js\n  response.writeHead(200, {\n    'Content-type': 'text/javascript',\n    'Cache-Control': 'max-age=200, public' // 以秒为单位\n  })\n  response.end('console.log(\"script loaded\")')\n  ```\n\n  2. `s-maxage=<seconds>` 覆盖 `max-age=<seconds>`，只在共享缓存中（如中转服务器）有效。\n\n  3. `max-stale[=<seconds>]` 表示即使缓存过期，仍可接受一个（在指定时间内）已过期资源，只在发起端设置才有效，在 `server` 端响应数据中设置是无效的。\n\n### 验证\n\n  1. `must-revalidate` 在使用之前的旧资源时，必须请求原 `server` 端来验证当前旧资源是否已经过期。\n\n  2. `proxy-revalidate` 与 `must-revalidate` 作用相同，但仅适用于共享缓存，如中转服务器。\n\n### 其他\n\n  1. `no-store` 表示所有的链中节点的缓存都不可存储当前响应数据。\n\n  2. `no-transform` 表示不能对当前响应数据进行转换或变化。\n\n***注***：以上所有指令都不具有强制力，仅表示一种约束期望。\n\n[http1.1-cache-control]:https://tools.ietf.org/html/rfc7234#section-5.2\n\n## Last-Modified/缓存验证\n\n- 用于 `server` 端标记响应数据上次修改的时间，据此来判断本地缓存是否需要更新。\n\n    - 一般在使用对应的数据缓存之前，`client` 首先通过配合 `If-Modified-Since` 或 `If-Unmodified-Since` ***请求头*** 来向 `server` 端传输之前的 `Last-Modified` 值。`server` 端据此可以来判断 `client` 端与 `server` 端的数据是否是同步的，即验证本地缓存是否需要更新。\n\n        - 注：在 `Cache-Control` 配置了 `no-store` 时，`client` 将不会携带 `If-Modified-Since` 或 `If-Unmodified-Since` 请求头。\n\n## Etag/缓存验证\n\n用于通过数据签名（如根据内容的 `contentHash` 计算）来 ***严格验证*** 数据是否需要更新。\n\n  - `client` 在下次使用该缓存之前，一般配合 `If-Match` 或 `If-Non-Match` ***请求头*** 来向 `server` 传输本地缓存的数据签名。`server` 端据此判断数据签名是否一致，即` server` 是应该向 `client` 返回新的数据，还是可以直接使用 `client` 端本地缓存。\n\n  ```js\n  response.writeHead(200, {\n    'Content-type': 'text/javascript',\n    'Cache-Control': 'max-age=20000000, no-cache',\n    'Last-Modified': '18/06/06 00:00:00', // 上次修改日期\n    'Etag': '777' // 指定数字签名\n  })\n\n  // 读取请求头\n  const etag = request.headers['If-None-Match']\n  if (etag && etag === '777') {\n    response.writeHead(304, {\n      'Content-type': 'text/javascript',\n      'Cache-Control': 'max-age=20000000, no-cache',\n      'Last-Modified': '18/06/06 00:00:00',\n      'Etag': '777'\n    })\n    response.end() // 即使此处返回内容，client 也会忽略该内容而使用本地缓存。\n  } else {\n    response.writeHead(200, {\n      'Content-type': 'text/javascript',\n      /**\n       * 1. 配置 no-cache 用于在每次使用本地缓存之前，强制向 server 端验证是否可使\n       * 用本地缓存\n       */\n      'Cache-Control': 'max-age=20000000, no-cache',\n      'Last-Modified': '18/06/06 00:00:00',\n      'Etag': '777'\n    })\n    response.end('console.log(\"script updated\")')\n  }\n\n  response.end('console.log(\"script loaded\")')\n  ```\n\n  - 注：在 `Cache-Control` 配置了 `no-store` 时，`client` 将不会携带 `If-Match` 或 `If-Non-Match` 请求头。\n\n## Set-Cookie\n\n用于 `server` 端通过 `Set-Cookie` 设置 `client` 端的 `HTTP Cookie`。\n\n### 特点\n\n`Set-Cookie` 响应首部不同于 `Cookie` 请求首部，它 ***不具有唯一性***。在 `Node.js` 中它通过一个数组来设置多个`Set-Cookie` 响应头。\n\n  ```js\n  response.writeHead(200, {\n    'Content-type': 'text/html',\n    'Set-Cookie': ['username=John_Wick', 'gender=male']\n  })\n  ```\n\n（以下 `Cookie` 都是指 `HTTP Cookie`，除非特别指明是 `Cookie` 请求首部（[extension][cookie-request-header]）。）\n\n  ```markup\n  # 创建 client 端 Cookie\n  Set-Cookie: <cookie-name>=<cookie-value>\n  ```\n\n`HTTP Cookie` （[extension][extension-cookie]）通常用于:\n\n  1. 会话管理，如登录状态，购物车等需要记录的信息。\n\n  2. 用户个性化设置，如用户自定义设置等。\n\n  3. 浏览器行为追踪，如跟踪分析用户行为等。\n\n注：不推荐再使用 `Cookie` 作用为本地存储介质，推荐使用 `localStorage`、`sessionStorage`、`IndexedDB` 代替。 因为每次请求时，在没有禁用 `Cookie` 的情况下都会携带 `Cookie` 请求首部传输至 `server`。如果使用了，将会带来额外的性能开销，尤其是在移动端下。\n\n[cookie-request-header]:https://lbwa.github.io/blog/writings/180608-http-request/#cookie\n\n### Cookie 属性\n\n  1. `max-age`（时长）和 `expires`（时间点）设置过期时间。\n\n      - 会话期 `Cookie`，若设置 `Cookie` 时未指定过期时间，那么它在浏览器关闭后就会被自动删除。\n\n      - 持久性 `Cookie`，在设置 `Cookie` 时指定了过期时间后，`Cookie` 将保存至特定的过期时间，除非手动删除。\n\n  ```js\n  response.writeHead(200, {\n    'Content-type': 'text/html',\n    // 使用逗号分隔不同的 Cookie 键值对，分号连接 Cookie 属性\n    'Set-Cookie': ['username=John_Wick', 'gender=male; Max-Age=5']\n  })\n  ```\n\n  2. `Secure` 只在 `HTTPS` 协议下发送。\n\n  3. 配置 `HttpOnly` 可阻止通过 `document.cookie` 访问指定 `Cookie`。\n\n  4. `domain` 属性，用于在访问一级域名设置指定 `Cookie` 时（前提），授权给所有子级域名指定 `Cookie` 使用权。\n\n  ```js\n  response.writeHead(200, {\n    'Content-type': 'text/html',\n    'Set-Cookie': ['username=John_Wick; domain=github.com', 'gender=male']\n  })\n  /**\n   * 1. domain=github.com 表示所有 github.com 的子域名都被授权访问\n   * github.com 下的 cookie\n   * 2. 必须首先访问一级域名才能设置（被共享的）Cookie\n   * 3. 只有设置了 domain 属性的 Cookie 才被共享\n   */\n  ```\n***注***：`Cookie` 属性是作用于个体，而非全体。\n\n[extension-cookie]:https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Cookies\n\n## Connection/长连接\n\n- 值为 `keep-alive` 或 `close`。\n\n- 用于构建 `HTTP` 长连接，复用同一客户端下的 `TCP` 通道。即用于告知 `client` 端在完成本次响应后，`server` 端是否会关闭当前 `TCP` 通道。即返回 `Connection` 请求头的执行结果，并设置为 `Connection` 响应头。\n\n- 在 `server` 端构建 `HTTP` 长连接之后，可设置长连接的 ***有效时间***，即在一定时间内没有新的请求时，关闭当前 `HTTP` 长连接。\n\n更多信息，查看本文 `HTTP 请求首部`[章节 - Connection][http-request-header]。\n\n[http-request-header]:https://lbwa.github.io/blog/writings/180608-http-request/#connection-长连接\n\n## Content-Type/内容协商\n\n与 `Accept` 请求首部对应。\n\n用于标注 `server` 端在与请求首部内容协商（[source][content-negotiation]）后，实际 `server` 端返回内容的 `MIME` 类型。\n\n`MIME` 类型对应的文件拓展名：[source][mime-reference]\n\n[mime-reference]:http://tool.oschina.net/commons\n\n## Content-Encoding/内容压缩\n\n与 `Accept-Encoding` 请求首部对应。\n\n用于标注 `server` 端在与请求首部内容协商后，实际 `server` 端返回内容的内容编码类型（即实际使用的压缩算法）。\n\n### 值\n\n`gzip` 表示采用 `Lempel-Ziv coding (LZ77)` 压缩算法，以及32位CRC校验的编码方式。\n\n`deflate` 采用 `zlib` 结构和 `deflate` 压缩算法。\n\n`br` 表示采用 `Brotli` 算法的编码方式。\n\n`;q=` 表示 ***权重***，即编码方式的优先顺序。\n\n`*` 匹配任意未在请求首部中列出的编码方式。\n\n以下为不常使用的编码方式：\n\n`compress` 采用 `Lempel-Ziv-Welch (LZW)` 压缩算法，已被大部分浏览器弃用。\n\n`identity` 用于指代自身，如未经过压缩或修改。\n\n```js\n// Node.js 编码数据内容的模块\nconst zlib = require('zlib')\n\n// ...\n\nresponse.writeHead(200, {\n  'Content-Type': 'text/html',\n  'Content-Encoding': 'gzip'\n})\nresponse.end(zlib.gzipSync(html))\n```\n\n![content-encoding][content-encoding]\n\n上图中，`420B` 则是表示传输的数据内容经过 `server` 的编码后，传输时的大小。它的大小与内容的实际编码方式有关，即 `Content-Encoding` 响应首部。`476B` 为数据内容在 `client` 端解压后的大小，除非内容变化，否则该值不变。\n\n[content-encoding]:https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/content-encoding.png\n\n## Content-Language\n\n与 `Accept-Language` 请求首部对应。\n\n用于标注 `server` 端在与请求首部内容协商后，实际 `server` 端返回的数据内容的自然语言类型。\n\n\n## X-Content-Type-Options\n\n标注 `client` 一定要遵循 `Content-Type` 响应头中的 `MIME` 类型，不应推测（修改）返回数据 `MIME` 类型。\n\n  - 早期 `IE` 会因错误的 `Content-Type` 或未声明该值而根据返回内容推测数据类型。此举极易导致文本代码被执行，那么 `client` 就可能被恶意注入。\n\n## Location/重定向\n\n表示请求当前 URL 时，`server` 端向 `client` 端告知之前请求的数据资源转移后的 `URL`，`client` 端应该去重定向请求（`Redi`）这个转移后的 URL。其中，重定向由 `client` 自动完成完成，不需要人工干预。\n\n- ***注***：必须向 `client` 端指定 `301` 或 `302` 重定向代码，否则浏览器不会自主进行重定向，此刻，将页面空白。\n\n```js\n// server.js\nconst data = fs.readFileSync('data.html')\n\nif (request.url === '/') {\n  // 必须设置为 302（推荐）或 301 代码，否则客户端无法正常跳转\n  response.writeHead(302, {\n    'Location': '/new-url'\n  })\n\n  response.end(html)\n}\n\nif (request.url === '/new-url') {\n  response.writeHead(200, {\n    'Content-Type': 'text/html'\n  })\n\n  response.end(data)\n}\n```\n\n`301` 与 `302` 的区别：\n\n  - `301` 表示永久重定向。例如，在请求 `url-0` 并完成当次重定向 `url-1` 后，缓存当前 `url-1`。之后发起的所有 `url-0` 请求直接在 `client` ***本地读取缓存*** 读取重定向地址 `url-1` ，此时并不会先向 `server` 请求重定向的目标地址。\n\n      1. 该存储的 `url-1` 会在缓存中尽可能长的存储。除非清除了 `client` 缓存。\n\n      2. 因为是从本地缓存读取重定向 URL，故应谨慎使用 `301` 代码。因为若在 `server` 端进行 URL 更新后，本地是无法感知更新的，本地仍将重定向至之前的 URL。\n\n  - `302` 表示临时重定向。即每次请求都会请求 `server` 来得到重定向的目标地址。只有指定了 `Cache-Control` 或 `Expires` 时，该重定向地址才是缓存的。\n\n## Content-Security-Policy/内容安全策略\n\n用于限制资源获取，报告（`report-uri` 指令）资源获取越权（[source][csr-intro]）。如，限制 HTML 中外部资源的加载（执行）。\n\nAPI:[source][csr-api]\n\n注：`connect-src`（[source][connect-src]）指令可以限制当前站的 `Ajax` 请求。\n\n实现方法一（推荐）：\n\n```js\n// server.js\nresponse.writeHead(200, {\n  'Content-Type': 'text/html;'\n\n  /**\n   * 1. default-src 指定了所有资源的备用策略，即在形如 img-src 等策略未指定的时候被应用。\n   * 2. 以下限制了只能通过 http 或 https 的方式来加载所有资源，那么嵌入式 JS 代码将被\n   * 忽视执行。\n   * 3. 值为 'default-src \\'self\\'' 时，将只限 `同域的资源（即本站）` 加载执行，那么\n   * 所有非同域外部资源将被 `block`\n   * 4. form 表单不受 'default-src \\'self\\'' 的限制。必须设置为\n   * 'form-action: \\'self\\''\n   */\n  'Content-Security-Policy': 'default-src http: https:'\n})\n```\n\n实现方法二：\n\n```html\n<meta http-equiv=\"Content-Security-Policy\" content=\"default-src 'self'\">\n```\n\n结果：\n\n```html\n<body>\n  <!-- 以下外部 JS 脚本将被执行 -->\n  <script src=\"https://example.com/data.js\"></script>\n  <!-- 以下嵌入式代码将被忽略 -->\n  <script>\n    console.log('Hello World !')\n  </script>\n</body>\n```\n\n[csr-intro]:https://developer.mozilla.org/zh-CN/docs/Web/HTTP/CSP\n\n[csr-api]:https://developer.mozilla.org/zh-CN/docs/Web/HTTP/Headers/Content-Security-Policy__by_cnvoid\n\n[connect-src]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Content-Security-Policy/connect-src\n"},{"to":"180606-http-protocol","data":"\n## HTTP 三次握手\n\n`HTTP` 自身没有和 `server` 端通信传输的功能，`HTTP` 本身只能发起和响应请求，并不传输请求。他是通过创建的 `TCP connection`（作为传输请求的通道）来实现数据传递功能。所有的 `HTTP` 请求创建时，都会创建一个 `TCP` 通道用于数据传输。\n\n  ![http-tcp][http-tcp]\n\n[http-tcp]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/http-tcp.svg\n\n- `HTTP 1.0` 时，在 `HTTP` 请求创建时，同样会创建一个 `TCP` 通道用于传输数据。在服务端响应请求后，`TCP` 通道就会关闭（非常驻）。\n\n- `HTTP 1.1` 时，可 ***额外声明*** 让服务端响应请求后，`TCP` 仍保持通道开启（常驻状态）。此举用于避免多次请求时，不必要的 `三次握手` 性能开销。\n\n    - 现阶段使用最为广泛的 `HTTP` 协议版本。\n\n- `HTTP 2` 可并发请求，那么在保持 `TCP` 通道开启时，相同用户多次对同一服务器的并发请求可共用一个 `TCP` 通道。\n\n    - `HTTP 2` 正在逐步推广中。 \n\n### 三次握手\n\n在 `HTTP` 通过 `TCP` 执行正式的请求之前，有 3 次预先请求发生在 `client` 和 `server` 端之间。\n\n1. `client` 创建一个预请求以告知 `server`：`client` 即将发起一个正式 `TCP` 连接。此次请求包含标志位（`SYN=1,Seq=X`）。\n\n2. `server` 响应 1 中的预请求，开启相应 `TCP` 端口，并返回一个响应数据包（`SYN=1, ACK=X+1, Seq=Y`）给 `client`。\n\n    - 此次 `server` 返回数据表示 `server` 不仅能够正常接受 `client` 的请求，而且已开启相应端口准备接收即将到来的正式 `TCP` 连接。\n\n    - 此时 `server` 端的 `TCP` 端口将保持开启至响应 `client` 请求（`client` 已正常接收的请求或关闭当前 `TCP` 连接的请求）。\n\n3. `client` 在收到 `server` 端返回的允许创建 `TCP` 连接的请求之后，向 `server` 发送已正常接收到 2 中的响应数据的请求（`ACK=Y+1, Seq=Z`）。\n\n    - 此次请求表示 `client` 能够正常接受 `server` 的响应数据。\n\n此时，完成 `三次握手` 预请求，创建正式的 `TCP` 请求。\n\n### 三次握手的意义\n\n1. 若没有三次握手，直接请求，那么在 `server` 返回数据时，`server` 并不知道 `client` 是否能够正确的接受到请求，是否过程中有数据丢失，那么 `server` 就可能在错误的时机仍然保持 `TCP` 连接端口来等待 `client` 确认数据已接受的请求或关闭当前 `TCP` 连接的请求，这样将带来一系列不必要的 `server` 性能开销。在 `client` 等待时间内没有正确接收请求时，`client` 就会关闭 `TCP` 连接。那么此时 `server` 也就没有必要为为无用的数据连接继续保持开启相应 `TCP` 连接端口。\n\n2. 在有了三次握手的策略后，在正式请求之前，就可以确保当前 `TCP` 通道是可用的，及时发现当前 `TCP` 的网络问题。避免因网络问题导致的无用的数据传输带来的 `server` 端口常驻的性能开销。\n\n## URI/URL/URN\n\n`URI`: Uniform Resource Identifier 统一资源标志符\n\n  - 用于唯一标识互联网中的信息资源\n\n  - 包含 `URL` 和 `URN`\n\n`URL`: Uniform Resource Locator 统一资源定位器\n\n  - 格式如下：\n\n      `protocol://user:pass@host.com:80/path?query=string#hash`\n\n      - `protocol` 协议。如 `https`、`http`、`ftp` 等。\n\n      - `user:pass` 用户验证。因暴露用户账号密码不安全，故不推荐使用。\n\n      - `host` 主机名。\n\n      - `80` 主机端口，默认为 `80`。每个物理主机端口都存放着不同的 web 服务。\n\n      - `path` 路由。\n      \n          1. `/` 表示当前 `web` 服务的根目录，而不是主机的根目录。\n          \n          2. `path` 路径默认情况下为 `web` 服务器下数据存放的路径。当数据库独立时，那么 `path` 仅表示数据的 ***存放地址***，并不能表示该数据在服务器磁盘上的路径。\n\n          3. 故推荐在程序内部鉴别数据，而不是通过 URL 鉴别数据。\n\n      - `query=string` 查询参数。常用于向 `server` 端传参。\n\n      - `hash` 哈希值。定位某个资源的某一片段。如文章的锚点。\n\n`URN`: Uniform Resource Name （永久）统一资源定位符\n\n  - 用于永久性在网络中标识出资源，因限制过多，已逐渐被 `URI` 取代。（[extension][urn]）\n\n[urn]:https://en.wikipedia.org/wiki/Uniform_Resource_Name\n\n## HTTP 报文\n\n`HTTP` 报文没有强约束，可自定义报文内容。\n\n![http-bw][http-bw]\n\n[http-bw]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/http-bw.svg\n\n## HTTP 方法\n\n- 用来定义对于资源的操作\n\n    - 常用方法有 `GET`、`POST`、`PUT`、`DELETE`。另外还有 `HEAD`、`OPTIONS`、`PATCH` 方法。\n\n    - 应该从开发人员的使用方式来定义各自方法的语义。\n\n## HTTP code\n\n- 定义服务器对请求的处理结果。\n\n    - 2XX - Success - 表示成功处理请求。如 200。\n\n    - 3XX - Redirection - 需要重定向，浏览器直接跳转。\n\n    - 4XX - Client Error - 客户端请求错误。\n\n    - 5XX - Server Error - 服务端响应错误。\n\n- 推荐 `server` 端正确配置 HTTP code，使得 HTTP code 语义化。好的 `HTTP` 服务应该可以通过 HTTP code 来判断请求结果。而不是只有 `200` 或 `500`。\n\n拓展：[code 码参考][code-reference]\n\n[code-reference]:http://tool.oschina.net/commons?type=5\n\n## HTTP 客户端\n\n能够发起 HTTP 请求，并能够接收返回数据的客户端都可称为 HTTP 客户端。如 `curl`、`XMLHttpRequest`、浏览器等。\n\n除了在浏览器中可以观察 HTTP 请求的细节外，亦可使用 `curl` 命令行工具来观察。 \n\n```powershell\n# -v 表示显示报文信息\ncurl -v www.baidu.com\n```\n\n返回数据如下：\n\n```powershell\n* Rebuilt URL to: www.google.com/\n  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current\n                                 Dload  Upload   Total   Spent    Left  Speed\n  0     0    0     0    0     0      0      0 --:--:-- --:--:-- --:--:--     0*\n  Trying 172.217.10.132...\n* TCP_NODELAY set\n* Connected to www.google.com (172.217.10.132) port 80 (#0)\n# 请求报文\n  # 起始行\n> GET / HTTP/1.1\n  # 首部\n> Host: www.google.com\n> User-Agent: curl/7.57.0\n> Accept: */*\n> # 此处有一空行\n# 响应报文\n  # 起始行\n< HTTP/1.1 200 OK\n  # 首部\n< Date: Thu, 07 Jun 2018 14:28:45 GMT\n< Expires: -1\n< Cache-Control: private, max-age=0\n< Content-Type: text/html; charset=ISO-8859-1\n# 省略一些信息\n# ...\n< Transfer-Encoding: chunked\n<\n{ [759 bytes data]\n100  3555    0  3555    0     0   3555      0 --:--:--  0:00:01 --:--:--  1834\n# 以下是响应报文的主体内容区域\n# ...\n<!doctype html><html\n```\n\n## HTTP 首部\n\n在实现 `HTTP` 协议过程中，一系列功能都是通过配置相应的 `HTTP` 首部来实现的。\n\n👉[HTTP 响应首部][http-response]\n\n👉[HTTP 请求首部][http-request]\n\n[http-response]:https://lbwa.github.io/blog/writings/180607-http-response/\n\n[http-request]:https://lbwa.github.io/blog/writings/180608-http-request/\n\n## 实战\n\n（以 `Nginx` 为例）\n\n`Nginx`（[官网][nginx-official-site]）纯粹地实现 `HTTP` 协议，其中并不包含业务逻辑，正因如此它的 ***可拓展性强***。\n\n[nginx-official-site]:https://nginx.org/en/\n\n### API\n\n- `Nginx` API\n\nAPI 文档：[API Docs][Nginx-api]\n\n命令行参数：[Command-line parameters][nginx-clp]\n\n```powershell\n# -c file 使用一个指定的配置文件代替默认配置文件，默认值为 nginx/nginx.conf\n\n# 启动服务\nstart nginx [-c confFile] # 推荐，但配置文件出错时，无提示信息\n# 或者\n./nginx [-c confFile] # 会占用当前窗口，但配置文件从出错时，有提示信息\n\n# -s signal 发送一个 signal 到 nginx 主进程\n# signal 值为 stop, quit, reload, reopen 之一\n\n# 重启服务\n./nginx -s reload\n\n# 退出服务\n./nginx -s stop # 立即停止服务，可能不会保存相关信息\n./nginx -s quit # 有序地停止服务，并保存相关信息\n\n# -g directives 发送一个全局配置指令\n# HUP 指令，使用新的配置文件启动进程，之后平缓停止原有进程，即平滑重启\n\n# 平滑重启\n./nginx -g HUP [-c newConfFile]\n\n# -t 检测配置文件。使用场景：用于上线前检测，避免上线错误\n./nginx -t -c sample.conf\n\n# 查看当前 nginx 进程号\n# logs/nginx.pid 是 nginx.pid 的文件路径\ncat logs/nginx.pid\n```\n\n- 系统 API\n\n```powershell\n# 查看端口占用，如 8800 端口\n# -ano 是三个参数 -a -n -o 简写形式\nnetstat -ano|findstr 8800\n\ntasklist /? # 帮助文档\n\n# /fi filter 显示一系列符合筛选器指定的进程\n\n# 查看当前 nginx 进程\n# 其中运算符 eq 表示 等于\ntasklist /fi \"imagename eq nginx.exe\" # cmd and powershell\ntasklist //fi \"imagename eq nginx.exe\" # git bash for win\n\n# 结束所有 nginx 进程\n\ntskill nginx # 推荐\n\n# /f 强行终止\ntaskkill /fi \"imagename eq nginx.exe\" /f # cmd and powershell\ntaskkill //fi \"imagename eq nginx.exe\" //f # git bash for win\n\n# 与 pid 配合使用\ncat logs/nginx.pid # 得到 Nginx 主进程 PID 值 pidNumber\ntaskkill //pid pidNumber //f\n```\n\n注：`tasklist` 和 `taskkill` 命令在 `git bash for win` 中必须以双斜杠传参（[source][tasklist-in-git-bash]）。\n\n[Nginx-api]:http://nginx.org/en/docs/windows.html\n\n[nginx-clp]:http://nginx.org/en/docs/switches.html\n\n[tasklist-in-git-bash]:https://stackoverflow.com/questions/34981745/taskkill-pid-not-working-in-gitbash\n\n### 代理基础配置\n\n1. 在 `host` 文件中映射原始请求地址。示例：\n\n```powershell\n# 用于将 example.com 解析为 127.0.0.1，原理是 PC 首先在本地 host 文件中解析 URL\n127.0.0.1 example.com\n```\n\n2. 单独配置 `servers/example.conf`，以模块化 `Nginx` 代理配置。\n\n拓展：`http` 是明文传输，故可在代理层修改原始请求的请求首部和内容。\n\n```nginx\n# 每个代理服务都在一个 server 中定义\nserver {\n  # 监听的端口\n  listen      80;\n  # 监听的 URL，即用户输入的 URL\n  server_name test.com;\n  \n  # 转发的目标地址\n  location / {\n    # 1. 代理层接受到原始请求后，将发起一个新的请求至代理路径。依据 HTTP 原则，该新的请\n    # 求的 host 默认为 proxy_pass。\n    # 注：可于终端 server 打印并查看新请求的 host 请求首部。\n    proxy_pass http://127.0.0.1:8800;\n    # 2. 恢复原始请求的 host 请求首部。变量 $host 即原始请求的 host 请求首部。\n    # 注：经浏览器控制台 network tag 可查看原始请求的 host 请求首部\n    proxy_set_header Host $host;\n  }\n}\n```\n\n以上配置将实现 `example.com ==转发至==> http://127.0.0.1:8800`。\n\n***注***，代理服务器根据原始请求的 `host` 请求首部来 ***选择*** 代理的目标路径。即可以实现一个端口监听，多个路径代理。\n\n### 缓存功能\n\n```nginx\n# proxy_cache_path 配置缓存存放路径\n# levels 配置生成多级文件夹，使得多个代理分离为自己独立的文件夹\n# keys_zone 配置在内存中分配给匹配的缓存（因为匹配的缓存将暂存在内存中）的区域名称和大小\nproxy_cache_path cache levels=1:2 keys_zone=my_cache:10m; # 2 级目录，内存 10m\n\nserver {\n  listen      80;\n  server_name test.com;\n  \n  location / {\n    proxy_cache my_cache; # 根据名字 my_caches 配置缓存存储的区域\n    proxy_pass http://127.0.0.1:8800;\n    proxy_set_header Host $host;\n  }\n}\n```\n\n代理缓存的应用场景：只要一次代理缓存，那么后续在缓存有效期内所有请求到代理服务器的请求都可使用该缓存，那么可大大节约向真正资源服务器请求的数量与时间。\n\n与代理缓存相关的响应首部（对于 `client` 来说）\n\n1. `Cache-Control`\n\n    - `s-maxage`: 功能与 `max-age` 相同，且 `s-maxage` 覆盖 `max-age`。二者区别在于 `s-maxage` 适用对象仅限共享缓存的对象，如中转代理服务器。\n\n    - `private`：标注只允许 `client` 缓存数据，中转代理服务器不能缓存该数据。\n\n    ```js\n    // 资源服务器\n    response.writeHead(200, {\n      // private 将导致 max-age 和 s-maxage 失效\n      'Cache-Control': 'max-age=2, s-maxage=20, private'\n    })\n    ```\n\n    - `no-store`：路径中所有节点（包含 `client`）都不能缓存该响应数据。\n\n    ```js\n    // 资源服务器\n    response.writeHead(200, {\n      // no-store 将导致 max-age 和 s-maxage 失效\n      'Cache-Control': 'max-age=2, s-maxage=20, no-store'\n    })\n    ```\n\n2. `Vary`: `Vary` 指定某一 `client` 端请求头，只有当该请求首部的值与上次请求首部的值相等时，才缓存响应数据。\n\n    ```js\n    // client\n    const index = 0\n\n    fetch('/data', {\n      headers: {\n        // 只有当此次 `x-test-Cache` 的值与上次请求相同时，才缓存此次响应数据\n        'X-test-Cache': index++\n      }\n    })\n    ```\n\n    ```js\n    // 资源服务器\n    response.writeHead(200, {\n      'Cache-Control': 's-maxage=200',\n      // 只有当 `Vary` 所标注的请求首部当次值与上次请求时的值相同时，才缓存当前响应数据\n      'Vary': 'X-test-Cache'\n    })\n    ```\n\n适用场景：在同一 URL 情况下，根据不同的 `userAgent` 来缓存不同的响应数据。比如根据移动端与 PC 端返回不同的数据。\n\n## HTTPS\n\n`HTTP` 是明文传输，为了密文传输，诞生了 `HTTPS`。\n\n### 加密与解密\n\n公钥（即服务端证书）用于加密被传输的数据。私钥用于解密被传输的数据。\n\n在握手阶段，进行公钥与私钥匹配。`client` 将在最初阶段传输加密套件，用于与 `server` 端内容协商（[source][content-negotiation]）选择最终使用的加密方式。私钥始终保持在 `server` 端，用于解密，那么据此保证了传输的安全性。\n\n![https-principle][https-principle]\n\n[content-negotiation]:https://developer.mozilla.org/en-US/docs/Web/HTTP/Content_negotiation\n\n[https-principle]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/http-protocol/https-principle.svg\n\n### 部署\n\n1. 生成证书（[本地生成证书命令][generate-localhost-certificates]）\n\n[generate-localhost-certificates]:https://gist.github.com/lbwa/5607c3a66573610b5ccfd4ef4aaa780f\n\n2. 配置 `Nginx` 代理\n\n（[reference][nginx-https-server]）\n\n```nginx\nproxy_cache_path cache levels=1:2 keys_zone=my_cache:10m;\n\nserver {\n  # https 默认端口是 443\n  listen      443 ssl;\n  server_name test.com;\n\n  # ssl on; 于 1.15 版本中废弃，listen <port> ssl 代替\n  ssl_certificate_key ../certs/localhost-privkey.pem;\n  ssl_certificate ../certs/localhost-cert.pem;\n\n  location / {\n    proxy_cache my_cache;\n    proxy_pass http://127.0.0.1:8800;\n    proxy_set_header Host $host;\n  }\n}\n```\n\n[nginx-https-server]:http://nginx.org/en/docs/http/configuring_https_servers.html\n\n补充：将 `HTTP` 转发至 `HTTPS`\n\n```nginx\n# 在 部署.2 的基础上实现\n\nserver {\n  listen      80 default_server;\n  listen       [::]:80 default_server;\n  server_name test.com;\n\n  # $server_name 接受请求的服务器的名称，此处即是 test.com\n  # $request_uri 原始完整的请求 URL，包含查询参数，即访问主机上的路径，如 /api/data\n  return 302 https://$server_name$request_uri;\n}\n```\n\n## HTTP 2\n\n1. 信道复用，在单个 `TCP` 通道内可 ***并发请求***，但在 `HTTP 1.1` 中单个 `TCP` 通道内是串行请求。\n\n2. 分帧传输，每帧以包含上下文的形式传输，过程中不一定是按照顺序传输的。因为包含上下文，故在响应端，可根据上下文重组各帧还原数据。\n\n3. Server Push，`server` 端不再是只有被动接受请求才能响应，`server` 端在 `HTTP 2` 中可主动推送数据至 `client`。\n\n### 部署\n\n（[reference][nginx-http-v2]）\n\n在 `HTTP 2` 标准中，`HTTP 2` 并不强制使用 `HTTPS`。值得注意的是，目前浏览器都要在开启 `HTTPS` 的情况下才能使用 `HTTP 2`。\n\n```nginx\n# 中转服务器\nserver {\n  listen             443 ssl http2;\n  server_name        test.com;\n  # 指定主动推送\n  http2_push_preload on;\n  # ...\n}\n```\n\n[nginx-http-v2]:http://nginx.org/en/docs/http/ngx_http_v2_module.html\n\n- 查看 `server` 端主动推送的相关信息，于地址栏输入 `chrome://net-internals/#http2` 查看。\n\n- 注：浏览器只会接受安全的认证过证书的 `server` 端推送的信息，否则主动推送信息将被忽略。\n\n补充：`HTTPS` vs `HTTP 1.1` vs `HTTP 2` [demo][comparison-demo]\n\n***注***：`Nginx` 代理服务器可以为 `HTTP 2` 做兼容，他会根据 `client` 端所支持的协议返回响应数据，而不需要开发人员来做协议兼容。\n\n[comparison-demo]:https://http2.akamai.com/demo/http2-lab.html\n"},{"to":"180507-execution-context","data":"\n本文主要讲述在事件循环中，每一个宏任务或每一个微任务是如何被具体执行的。即被推入执行上下文栈（`execution context stack`，亦称调用栈 `call stack`）的代码是如何被具体执行的。\n\n## 执行上下文定义\n\n执行上下文（`execution context`（[ECMAScript][ECMAScript-execution-context]））用于**追踪代码的执行**。在任何时候在一个客户端中**最多**只存在一个当前**正在执行**代码的执行上下文，并且被称作客户端的 **当前执行上下文**（`running execution context`）。\n\n## 执行上下文栈（亦称调用栈）定义\n\n执行上下文栈（`execution context stack`，亦称调用栈 `call stack`）用于追踪执行上下文。当前执行上下文总是执行上下文栈中最上层的那一个执行上下文。\n\n注：\n  - 执行上下文栈即是执行上下文的**容器**。\n\n      ![execution-context][execution-context]\n\n[execution-context]:https://rawgit.com/lbwa/lbwa.github.io/vue/source/images/post/execution-context/execution-context.svg\n\n## Running execution context 的更替\n\n（[来源][ECMAScript-execution-context]）\n\n> A new execution context is created whenever control is transferred from the executable code associated with the currently running execution context to executable code that is not associated with that execution context.The newly created execution context is pushed onto the stack and becomes the running execution context.\n\n（[来源][suspended]）\n\n> Once the running execution context has been suspended a different execution context may become the running execution context and commence evaluating its code. At some later time a suspended execution context may again become the running execution context and continue evaluating its code at the point where it had previously been suspended.\n\n1. 从当前运行的执行上下文相关联的可执行代码转移控制权（`control`，可理解为执行权）到与该执行上下文不相关的可执行代码时，就会创建新的执行上下文。\n\n    - 可理解为在一个函数中调用另一个函数时，就会创建一个新的执行上下文。\n\n2. 新的执行上下文将会**代替**之前的执行上下文成为当前执行的执行上下文（`running execution context`）并推入执行上下文栈中（`execution context stack`）。\n\n3. 之前的执行上下文将会进入`冻结`状态（`suspended `）（[来源][suspended]），并等待新的执行上下文执行完成。待新的执行上下文执行完成将会恢复之前的执行上下文的执行。\n\n以上可以解释 `JavaScript 语言精粹` P27中，作者介绍到，在一个函数（称为 a）中调用一个函数（称为 b）时，a 会暂停执行，进入 `冻结` 状态，并将当前执行权转移给函数 b。待 b 执行完成后，执行权由 b 回到 a，这样 a 得以继续恢复执行接下来的代码。\n\n[ECMAScript-execution-context]:https://www.ecma-international.org/ecma-262/#sec-execution-contexts\n\n[suspended]:https://www.ecma-international.org/ecma-262/#table-22\n"},{"to":"180424-vue-lifecycle-and-slots","data":"\n# Vue.js 生命周期钩子\n\n在 Vue 组件的生命周期内，`mounted` 之前（包括自身）的所有钩子都只会调用**唯一的一次**。\n\n在服务端渲染 Vue.js 组件时，不会调用 `beforeMount` 和 `mounted` 的钩子的，因为没有操作 DOM 的环境。\n\n尽管在 `beforeCreate` 时期，事件与生命周期已完成初始化，但是初始化注入和交互都是在 `beforeCreate` 之后，`created`之前。那么在组件中的数据操作，如 `ajax 请求` 最早不能早于 `created` 时期。\n\n# 渲染\n\n`render` 函数不能写成 箭头函数，否则其中的 this 将指向错误的对象，而非 vue 实例。\n\n# 实例对象\n\n`$el` 只存在始于 `created` 之后，即在 `beforeMount` 才能被探测到。在 `beforeMount` 时期值为将被替换的节点，如原 DOM 中 `<div class=\"app\"></div>`；在 `mounted` 时期的值为已经替换的 DOM 节点，原节点已经被新节点替换。\n\n`$refs` 是对 DOM 的引用，那么它的存在只能在 `mounted` 才能被探测到\n\n`$options` 是当前 Vue 实例化时的选项对象，即 `new Vue()` 时的参数对象\n\n# 在 Vue.js 中监听对象属性的方法\n\n在常规情况下， Vue.js 只监听数据**对象本身**，即只监听指向某对象的**指针是否变化**。它对于该对象的内部属性变化并不能做到响应其变化。\n\n原因是，据 [官方文档][reactive] 响应式原理，Vue.js 在初始化实例时，对 data 对象中的每一项都执行 `getter/setter` 的转化过程。这里的转化过程**并没有进行深度遍历**，即 data 对象中的某项是一个对象 A，对象 A 下的属性是**不会**受到监听的，受到 Vue.js 监听的是对象 A 这个整体。\n\n示例如下：\n\n```js\nnew Vue({\n  el: '#app',\n  data: {\n    obj: {\n      a: 0\n    }\n  },\n\n  methods: {\n    inputEvt () {\n      this.obj.a += 1\n      console.log(this.obj.a)\n    }\n  },\n\n  watch: {\n    // 监听 obj 时是无法响应 obj.a 的变化的。修改为 'obj.a' 的监听即可\n    obj (newValue, oldValue) {\n      console.log('running')\n    }\n  },\n\n  render (h) {\n    return h('input', {\n      on: {\n        input: this.inputEvt\n      }\n    })\n  },\n})\n```\n\n## 解决方案\n\n```js\nwatch: {\n  // 法一\n  'obj.a': { // 对象属性的样式一定要是字符串形式\n    console.log('obj.a changed')\n  },\n\n  // 法二\n  obj () {\n    handler () { // 一般省略了 handler 写法，直接写内部代码块内容\n      console.log('obj.a changed')\n    },\n\n    immediate: true, // 该回调将会在侦听开始之后被立即调用\n    deep: true // 是否深度监听对象属性，性能开销大，慎用\n  }\n}\n```\n\n> 因 JavaScript 的限制，Vue.js 无法监听对象的属性的添加和删除。\n\n`Vue.set()` 用于建立非初始化（没有在 data 项中声明的数据对象）对象属性的响应式监听，以触发视图更新。这个方法的目的是要去**触发响应式的视图更新**，而不是数据处理，若需要对对象的变化做出对应的数据处理，请使用 `watcher`。\n\n[reactive]:https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项\n\n# 由 props 联系到子组件的通信行为\n\n前提：一般地，我们将子组件分为业务子组件和基础（展示性）子组件。其中，基础组件是（展示性组件）由父组件向其通过 props 来传递数据并展示数据内容，仅仅具有展示功能，不具有处理数据功能。我们要遵循的原则是保持父子组件间的`单向数据流`。\n\n子组件（业务和基础子组件）中不应有修改 props 的语句出现。因为 props 本身定位是**规范约束**子组件的显示行为。如果在这时在子组件中出现了修改 props 的语句。那么这破坏了传递 props 来约束子组件的原则。作为一个子组件不应该修改父组件的数据。\n\n如果要在子组件内修改 props ，那么导致该子组件的职责不清晰。即该组件的**职责定位**有问题，要么派发事件让父组件处理数据，要么本应将数据处理完毕后再传给子组件。至于父组件会不会处理以及如何处理子组件传递的载荷，这不是子组件的职责所在。\n\n至于基础子组件和业务子组件的划分，个人认为是通过组件本身内部功能实现（是否仅仅是展示数据），**组件复用性**来划分。一般地，复用性子组件我们定义为基础子组件，其中**不应有**处理数据的语句出现。因为复用性高，那么其在不同的使用环境可能对应不同的数据处理方法。所以，复用性组件应该作为基础组件的存在，其职责主要是展示数据。处理数据这一行为交由子组件的父组件处理。\n\n# 对增强组件复用性的思考\n\n1. 划分明确的组件职责\n\n2. slot 插槽\n\n3. slot 插槽 + slot-scope 插槽\n\n## slot-scope 插槽原理\n\n一般情况下，每个组件都有自己的作用域，父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。典型示例就是，子组件中的 `slot 插槽` 内容引用的是**父组件**的数据对象。即 `slot 插槽` 的内容引用的数据对象是**跟随**父组件作用域的。\n\n作用域插槽用于在子组件 `slot 插槽` 中调用自身的数据对象。父组件中的 `slot-scope 插槽` **指定**了要引用的 props 对象。这里就像是子组件的作用域插到父组件中一样。\n\n``` html\n<!-- child component -->\n<div class=\"child\">\n<!-- 在父组件没有使用 slot-scope 时，插槽内容中的 props.text 值为父组件内的 props 值 -->\n  <slot></slot>\n</div>\n\n<!-- parent component -->\n<my-awesome-list :items=\"items\">\n<!-- 此时，slot 插槽内容调用 props.text 值将优先调用子组件的 props.text -->\n  <li\n    slot-scope=\"props\"\n    class=\"my-fancy-item\">\n    {{ props.text }}\n  </li>\n</my-awesome-list>\n```\n\n在父组件中，指定了传给子组件的 slot-scope 值，那么在子组件中此时调用的 props 即为父组件的 props 值。\n\n## slot-scope 插槽实现\n\n示例如下：\n\n```js\nconst ChildComponent = {\n  data () {\n    return {\n      childText: 'child text'\n    }\n  },\n\n  // 子组件中的 text 将经过 slot-scope 传递给父组件\n  template: `\n  <div class=\"child\">\n    <slot :text=\"childText\"></slot>\n  </div>\n  `\n}\n\nnew Vue({\n  el: '#app',\n\n  components: {\n    ChildComponent\n  },\n\n  // 父组件以 props 对象的属性的形式接收子组件传递的 text 值\n  // 同时，在插槽内仍可调用父组件的 data 对象\n  template: `\n  <div class=\"app\">\n    <child-component>\n      <span slot-scope=\"props\">{{props.text}}</span>\n    </child-component>\n  </div>\n  `,\n\n  data: {\n    text: 'parent text'\n  }\n})\n```\n\n此时，渲染的 DOM 树如下：\n\n``` html\n<div class=\"app\">\n  <div class=\"child\">\n    <span>child text</span>\n  </div>\n</div>\n```\n\n由以上实例，`slot-scope 插槽` 提供了一种经过 props 对象**子组件向父组件传递数据**的**机会**。它一般配合 `slot 插槽` 一起使用，这样，可以有不同的 `slot 插槽` 内容，但是使用的是**同一数据对象**，即***子组件作为一个能传递数据的重用模板***。此时，子组件的作用域好像插在父组件一样。\n\n## slot-scope 插槽与 slot 插槽的不同\n\n`slot-scope 插槽` **侧重**指定渲染时的**数据对象**的调用，它实现了一种经过 props 对象子组件向父组件传递数据的机会。`slot 插槽` 侧重指定渲染时的**内容**，即内容分发。\n\n另外值得注意的是，`slot-scope 插槽` 定位并不是向父组件传递数据，它**仅仅**只能指定 `slot 插槽` 中内容区域的数据对象，那么 `slot-scope 插槽` 是不能与 `vm.$emit()` 来相提并论的。\n\n# 在渲染函数中使用 $slot\n\n```js\nconst ChildComponent = {\n  render (h) {\n    return h('div', {\n      class: 'child'\n    }, this.$slots.header) // 在子组件中通过 vm.$slot 来访问插槽内容\n  }\n}\n\nnew Vue({\n  el: '#app',\n\n  components: {\n    ChildComponent\n  },\n\n  render (h) {\n    return h('div', {\n      attrs: {\n        id: 'app'\n      }\n    }, [\n      h('child-component', {}, [\n        h('span', {\n          slot: 'header'\n        }, this.text)\n      ])\n    ])\n  },\n\n  data: {\n    text: 'parent text'\n  }\n})\n```\n\n在渲染函数中，使用 `vm.$slot` 在子组件中（接收方）访问插槽内容，匿名插槽为 `vm.$slot.default`，具名插槽为 `vm.$slot.name`。\n"},{"to":"180421-learning-vue-unit-test","data":"\n# 关于单元测试应该了解的知识\n\n## 测试原则\n\n首先最应该搞明白的是，我们要测什么？测试的目的是什么？\n\n单元测试，侧重点在\"单元\"。在单元测试中更应该注重**单个**单文件组件的功能实现，而不是过多纠缠于组件之间的数据传递(这是端到端测试的内容，即 e2e，测试整个应用的功能展现)和组件中的功能实现过程。\n\n我们不论是在单元测试中还是 e2e 测试的重点都应该是，测试单个组件（或由多个组件组成的整个应用）的渲染或功能的**结果**，而不是过程！！即侧重**黑盒测试**，至于是怎样实现的，并不是测试的内容。\n\n注重结果测试的好处就是，并不限制结果的实现方式，为后期的优化和拓展提供了更多的可能性。\n\n比如，测试一个函数的功能，就看这个函数需要什么数据，然后提供测试的原始数据，之后我在调用该函数(可通过直接调用或事件触发)。断言函数的返回结果。这些就是我们的测试内容。至于该函数是如何处理数据的，并不是测试内容。\n\n## Vue.js 单元测试工具箱\n\n1. [vue-test-utils][vue-test-utils] - 官方\n\n- karma 单元测试环境\n- Mocha 单元测试框架\n- [Chai][Chai] 断言库\n\n2. [ElementFE Vue.js test utils][ElementFE Vue.js test utils]\n\n[vue-test-utils]:https://vue-test-utils.vuejs.org/zh-cn/\n\n[ElementFE Vue.js test utils]:https://github.com/lbwa/vue-unit-test/blob/master/test/unit/util.js\n\n[vue-test-utils 高级技巧]:https://vue-test-utils.vuejs.org/zh-cn/guides/common-tips.html\n\n[Matt O'Connell]:http://slides.com/mattoconnell/deck#/\n\n[Chai]:http://www.chaijs.com/guide/styles/#assert\n\n# 单元测试技巧\n\n## 测试异步行为\n\n首先需要了解的是 `vue-test-utils` 是同步应用 DOM 更新的，那么在 `Mocha` 的 `expect()` 中存在异步操作且还未完成异步操作时，就可能已经调用 `expect()` 来断言了。\n\n在 `Jest` 和 `Mocha` 等单元测试库都定义了一个回调函数 `done()` 来标明测试用例的完成时机。有了该 `done()` 回调函数即表明了，该处代码块是异步操作（具体原理见下文）。我们可以和 `$nextTick` 或 `setTimeout` 结合 `done()` 来保证异步操作在断言之前完成。\n\n`done()`实际用例：[用例一][example-done-1]，[用例二][example-done-2]\n\n## 测试异步行为的原理\n\n结论： `done()` 保证了断言是在下一个事件循环被执行，那么在断言之前的所有异步操作均已完成。\n\n在单元测试库中通过一个 `done()` 回调函数来标明了测试用例的执行时机，其意义在于，只有等到当前事件循环中的所有任务执行（包含了当前事件循环中的所有异步操作的执行）完成后，单元测试库才会调用 `done()` 回调，用于执行断言。此时的，断言已经开启了新的事件循环队列。\n\n之所以，当前事件循环中的异步操作全部被执行的原因是，在一个事件循环中，首先从 marco-task 队列提取第一个任务，在执行这个任务过程中，产生的所有**异步操作**的**回调函数**调用（如，Promise.then()中的参数对象），都将进入 micro-task 队列等待执行。待当前 marco-task 这一任务完成，开始依次执行 micro-task 队列中的任务，直至**清空**该 micro-task 队列。只有等到当前事件循环中的 micro-task 清空后才会进入下一个事件循环，即开启下一个 marco-task 的执行。此时，即是 `done()` 的执行时机，即正因为有了 `done()` 才保证了断言是在下一个事件循环中被执行，那么，在此之前的所有异步操作的回调函数早就已经执行完成了。\n\n以上原理更多的具体分析，可点击查看我的另一篇博文——[《理解 event loop 机制》][event-loop]。\n\n## 测试键盘、鼠标及其他 DOM 事件\n\n（以官方单元测试工具为例）\n\n## 测试环境中的事件触发与监听\n\n```js\nit('测试点击 todo 单项事件 - refreshThisCompleted', done => {\n    const wrapper = mount(ContentItem, {\n      propsData: {\n       // ...\n      }\n    })\n    const button = wrapper.find('.toggle')\n\n    button.trigger('click') // 官方库包装了事件触发以及事件的监听的过程\n\n    // ...\n  })\n```\n`button.trigger('click')` 是官方库的事件触发 API，其包含了事件初始化，事件派发，事件监听等一系列过程。\n\n注：在原本的测试环境中 `Vue.js` 的 watcher 是不能被触发的，其中的 watcher 都是需要手动触发的。\n\n```js\n// 创建事件并触发\nconst evt = new window.Event('click') // Event() 代替 Document.createEvent() 成为标准\nbutton.dispatchEvent(evt)\n// 手动触发 watcher\nvm._watcher.run() // vm 表示测试环境中的 Vue 实例\n```\n\n特别地，特定按键的事件触发如下:\n\n```js\nit('刷新显示的 todo 单项 - refreshItems', () => {\n    const wrapper = mount(LayoutContent)\n    const inputBox = wrapper.find('.add-item')\n\n    inputBox.element.value = 'Test content'\n    inputBox.trigger('keyup.enter') // 与 Vue.js 中的特定事件触发写法相似\n    // ...\n})\n```\n\n参考：[测试环境中的事件][dom-events]\n\n[dom-events]:https://vue-test-utils.vuejs.org/zh-cn/guides/dom-events.html\n\n## 测试环境中的 evt.target\n\n一般情况下 `wrapper.trigger()` 可携带一个对象作为载荷，传递给监听器。但是，这个对象**不能**设置事件 evt.target 对象。原因：[点我][trigger]\n\n那么在需要取得某个元素的 value 值的情况下，我们可以有以下的实现：\n\n```js\nconst input = wrapper.find('input')\ninput.element.value = 100\ninput.trigger('click')\n```\n在调用 `trigger()` 方法之前就设置好该元素的 value 值。\n\n具体使用案例：[点我][trigger1]\n\n[trigger]:https://vue-test-utils.vuejs.org/zh-cn/api/wrapper/trigger.html\n\n[trigger1]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/LayoutContent.spec.js#L38-L50\n\n## 重要事项\n\nVue Test Utils 是同步触发事件。因此 Vue.nextTick 不是必须的。\n\n[example-done-1]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/ContentItem.spec.js#L61-L64\n\n[example-done-2]:https://github.com/lbwa/vue-unit-test/blob/3fcee440f0e0511071d8f559b54b88ab23197904/test/unit/specs/LayoutContent.spec.js#L104-L107\n\n[event-loop]:https://lbwa.github.io/blog/writings/180308-event-loop/\n\n# travis CI\n\n## .travis.yml 中\n\n在 travis CI 集成时，调用 Chrome 的[必须选项][chrome-options]：\n\n```yaml\nsudo: required\n\naddons:\n    chrome: stable\n\nbefore_install:\n  - export CHROME_BIN=chromium-browser\n  - export DISPLAY=:99.0\n  - sh -e /etc/init.d/xvfb start\n```\n\n`export CHROME_BIN=chromium-browser` 表示指定测试时使用的 Chrome 浏览器(最好字指明，还有 `google-chrome` 可选)。\n\n在 `karma.conf.js` [示例配置][karma.conf.js]中调用 `Chrome` 等**界面浏览器**时，以下两项是***必须项***。\n\n`export DISPLAY=:99.0` 指定一个 GUI 测试。[出处][display-origin]\n\n`sh -e /etc/init.d/xvfb start` 指定一个在 `travis CI` 中测试时的图形界面。[出处][xvfb-origin]\n\n特别地，在 travis CI 中调用不需要图形界面的 ChromeHeadless 版本（[示例配置][ChromeHeadless]）的时候，那么以上两项就***不是必须的***。\n\n[ChromeHeadless]:https://github.com/lbwa/vue-ssr/blob/master/test/unit/karma.conf.js#L19-L23\n\n## karma.conf.js 中\n\n在 `karma.conf.js` [示例配置][karma.conf.js]中将部分配置修改如下：\n\n```js\nmodule.exports = function karmaConfig (config) {\n  config.set({\n    // browsers: ['PhantomJS'], 结合 vue-test-utils 挂载时 执行 mount() 会报错\n    // browsers 数组有多项时，将同时调用数组内的所有浏览器开始 unit test\n    browsers: process.env.TRAVIS ? ['Chrome_travis_ci'] : ['Chrome'], // 浏览器\n    customLaunchers: {\n      Chrome_travis_ci: {\n        base: 'Chrome',\n        // https://github.com/karma-runner/karma-chrome-launcher\n        flags: process.env.TRAVIS ? ['--no-sandbox'] : ['']\n      }\n    },\n    // ...\n    coverageReporter: { // karma-coverage配置，配置测试覆盖率的输出目录及格式\n      dir: './coverage',\n      reporters: [\n        { type: 'lcov', subdir: '.' }, // 输出 Icov.info\n        { type: 'text-summary' }, // 输出 网页报告 Icov-report\n        { type: 'json', subdir: '.' } // 输出 coverage-final.json\n      ]\n    }\n  })\n}\n```\n\n在配置中使用 `process.env.TRAVIS` 来判定当前的测试环境，因为在 travis CI 环境中调用 Chrome 时有[权限的限制][chrome-options]，在 travis CI 使用 Chrome 的 `--no-sandbox` 模式来进行单元测试。\n\n另外一种根据不同环境使用 Chrome 的不同模式的**方法**就是，去掉配置中的环境判断，在添加同样的 `customLaunchers` 配置下，根据 [karma-chrome-launcher API][karma-chrome-launcher] 来在 node script 添加 CLI 命令以指定测试的浏览器。\n\n```bash\n$ cross-env BABEL_ENV=test karma start test/unit/karma.conf.js --single-run --browsers Chrome_travis_ci\n```\n\n添加 `--browsers Chrome_travis_ci` 来指定在 travis CI 中的浏览器，因为我们在 [karma.conf.js][karma.conf.js] 中定义了 `customLaunchers` ，那么此时启动的**浏览器及其模式**将会**匹配**我们定义的 `customLaunchers` 项。\n\n# 参考\n\n[vue-test-utils 高级技巧][vue-test-utils 高级技巧]\n\n[Matt O'Connell 关于 Vue.js 的单元测试的演讲][Matt O'Connell]\n\n[How to run JavaScript tests in Chrome on Travis][JS-on-Travis]\n\n[travis CI 默认环境变量][Default Environment Variables]\n\n[JS-on-Travis]:https://swizec.com/blog/how-to-run-javascript-tests-in-chrome-on-travis/swizec/6647\n\n[karma.conf.js]:https://github.com/lbwa/vue-unit-test/blob/master/test/unit/karma.conf.js\n\n[karma-chrome-launcher]:https://github.com/karma-runner/karma-chrome-launcher\n\n[chrome-options]:https://docs.travis-ci.com/user/chrome\n\n[display-origin]:https://docs.travis-ci.com/user/languages/javascript-with-nodejs#Ember-Apps\n\n[xvfb-origin]:https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\n\n[Default Environment Variables]:https://docs.travis-ci.com/user/environment-variables/#Default-Environment-Variables\n"},{"to":"180419-cross-domain-solution","data":"\n## 什么是跨域\n\n跨域，指的是浏览器当前页面不能执行其他网站的脚本。它是由浏览器的**同源策略**造成的，是浏览器对 JavaScript 脚本施加的安全限制。\n\n所谓`同源`是指，**域名，协议，端口**都相同。浏览器执行 JavaScript 脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。\n\n## 对跨域的基本理解\n\n1. 跨域只存在于浏览器客户端，在服务端是不存在跨域的。\n\n2. 跨域时的 ajax 请求并不是没有发出去，此时跨域请求**仍能发出**，且服务端能够收到请求，并返回相应的结果，只是结果在客户端解析时，**被拦截**了。这一点可在请求后的控制台 `network` 选项卡验证，在报错跨域时，仍然能够看到返回的数据结果 `response`。\n\n浏览器在数据返回时会验证是否是同源数据，若不是同源数据，将会进一步**验证数据头部**是否带有 `access-control-allow-origin: *` ，以此来判断返回数据的服务器是否开启了 `CORS` ，并且检查当前源中**允许的源**是否包括了请求源，并作出解析或拒绝解析返回数据的判断。\n\n![跨域请求][cross-domain-solution-img1]\n\n[cross-domain-solution-img1]:https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/Cross-domain-solution/kuayuyanzheng.PNG\n\n## 解决方案\n\n跨域的常见解决方法:\n\n目前为止，跨域请求都必须依靠服务端进行相关配置来处理跨域请求。\n1.  window.name + iframe 需要目标服务器响应 window.name。\n1.  window.location.hash + iframe 同样需要目标服务器作处理。\n1.  html5 的 postMessage + iframe 这个也是需要目标服务器或者说是目标页面写一个 postMessage，主要侧重于前端通讯。\n1.  JSONP 需要目标服务器配合一个 callback 函数。\n1.  CORS 需要服务器设置 header：Access-Control-Allow-Origin。\n1.  服务器（如，自建 nginx 服务器）反向代理，这种方法可以不用目标服务器配合，但是必须搭建一个**中转服务器**，用于转发请求。此法亦可伪造 header 来绕过 JSONP 的 header 验证\n\n现在一般常用的是方法是 4，5，6。\n\n## 拓展：关于 ajax 的同源限制\n\n简短来说，客户端的 ajax 请求只能请求同源数据。\n\n举例来说，a 网站有一个 ajax 请求 x，a 在没有配置后端的情况下，b网站是不能直接使用 ajax 跨域请求 a 网站的请求 x（浏览器同源策略），只有当 a 网站的请求 x 是 JSONP 请求时，b 网站才能通过 ajax 代理 JSONP 请求并伪造 header 请求 x。或将b网站的 ajax 请求由中转服务器转发去请求 x。\n\n## 反向代理解决需要跨域的 ajax\n\n反向代理原理：浏览器有同源限制，但**服务器没有同源限制**，那么可以利用这一特性来使用本地服务器来转发请求\n\n前后端分离开发过程中，webpack-dev-server （基于 express 的实现）设置 [devServer.before][devServer.before] 来实现反向代理，示例配置[点我][fanxiandaili]\n\n[fanxiandaili]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L28-L116\n\n[devServer.before]:https://doc.webpack-china.org/configuration/dev-server/#devserver-before\n\n## 反向代理解决需要验证 header 的 JSONP\n\n现象：JSONP 本身是不具有模拟 headers 的功能的。\n\n原理：当目标是需要验证 header 的 JSONP 请求时。使用中转服务器的 axios 请求模拟目标 JSONP 请求及其 header。返回的数据格式是携带有目标数据的回调函数。\n\n典型的需要验证 header 的 JSONP 请求模拟[示例][the-recommend.js-jsonp]\n\n```js\nexport function getJSONPData (recommendId) {\n  const data = {\n    ...commonParams,\n    ...{\n      type: 1,\n      json: 1,\n      utf8: 1,\n      // ... some request params\n    }\n  }\n\n  // 在没有 header 验证的情况下直接使用 jsonp 请求 url，否则使用后端 ajax 代理转发 JSONP 请求\n  // return jsonp(TARGET_URL, data, {\n  //   ...options,\n  //   // https://github.com/webmodules/jsonp/blob/master/index.js#L50\n  //   prefix: '', // 回调函数前缀，默认值为 __jp\n  //   name: 'playlistinfoCallback' // 回调函数名，默认值为从 0 开始的计数器\n  // })\n\n  return axios.get(TARGET_URL, {\n    params: data\n  }).then(res => res.data)\n}\n```\n\n中转服务器示例配置(express 为例)[点我][aqjhddm]\n\n```js\n// devServer.before(它是一个 express API)\n\napp.get('/api/getJSONPData', (req, res) => {\n  const url = 'https://example.com'\n\n  axios.get(url, {\n    // 伪造 JSONP 的 headers\n    headers: {\n      referer: 'https://example.com',\n      host: 'https://example.com'\n    },\n    params: req.query\n  }).then(response => {\n    let ret = response.data\n\n    // 提取返回的 JSONP 数据中的回调函数中的参数（即目标数据）\n\n    if (typeof ret === 'string') {\n      // 该正则不具有普适性\n      const reg = /^\\w+\\(({.+})\\)$/\n      const matches = ret.match(reg)\n\n      if (matches) {\n        ret = JSON.parse(matches[1])\n      }\n    }\n    res.json(ret)\n  }, err => {\n    throw Error(`Proxy failed, ${err}`)\n  })\n})\n```\n\n以上两个配置对比普通的 JSONP 请求，可看出，当（**前提条件**） JSONP 有 header 验证时，转为使用 后端代理 ajax 请求 JSONP 数据，（**返回数据的处理方法**）返回的数据是包含之前 JSONP 的回调函数名的，可在 [剔除回调函数][tchdhs] 看出，需要对返回的数据剔除回调函数名，并转为 JSON 正确格式\n\n## 反向代理适用场景\n\n### 场景一：目标服务器返回 JSON 格式\n\n在后端代理请求返回数据格式为 JSON 的情况下，api 不要使用 JSONP 访问后端中转服务器的 url ，尽管 api 能收到正确的数据内容，但格式是错误 `(Uncaught SyntaxError: Unexpected token :)` 的！！因为中转服务器 axios 请求目标服务器返回的数据是 JSON 格式。中转服务器会将目标服务器返回的数据转发回 api ，那么 JSONP 是**无法正确解析** JSON 格式的（JSON 格式没有回调函数）。即请求的类型数据格式要对应相应的请求类型。\n\n### 场景二：目标服务器返回 JSONP 格式\n\n当目标服务器返回的是 JSONP 格式时，***仍然使用 axios 请求中转服务器***，不同于场景一的是，在返回的 JSONP 数据中需要**剔除回调函数并转化为 JSON 格式**。\n\n那么可总结为，使用 axios 转发模拟带 headers 验证的 JSONP 时，***必须以 ajax 请求中转服务器***。我们根据目标服务器返回给中转服务器的数据类型来决定是否在中转服务器中添加**剔除回调函数并转化为 JSON 格式**这一数据处理的步骤。\n\n[header-refer-JSONP]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L47-L71\n\n[the-recommend.js-jsonp]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L33-L59\n\n[aqjhddm]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L74-L100\n\n[tchdhs]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.dev.conf.js#L85-L95\n\n### 易错点：反向代理转发请求时返回错误格式\n\n现象：[链接][fxdlgscw]高亮处 JSONP 请求中转服务器，返回格式错误\n\n原因：目标服务器只接受 ajax 请求（返回的数据不会有回调函数包裹）时，我们的网页也只能以 ajax 请求中转服务器，中转服务器转发 ajax 请求。若我们的网页使用 JSONP 来请求中转服务器，那么我们最后收到的是 ajax 类型的返回数据，并没有一个回调函数来包裹返回数据，那么就没有可执行的回调函数。即造成了格式错误。\n\n[fxdlgscw]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L49-L55\n\n解决方案：[使用 axios 请求][axios-request]后端中转服务器，返回正确格式\n\n[axios-request]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-recommend.js#L56-L59\n\n\n## JSONP\n\nJOSNP 意为 `JSON with padding`，本质是动态创建 script 标签的 src 属性来请求数据，因为 `<script>` 的 `src` 属性是可以**跨域的。**\n\n原理：\n\n1. 首先是利用 `<script>` 的 `src` 属性来实现跨域。\n\n1. 通过将前端方法作为**参数**传递到服务器端，然后由服务器端注入参数之后再返回，实现服务器端向客户端通信。客户端在收到返回数据时，就会执行被回调函数包裹的目标数据。\n\n1. 由于使用 script 标签的 src 属性，因此**只支持get方法**\n\n**直接**使用 jsonp 方法访问源地址，这在**没有 referer 验证的情况下**可返回正确的数据，若需要 referer 验证(在 Chrome Devtool network 选项直接点击链接是否能返回正确数据)，那么使用 axios 后端代理转发请求。因为 JSONP 本身不能伪造 headers ，反向代理的目的是**伪造 header。**\n\n典型的 JSONP 请求[点我][jsonp-example]\n\n[jsonp-example]:https://github.com/lbwa/vue-sonar/blob/master/src/api/the-artist.js#L4-L20\n\n### JSONP 的局限性\n\n1. 只支持 GET 请求\n\n1. 因为是通过 `<script>` 的 `src` 属性来实现跨域的，那么我们是无法验证请求数据的安全性，那么我们必须确保请求的域的安全性\n\n1. 必须另外添加计时器来判断是否请求成功\n\n## 参考\n\n[MDN Same-Origin Policy][browser]\n\n[HTML Standard Concept-origin][browser1]\n\n[我知道的跨域与安全][all-I-know-about-cross-domain]\n\n[ajax 跨域解决方案][CORSajaxky]\n\n[如何解决前后端分离中的 ajax 跨域问题][rhjjqhdflzdkywt]\n\n[常见 jsonp 出现格式错误的原因][cjjcxgscw]\n\n[cjjcxgscw]:https://www.zhihu.com/question/264546160\n\n[CORSajaxky]:https://segmentfault.com/a/1190000012469713#articleHeader12\n\n[all-I-know-about-cross-domain]:https://juejin.im/post/5a6320d56fb9a01cb64ee191\n\n[rhjjqhdflzdkywt]:https://www.zhihu.com/question/265985355\n\n[browser]:https://developer.mozilla.org/en-US/docs/Web/Security/Same-origin_policy\n\n[browser1]:https://html.spec.whatwg.org/multipage/origin.html#concept-origin\n"},{"to":"180418-summary-of-vue-sonar","data":"\n# 移动端点击存在 300 ms 延迟\n\n## 缘由\n\n出现延迟的原因：[What Exactly Is The 300ms Click Delay][click-delay]\n\n简短来说，移动端的 300ms 延迟是浏览器厂商的一个设置，这是因为移动端浏览器是支持双击触摸操作的，厂商设置等待约 300ms 是为了**判断用户的点击行为**到底是单击操作还是双击操作。\n\n## 解决方案\n\n为了提升移动端的体验，使用 [FastClick.js][FastClick.js] 来优化这 300ms 的延迟， 它通过**事件代理**的方式来排除移动端浏览器对物理点击的 300ms 毫秒判断。\n\n其他参考：[FastClick 源码解读][fastClick-reference]\n\n[fastClick-reference]:https://segmentfault.com/a/1190000004295106\n\n[click-delay]:https://www.telerik.com/blogs/what-exactly-is.....-the-300ms-click-delay\n\n[FastClick.js]:https://github.com/ftlabs/fastclick\n\n# 跨域解决方案\n\n## 什么是跨域\n\n跨域，指的是浏览器当前页面不能执行其他网站的脚本。它是由浏览器的**同源策略**造成的，是浏览器对 JavaScript 脚本施加的安全限制。\n\n所谓`同源`是指，**域名，协议，端口**都相同。浏览器执行 JavaScript 脚本时，会检查这个脚本属于哪个页面，如果不是同源页面，就不会被执行。\n\n## 解决方案\n\n[点我，查看我的另一篇博文][cross-domain-origin]\n\n[cross-domain-origin]:https://lbwa.github.io/blog/writings/180419-cross-domain-solution/\n\n# 基础模块通过 npm 下载\n\n一般常用的基础模块可发布至 npm 中，在开发时，通过 npm 下载。\n\n# event.currentTarget and event.target\n\nevent.currentTarget 是注册事件时所指向的元素，而 event.target 是响应事件的最小子元素，也就是最深层级的触发事件的元素，需要开发者合理使用。\n\n监听程序的执行元素：event.currentTarget\n\n事件捕获的目标，或称事件冒泡的触发者：event.target\n\n# request Headers\n\n5XX 错误：都是服务器错误\n\n在服务器没挂的情况下，jsonp 请求不到数据的原因可能是服务器设置了 头部中 host 和 referer 验证（jsonp 是无法绕过（伪造） host 验证的）\n\n解决方案： webpack-dev-server 代理使用 ajax 跨域请求\n\n# Vue.js 中的 $nextTick() 实现\n\nsetTimeout 是 this.$nextTick 的一种实现，nextTick 本质上是利用 [事件循环][eventloop]来 达到异步更新目的\n\n为兼容所有手机，`this.$nextTick(() => {})`可用`setTimeout(() => {}, 20)`来代替，其中 20ms 是经验值\n\n参考：[点我][vuenexttickshixian]\n\n[vuenexttickshixian]:https://mp.weixin.qq.com/s/mCcW4OYj3p3471ghMBylBw\n\n[eventloop]:https://lbwa.github.io/blog/writings/180308-event-loop/\n\n>事实上，vue在2.5版本中已经删去了MutationObserver相关的代码，因为它是HTML5新增的特性，在 iOS 上尚有bug。\n\n## ios 网页版 audio 需要用户点击才能播放\n\n在组件 `app-player` 中的 `currentSong` 的 watcher 中的调用 audio 的 play() 方法在 IOS 上是[无法播放][cannotplay]（[解决方案][solveplayproblem]）的，此法会被 safari 拦截，那么 ios 需要用户来点击（得到用户的 action ）播放\n\n[cannotplay]:https://github.com/DDFE/DDFE-blog/issues/24\n[solveplayproblem]:https://github.com/vuejs/vue/issues/7109\n\n原因：本质是 vue.js 的 nextTick 机制导致的无法播放的问题。[参考][vuenexttickshixian]\n\n[vuenexttickshixian]:https://mp.weixin.qq.com/s/mCcW4OYj3p3471ghMBylBw\n\n# 区分基础组件和业务组件\n\n基础组件不会出现业务逻辑，将基础组件中的业务逻辑使用 `this.$emit` 派发给业务组件\n\n基础组件常见内容: props、state、methods（**侧重**被外部调用，改变基础组件的状态，并不是侧重处理数据的 methods）、event（向外部传递并携带载荷，告知数据变化）\n\n基础组件一般不放跟 vuex 数据处理相关的东西，***基础组件侧重展示数据的功能***。\n\n# 滚动组件\n\n若 app 有多处相同方式滚动区域，那么可结合 **slot 匿名插槽** 将滚动组件单独作为一个基础组件。\n\n滚动基础组件中包含一些**代理**执行的函数，可从**外部调用**执行来更新组件内部状态。\n\n```js\n // child component\n // 代理执行的方法，意在组件外部调用内部方法更新组件状态\n  enable () {\n    this.scroll && this.scroll.enable()\n  },\n  \n  disable () {\n    this.scroll && this.scroll.disable()\n  },\n\n  refresh () {\n    this.scroll && this.scroll.refresh()\n  }\n```\n```js\n// parent component\n// 在外部改变子组件（ref=\"child\"）内部状态\nthis.$refs.child.enable()\nthis.$refs.child.disable()\nthis.$refs.child.refresh()\n```\n\n可能遇见的问题：\n\n1.基础滚动组件中的 slot 插槽内容可能包含 ajax 请求数据，那么必须在 ajax 返回数据之后刷新基础组件，否则将得到错误的计算高度，那么也就无法滚动。\n\n一种解决方案就是： 传入一个 data 对象（该对象即是 ajax 返回数据）到滚动组件中，那么当数据返回时将触发基础滚动组件中的 watcher ，这样就可以刷新组件了。\n\n# better-scroll 常见问题\n\n1. 初始化 better-scroll 时机，常见在滚动区域有 ajax 请求时，要在 ajax 得到数据后刷新组件，即 `this.scroll.refresh()`。\n1. 当滚动区域包含 ajax 请求时，可用 padding-top 占位或监听 load 事件（图片请求）刷新滚动组件。\n1. 在滚动组件内部，建立一个 watcher ，它观察的值是一个 ajax 返回数据，当该数据对象变化时，将触发 watcher ，这样滚动组件就可**自我刷新**。\n\n# 图像懒加载\n\n页面有很多图像时，使用图像懒加载，在图像进入视口时才加载，否则为默认图像\n\n原理：\n\n``` html\n<img src=\"默认图像地址\" data-src=\"真实图像地址\">\n```\n\n在图像进入视口之后，src 地址被替换为真实图像地址\n\n推荐插件：[vue-lazyLoad][vue-lazyLoad]\n\n[vue-lazyLoad]:https://github.com/hilongjw/vue-lazyload\n\n\n# 给用户一个等待预期\n\n在等待 ajax 返回数据时，显示`正在载入...`样式组件\n\n# 在什么时候使用弹性布局\n\n思考使用弹性布局的时机，现阶段移动端对于弹性布局都有良好的支持，那么在移动端页面开发时，首先应尝试使用弹性布局。\n\n# 类通讯录组件的开发\n\n（以组件`base-list`为例）\n\n## 滚动行为\n\n### 计算高度\n\n设立一个 watcher 观察传入组件的 props 的变化，在 vue 更新 DOM 之后（nextTick）调用计算高度的函数 `_calculatHeight` 函数，计算各个类别元素的高度，加上初始高度 0，即可得到各个锚点（anchor）的位置，用 `listHeight` 变量存储。\n\n```js\n_calculateHeight {\n  const group = this.$refs.group\n  let listHeight = []\n  let height = 0\n\n  this.listHeight.push(0)\n\n  for (let i = 0; i < group.length; i++) {\n    // clientHeight = height + padding - 水平滚动条\n    height += group[i].clientHeight\n    this.listHeight.push(height)\n  }\n}\n```\n\n### 监听 scroll 事件，建立直达锚点函数\n\n以下于基础滚动组件中操作\n\n#### 派发 scroll 事件\n\n监听 scroll 事件，是为了得到当前 scrollY 值\n\n子组件 `base-scroll.vue`（以`better-scroll` 和 `slot 插槽` 建立的滚动基础组件）中设置监听事件 `scroll` ，并在事件处理程序中向父组件派发一个 `scroll` 事件。\n\n```js\n// 在初始化组件的函数中加入\nif (this.listenScroll) { // this.listenScroll 是 props 属性，表示是否监听 scroll 事件\n  let that = this\n  this.scroll.on('scroll', pos => { // 监听原生滚动事件，派发一个滚动事件\n    that.$emit('scroll', pos) // pos 包含当前滚动坐标值，形如 {x: 0, y:0}\n  })\n}\n```\n\n父组件中的监听程序\n\n```js\nscroll () {\n  this.scrollY = pos.y\n}\n```\n\n#### 建立直达锚点的函数\n\n调用 `better-scroll` 自带函数 `this.scroll.scrollTo()` 和 `this.scroll.scrollToElement()`\n\n[示例][scrollTo]\n\n### 1.3. 监听 scrollY 变化，以计算当前 currentIndex\n\n```js\nwatch: {\n  scrollY (newY) { // watch 中函数可传入 newValue 和 oldValue，表示新值和旧值\n    const listHeight = this.listHeight\n    // 当位于顶端时\n    if (newY > 0) {\n      this.currentIndex = 0\n    }\n    // 当位于中段时\n    for (let i = 1; i < listHeight.length - 1; i++) {\n      let heightStart = listHeight[i]\n      let heightEnd = listHeight[i + 1]\n      if (-newY >= heightStart && -newY < heightEnd) { // 检测当前的可视区间\n        this.currentIndex = i\n      }\n    }\n    // 当位于列表底端时\n    this.currentIndex = listHeight.length - 2\n  }\n}\n```\n\n### 设置激活 active 类的条件\n\n``` html\n<!-- index 为 v-for 中的 key 值-->\n<span :class=\"currentIndex===index? 'active\" : ''>\n```\n\n触摸触发 active 切换：\n\n```js\n_scrollTo (index) {\n  this.scrollY = -this.listHeight[index] // 效果：点击行为切换 active 类\n  //...\n},\n```\n\n滚动触发 active 切换：\n\n```js\n_scrollTo (index) {\n  // ... \n  this.$refs.list.scrollToElement(this.$refs.group[index], 0) // 调用子组件方法跳转至锚点, 0表示动画时间\n},\n```\n\n触摸和滚动事件都会触发方法 `_scrollTo`，使得跳转至目标锚点,`_scrollTo` 即是跳转函数\n\n## 触摸行为\n\n### 建立 data-index\n\n在导航单个元素上建立一个 `data-index=\"index\"` 属性，用于得到当前锚点的索引值\n\n在基础 js 中添加一个类，该类功能是得到自定义 `data-` 属性的值或添加自定义属性给目标标签\n\n注：这里涉及到一个复用的思维，即可能在之后的开发中复用该功能，那么我们可以将该函数独立到公共 JS 中。\n\n```js\nexport function getData (el, name, value) {\n  const prefix = 'data-'\n  name = prefix + name\n  if (value) {\n    return el.setAttribute(name, value)\n  } else {\n    return el.getAttribute(name)\n  }\n}\n```\n\n### touchstart 事件\n\n```js\n// 得到锚点 index ，调用 better-scroll 方法跳转至锚点\nonTouchStart (evt) {\n  let anchorIndex = getData(evt.target, 'index') // 得到自定义 data-index 值\n  this.touch.y1 = evt.touches[0].pageY // pageY 触摸目标在 HTML 文档中的 Y 坐标\n  this.touch.anchorIndex = anchorIndex\n  this._scrollTo(anchorIndex)\n}\n```\n### touchmove 事件\n\n```js\n// 计算偏移距离，以至于得到偏移个数，之后调用跳转元素方法，达到 touchmove 滚动 list 的效果\nonTouchMove (evt) {\n  this.touch.y2 = evt.touches[0].pageY\n  let jumpNumber = (this.touch.y2 - this.touch.y1) / ANCHOR_HEIGHT | 0 // 触摸偏移。其中设置初始值 0\n  let anchorIndex = parseInt(this.touch.anchorIndex) + jumpNumber // anchorIndex 为字符串\n  this._scrollTo(anchorIndex)\n}\n```\n\n[示例][base-list]\n\n[base-list]:https://github.com/lbwa/vue-sonar/blob/master/src/base/base-list.vue\n\n[scrollTo]:https://github.com/lbwa/vue-sonar/blob/master/src/base/base-scroll.vue#L33\n\n# 模拟 position: sticky 效果\n\n原理： 计算 scrollY 与第 i + 1 个锚点开始的 y 坐标的差值，当差值小于 title 高度时，原 title 向上移动（title 高度 - 差值）像素。\n\n# mutations\n\nmutations 常有 mutation-types.js 来存储 mutation 的名字（设置为常量）\n\n```js\n//...\nimport createLogger from 'vuex/dist/logger' // 每次修改 state ，都会打印新旧 state\n\nVue.use(Vuex)\n\nconst debug = process.env.NODE_ENV !== 'production'\n\nexport default new Vuex.Store({\n  state,\n  getters,\n  mutations,\n  actions,\n  strict: debug, // 检测是否是 mutations 修改 state,非法修改将报错。因有性能损失，则不能在生产环境开启\n  plugins: debug ? [createLogger()] : []\n})\n\n```\n\n# 业务逻辑层和表现层\n\n业务逻辑（常见于业务组件）也是核心逻辑，业务逻辑层***专注于数据的处理***，因业务逻辑层常改变，所以将业务逻辑层独立出来，降低修改业务逻辑对其他层的影响。业务逻辑的特点是不与使用者交互\n\n表现层（常见于基础组件）专注于***数据展现***，指界面和交互。\n\n# 在单文件组件中引用子组件\n\n``` html\n<child-component ref=\"child\">\n```\n```js\nthis.$refs.child // 返回对组件的引用\nthis.$refs.child.$el  // 返回对 DOM 节点的引用\n```\n\n总结：`ref=\"name\"` 在 DOM 上使用时 `this.$refs.name` 引用的是 DOM 节点，在组件上使用时，则引用的是组件，若要在组件上引用渲染后的组件，那么使用 `this.$refs.name.$el`\n\n注：只有在 `mounted` 生命周期之后才有 `$el`，在 `created` 时期 `$el` 不可见\n\n# data 对象\n\n在 vue Devtool 中，除非给 data 添加一个 watcher 否则，将在 Devtool 中**不会**响应式变化\n\n# 浏览器能力检测 - 简单实现 autoprefixer\n\n目标：实现 autoprefixer 的自动添加厂商前缀\n\n```js\n// 浏览器能力检测，查询能够被当前浏览器识别的前缀\nlet elementStyle = document.createElement('div').style\n\nlet vendor = (() => {\n  transformNames = {\n    webkit: 'webkitTransform',\n    Moz: 'MozTransform',\n    O: 'OTransform',\n    ms: 'msTransform',\n    standard: 'transform'\n  }\n\n  for (let key in transformNames) {\n    if (elementStyle[transformNames[key]] !== undefined) {\n      return key\n    }\n  }\n\n  return false // 没有任何已知前缀能被当前浏览器识别时\n})\n\nexport function prefixStyle (style) {\n  if (vendor === false) { // 没有任何已知前缀能被当前浏览器识别时\n    return false\n  }\n\n  if (vendor === 'standard') {\n    return style\n  }\n\n  return vendor + style.charAt(0).toUpperCase() + style.substr(1)\n}\n```\n\n## 调用变量属性\n\n常见场景： 兼容不同浏览器，可能会有不同的 CSS 属性名\n\n```js\n// const transform = prefixStyle('transform')\nthis.$refs.cd.style[transform] = `translate3d(${x}, ${y}, 0) scale(${scale})`\n```\n\n以上因为 transform 为变量，所以在引用时，是引用的变量 transform ，故**只能**使用**方括号法**访问属性，而不是点属性法\n\n# common/js/config.js 放置整个项目的配置文件\n\n在 Vuex 的 store 文件中，\n\nstate 只保留最基础的数据，能够通过基础数据计算得到的值放置到 getters 中。\n\nmutations 最好建立一个 mutations-type.js 来封装各个 mutation 的名字为常量，意义在于使得 linter 之类的工具发挥作用，和使得合作者一目了然存在哪些 mutation。\n\nactions 用于异步操作或对 mutations 的封装（封装需要一次触发多个 mutations 的操作）\n\n# 子组件派发事件，传递数据\n\nbase 组件（即基础组件）**只**起展示作用？数据处理**都**在在业务组件中处理？\n示例： base-song-list.vue 中的 selectItem 处理函数，该函数处理点击歌曲后向父组件派发一个 select 事件，载荷为点击的歌曲和该歌曲的索引。base 组件中的最终目标是展示传进来的数据，对于数据的改变是**不在**该组件中处理，转而派发事件，或触发 mutations 或 actions 提交\n\n以上，待验证总结其他基础组件的最终目的是否也是只是展示传进来的数据，不处理变化的数据。\n\n子组件（扩展为基础组件）只管尽可能地提供它所能够提供的数据(this.$emit()的载荷)，而不去管最后这些数据哪些能够被使用，以及如何被使用。综合的，子组件的角色定位是`只管提供数据`，子组件`并不知道如何使用这些它传出的数据`，子组件不管数据的使用，故`不应该因为外部如何使用数据或使用哪些数据来定义子组件的提供数据这一行为`。\n\n子组件（扩展为基础组件）的角色定位是`只管提供数据`，父组件监听子组件事件，得到传出的数据，并处理数据（哪些数据需要使用，以及如何使用）\n\n示例：\n\n```js\n// base-song-list 组件中\n// template\n@click=\"selectedItem(item, index)\"\n\n// script\nselectedItem (song, index) {\n  this.$emit('select', song, index)\n}\n```\n子组件（扩展为基础组件）中派发 select 事件，传递点击事件后产生的载荷 song 和 index，此时，子组件（扩展为基础组件） base-song-list 并不知道这里的载荷 song 和 index 接下来将被如何使用，以及会不会使用，它的职责**只是**提供他所能够提供的数据 song 和 index。这里的一个思维就是：不要以派发事件 select 之后如何使用数据来定义子组件（扩展为基础组件） base-song-list 传递数据的这一行为，如何使用数据并不是子组件 base-song-list 的职责\n\n```js \n// parts-music-list 组件中\n// template\n@select=\"selectedSong\"\n// script\nmethods: {\n  ...mapActions([\n    'selectedPlay'  // actions 映射\n  ]),\n  selectedSong (item, index) {\n    this.selectedPlay({\n      list: this.songs,\n      index\n    })\n  }\n  // ...\n}\n```\n在父组件 parts-music-list 中，事件处理程序 selectedSong 中由子组件（扩展为基础组件）传入的数据 song 和 index 只使用了 index，而没有使用 song。\n\n父组件中才会处理传入的数据\n\n子组件（扩展为基础组件）的数据只与自身相关，如何处理如何使用传出的数据，不是子组件（扩展为基础组件）的职责。\n\n# 元素的百分比宽度和高度的计算\n\n元素的百分比宽高是依据**包含块**（containing block）的宽高(指内容区的宽高)来计算的。\n\n关于包含块（containing block）的概念，不能简单地理解成是父元素。如果是静态定位和相对定位（位于普通流中），包含块一般就是其父元素。但是对于绝对定位（position: absolute）的元素，包含块应该是离它最近的 position 为 absolute、relative、或者 fixed 的祖先元素。对固定定位（position: fixed）的元素，它的包含块是视口（viewport）。\n\n\n参考：[w3c height][w3c-height]、[CSS Standard property index][CSS-Standard-property-index]\n\n[w3c-height]:https://www.w3.org/TR/CSS21/visudet.html#the-height-property\n\n[CSS-Standard-property-index]:https://drafts.csswg.org/css-box/#property-index\n\n# 定义 vue transition 组件中的各个部分的动画\n\n``` scss\n&.normal-enter-active, &.normal-leave-active {\n  transition: all .4s;\n  .parts-top, .parts-bottom {\n    transition: all .4s ease;\n  }\n}\n&.normal-enter, &.normal-leave-to {\n  opacity: 0;\n  .parts-top { // Chrome simulator 有一定几率出现只有一个部分进入动画，IOS 正常\n    transform: translate3d(0, -100px, 0);\n  }\n  .parts-bottom {\n    transform: translate3d(0, 100px, 0);\n  }\n}\n```\n\n# 动画性能优化\n\n当在使用 @keyframes 动画时，如果做的动画比较复杂的话，就会导致动画不流畅，掉帧，尤其是移动端掉帧特别明显。这是因为，如果@keyframes 改变的属性是与 layout 相关的话，就会**触发重新布局**，导致渲染和绘制的时间会更加地长。 所以，应该尽可能地使用不会触发重新布局的属性来完成动画。\n\n触发重新布局的属性有： width, height, margin, padding, border, display, top, right, bottom ,left, position, float, overflow等。应该尽量规避使用。\n\n不会出发重新布局的属性有：transform(其中的translate, rotate, scale), color, background等。应该尽量用这些去取代。\n\n# 便捷格式化数字的方法\n\n**数字格式化**\n\n[Number.prototype.toLocaleString][toLocaleString]( [ locales [, options ] ] ) 可将数字格式化为特定格式**字符串**，如**补0**。控制位数，是否有逗号（分隔符），添加货币符号等等。\n\n注：该方法最终返回的结果是**字符串**。使用补0时，第一个参数 locales 要设置（如：'zh'）。\n\n```js\nconst num = 2333333;\nnum.toLocaleString('zh', { style: 'decimal' }) // 2,333,333\nnum.toLocaleString('zh', { style: 'percent' }) // 233,333,300%\nnum.toLocaleString('zh', { style: 'currency' }) // 报错\nnum.toLocaleString('zh', { style: 'currency', currency: 'CNY' }) // ￥2,333,333.00\nnum.toLocaleString('zh', { style: 'currency', currency: 'cny', currencyDisplay: 'code' }) // CNY2,333,333.00\nnum.toLocaleString('zh', { style: 'currency', currency: 'cny', currencyDisplay: 'name' }) // 2,333,333.00人民币\nnum.toLocaleString('zh', { minimumIntegerDigits: 5 }) // 02,333.3\n\n//如果不想有分隔符，可以指定 useGrouping 为 false\nnum.toLocaleString('zh', { minimumIntegerDigits: 5, useGrouping: false }) // 02333.3\nnum.toLocaleString('zh', { minimumFractionDigits: 2, useGrouping: false }) // 2333.30\n\n// 控制有效数字\nconst num = 1234.5\nnum.toLocaleString('zh', { minimumSignificantDigits: 6, useGrouping: false }) // 1234.50\nnum.toLocaleString('zh', { maximumSignificantDigits: 4, useGrouping: false }) // 1235\n```\n\n**日期格式化**\n\n[Date.prototype.toLocaleString][toLocaleString]( [ locales [, options ] ] ) 可将数字格式化为特定格式**字符串**\n\n```js\nconst date = new Date();\ndate.toLocaleString('en', { weekday: 'narrow', era: 'narrow' }) // W A\ndate.toLocaleString('en', { weekday: 'short', era: 'short' }) // Wed AD\ndate.toLocaleString('en', { weekday: 'long', era: 'long' }) // Wednesday Anno Domini\n\nconst date = new Date();\ndate.toLocaleString('zh', { timeZoneName: 'short' }) // 2018/4/5 GMT+8 下午7:18:26\ndate.toLocaleString('zh', { timeZoneName: 'long' }) // 2018/4/5 中国标准时间 下午7:18:26\n\nconst date = new Date()\ndate.toLocaleString('zh', { year: 'numeric',  month: 'numeric',  day: 'numeric',  hour: 'numeric',  minute: 'numeric',  second: 'numeric', }) // 2018/4/5 下午7:30:17\ndate.toLocaleString('zh', { year: '2-digit',  month: '2-digit',  day: '2-digit',  hour: '2-digit',  minute: '2-digit',  second: '2-digit'  }) // 18/04/05 下午7:30:17\n\nconst date = new Date();\ndate.toLocaleString('en', { month: 'narrow' }) // A\ndate.toLocaleString('en', { month: 'short' }) // Apr\ndate.toLocaleString('en', { month: 'long' }) // April\n\n```\n\n[toLocaleString]:https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/toLocaleString\n\n# $refs 对象的生命周期\n\n```js\ncomputed: {\n  /**\n  * https://cn.vuejs.org/v2/api/#ref\n  * $refs 本身是作为渲染结果存在的，故在 mounted 之前 $refs 是不存在的，故查询\n  * $refs.bar 的宽度只能使用 watcher 时查询。\n  */\n\n  currentBtn () {\n    const progressLength = this.$refs.bar.clientWidth // 报错\n    return {\n      transform: `translateX(${this.currentPercent * progressLength}px)`\n    }\n  }\n}\n```\n\n示例中是无法查询到 `this.$refs.bar` 标签的宽度的，经试验 `computed 属性` 在 created 时期之后，mounted 时期之前执行，而 `$refs` 对象是作为渲染结果的存在，那么在执行 `computed 属性` 中函数时，`this.$refs` 是 `undefined`。\n\n**总结：**`this.$refs`对象只在渲染后填充，不能在 `computed 属性` 中调用 `this.$refs`对象。参考：[子组件引用][refs]\n\n[refs]:https://cn.vuejs.org/v2/guide/components.html#子组件引用\n\n# 进度条组件中的点击事件与触摸事件\n\n## 比较点击与触摸事件的共同点：\n\n因为在基础组件中不处理业务逻辑，那么通过改变进度条样式来**触发**播放器时间改变。\n\n### 改变样式\n\n```js \nmethods: {\n  // ...\n  _offset (length) { // 修改当前显示进度的样式\n    this.$refs.progress.style.width = `${length}px`\n    this.$refs.progressBtn.style[TRANSFORM] = `translateX(${length}px)`\n  }\n  // ...\n}\n```\n\n### 修改时间\n\n在基础组件中，是不应该有业务逻辑的。换句话说，业务逻辑只出现在业务组件中，那么在修改样式之后，通过向父组件派发事件的方式来启动业务逻辑。\n\n```js\nmethods: {\n  // ...\n  _triggerPercent () { // 载荷为目标时间百分比（当前样式百分比）\n    // 计算修改够的样式百分比\n    const progressLength = this.$refs.progressBar.clientWidth - PROGRESS_BTN_WIDTH\n    const percent = this.$refs.progress.clientWidth / progressLength\n\n    this.$emit('percentChange', percent)\n  }\n  // ...\n}\n```\n\n## 触摸事件\n\n关键点：利用 `touch` 事件中特有的事件对象得到各个基础数据，进而得到移动距离。\n\n组件初始化时，建立一个在 `touchstart`,`touchmove`,`touchend` 三个事件中可共享的数据容器\n\n```js\ncreated () {\n  this.touch = {}\n}\n```\n\n### touchstart\n\n得到当前播放控件的坐标位置，为后续计算移动距离做准备\n\n```js\nprogressTouchStart (evt) {\n  this.touch.initiated = true // 表示是否已经初始化\n  this.touch.startX = evt.touches[0].pageX\n  this.touch.left = this.$refs.progress.clientWidth\n}\n```\n\n### touchmove —— 计算当前的移动距离\n\n```js\nconst PROGRESS_BTN_WIDTH = 16 // 圆点控件的宽度\n\nprogressTouchMove () {\n  if (!this.touch.initiated) { return }\n\n  // 当前位移\n  const displacement = evt.touches[0].pageX - this.touch.startX\n  // 总移动长度\n  const progressLength = this.$refs.progressBar.clientWidth - PROGRESS_BTN_WIDTH\n  const offsetLength = Math.min(progressLength, Math.max(0, this.touch.left + displacement))\n\n  this._offset(offsetLength) // 触发进度条样式的改变\n}\n```\n\n### touchend —— 重置初始状态\n\n```js\nprogressTouchEnd (evt) {\n  this.touch.initiated = false\n  this._triggerPercent() // 派发事件，启动业务逻辑\n}\n```\n\n由 touchmove 事件中的样式改变结果，计算时间百分比。向父组件派发事件来启动修改播放器时间的业务逻辑。\n\n## click 事件\n\n### 当前点击的位置 —— offsetX\n\n```js\nmethods: {\n  // ...\n  progressClick (evt) {\n    this._offset(evt.offsetX) // 修改样式\n    this._triggerPercent() // 获得目标百分比，并派发事件和载荷，以启动修改时间的业务逻辑\n  }\n  // ...\n}\n```\n\n在 click 事件中，与 touch 事件共同的关键点是得到当前点击位置的 X 坐标，这样才能得到目标百分比来修改播放器时间。\n\n而在 click 事件中，事件对象有一个 `offsetX` 属性，该属性表示事件对象与目标节点的 `padding edge` 在 X 轴方向上的偏移量。这里得到的数据即是目标位置。\n\n## 总结\n\n综上分析，不论是在 click 事件还是 touch 事件中，**最重要**的是解决获取当前位置的问题，当获取到当前位置，那么就可得到目标百分比，进而派发事件，携带载荷来修改播放器的当前时间。\n\n据此，我们也可得到一些开发组件的经验。在开发组件之前，预想设想组件的使用场景，得到将会产生**哪几种事件**，他们的**公共驱动点**在哪？如何使用最少的代码量来**驱动**不同的事件所带来的数据改变。\n\n# 在某数值范围内循环\n\n```js\nmethods: {\n  // ...\n  changeMode () {\n    const mode = (this.mode + 1) % 3\n    this.setPlayMode(mode) // setPlayMode 为映射的 mutation，用于修改 state mode\n  }\n  // ...\n}\n```\n\n由以上方法，可将 mode 的值的范围限制在 `0 ~ 2` 中。\n\n# 打乱数组\n\n```js\nfunction getRandomInt (min, max) { // 产生介于 min 和 max 之间的随机数，包含上下限\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nexport function shuffle (arr) { // 经典打乱数组算法\n  for (let i = 0; i < arr.length; i++) {\n    let j = getRandomInt(0, i)\n    let t = arr[i]\n    arr[i] = arr[j]\n    arr[j] = t\n  }\n  return arr\n}\n```\n\n# 得到元素在视口中的坐标\n\n[Element.getBoundingClientRect()][getBoundingClientRect] 方法返回`元素A`的大小及其相对于视口的位置。\n\n得到的[对象][client-rect]为：\n\n```js\nDOMRect {x: 67.53125, y: 682, width: 240.2604217529297, height: 30, top: 682, …}\n    bottom:712 // 矩形盒子A的底部相对于视口圆点的 y 坐标\n    height:30 // 元素高度 = bottom - top\n    left:67.53125 // 矩形盒子A的左侧相对于视口圆点的 x 坐标\n    right:307.7916717529297 // 矩形盒子A的右侧相对于视口圆点的 x 坐标\n    top:682 // 矩形盒子A的顶部相对于视口圆点的 y 坐标\n    width:240.2604217529297  // 元素宽度 = right - left\n    x:67.53125\n    y:682\n```\n\n\n[getBoundingClientRect]:https://developer.mozilla.org/zh-CN/docs/Web/API/Element/getBoundingClientRect\n\n[client-rect]:https://developer.mozilla.org/zh-CN/docs/Mozilla/Tech/XPCOM/Reference/Interface/nsIDOMClientRect\n\n# music-list 中的随机播放按钮\n\n始于 randomPlaySong ==> actions 中 randomPlay (==> actions 中 selectedPlay 对应修改 ==> common/js/util 中 shuffle 函数修改 )\n\n```js\nfunction getRandomInt (min, max) { // 产生介于 min 和 max 之间的随机数，包含上下限\n  return Math.floor(Math.random() * (max - min + 1) + min)\n}\n\nexport function shuffle (arr) { // 经典打乱数组算法\n  let _arr = [...arr] // 不能对原数组造成影响\n\n  for (let i = 0; i < _arr.length; i++) {\n    let j = getRandomInt(0, i)\n    let t = _arr[i]\n    _arr[i] = _arr[j]\n    _arr[j] = t\n  }\n  return _arr\n}\n```\n\nshuffle 函数中的**关键点**是，**不能**对传入的参数数组造成影响，否则在 selectedPlay 中的`index = findIndex(randomList, list[index])` 将导致无法找到正确的当前播放歌曲的索引\n\n```js\nexport const selectedPlay = ({ commit, state }, { list, index }) => {\n  commit(types.SET_SEQUENCE_LIST, list)\n\n  if (state.mode === playMode.random) {\n    let randomList = shuffle(list) // 打乱数组\n    commit(types.SET_PLAYLIST, randomList) // 设置打乱后的歌单为当前歌单\n    index = findIndex(randomList, list[index]) // 找到所选歌曲在打乱数组中的索引\n  } else {\n    commit(types.SET_PLAYLIST, list)\n  }\n\n  commit(types.SET_CURRENT_INDEX, index)\n  commit(types.SET_FULL_SCREEN, true) // 默认点击歌曲后全屏播放\n  commit(types.SET_PLAYING_STATE, true)\n}\n```\n（注：当前播放歌曲是依据 playList 计算而来，sequenceList 是用于展示（交互）的列表，详见 [vuex store][currentSong]）\n\n***关键点：***\n\na. 在 selectedPlay 中，区分`随机播放`和`其他模式播放`，在当前模式为`随机播放`时，找到传入索引在打乱后的歌单中的索引，并设置新的索引。\n\nb. `index = findIndex(randomList, list[index])`一定要保证 `list[index]` 的 `list` **是之前的未打乱列表**，这样才能找到用户在点击时所选的正确歌曲（项），这样在之后的设置新索引时才能保证找到之前用户的点击项。\n\n[currentSong]:https://github.com/lbwa/vue-sonar/blob/master/src/store/getters.js\n\n# 空间不够的横向排列\n\n在盒模型中，当两个子元素（`display：inline-block`）的宽度都为视口宽度时，可在父元素设置 `white-space: nowrap`，那么两个子元素本是上下排列的将转为横向左右排列。注意：这是一个**强制**不换行行为。\n\n这里父元素设置 [white-space][white-space] 的好处是，子元素不用另外设置 `transform` 等初始位移属性。\n\n[示例配置][example-nowrap]\n\n[white-space]:https://developer.mozilla.org/zh-CN/docs/Web/CSS/white-space\n\n[example-nowrap]:https://github.com/lbwa/vue-sonar/blob/master/src/components/app-player/app-player.vue#L603-L609\n\n# v-if 与 v-for 同时使用\n\n一般情况下，v-if 最佳实践是在 v-for 的外层容器来控制 v-for 的渲染与否。[参考][refer]\n\n[refer]:https://cn.vuejs.org/v2/guide/list.html#v-for-with-v-if\n\n# 多个组件使用同一逻辑\n\n在多个组件使用同一逻辑的情况下，使用 mixin [混入][vue-mixin]来一次写入所有相同逻辑。\n\n注：mixin 中的 mapMutations 已定义的函数不能在组件中再次定义，否则报错：no setter\n\n[vue-mixin]:https://cn.vuejs.org/v2/guide/mixins.html\n\n# 块级元素开始的空白文本将被忽略\n\n块级元素开始的空白文本将会被忽略，并且，块级元素后面的空白文本结点将不会参与渲染，要注意的是注释节点也是正常的页面节点，只是它不参与渲染。[参考][kjyskb]\n\n[kjyskb]:https://juejin.im/post/599ececb5188252423583c27#heading-18\n\n# 组件 watcher 的另一种写法\n\n```js\ncreated () {\n  this.$watch('query', debounce(newQuery => {\n    this.$emit('queryChange', newQuery)\n  }, 200))\n}\n```\n以上示例与写为 vue 选项的写法作用相同。\n\n# 对子组件的一种传值方法，当该值不需要监听时\n\n```js\n// child component\nmethods: {\n  setQuery (query) {\n    this.query = query\n  }\n}\n\n// parent component\n\nmethods: {\n  selectKey (item) {\n    this.$ref.child.setQuery(item)\n  }\n}\n```\n\n调用子组件方法传值的优势在于:\n\n1. 不用设置不必要的 props 和 watch\n2. 代码量更少\n\n适用于不需要监听的数据传递，注重传递这一行为\n\n这里也牵涉到一个子组件是基础组件时，不应在子组件中出现业务逻辑\n\n## vuex store 中慎用 splice() 等会修改原对象的方法\n\n```js\nexport const insertSong = ({ commit, state }, song) => {\n  /**\n   * 为了在之后使用 Array.prototype.splice() 方法，这里使用拓展运算符浅复制数组\n   * 原因：\n   * 1. 因为在 JavaScript 中操作对象的实质是操作对象指针，那么在不复制数组的情况下使\n   * 用数组 splice() 方法将会修改原数组。\n   * 2. 第一点的这个行为与在 vuex 中必须通过mutation 来修改 state 的原则相悖。继而报\n   * 错 Do not mutate vuex store state outside mutation handlers。\n   */\n\n  let playlist = [...state.playlist]\n  let sequenceList = [...state.sequenceList]\n  let currentIndex = state.currentIndex // 当前在 playlist 中的索引\n\n  // 记录当前歌曲\n  let currentSong = playlist[currentIndex]\n  // 判断当前歌曲是否已存在，若存在则返回索引\n  let fqIndex = findIndex(playlist, song)\n  // 因为是插入歌曲，所以索引 +1\n  currentIndex++\n  // 插入目标歌曲到当前索引位置\n  playlist.splice(currentIndex, 0, song)\n  // 查找结果是存在目标歌曲\n  if (fqIndex > -1) {\n    if (currentIndex > fqIndex) {\n      // 若当前插入索引大于列表中的索引，即在原索引之后\n      playlist.splice(fqIndex, 1)\n      currentIndex-- // 因为原单项已被删除，所以 -1\n    } else {\n      // 若当前插入索引不大于列表中的索引，即在原索引之前\n      playlist.splice(fqIndex + 1, 1)\n    }\n  }\n\n  let sequenceCurrentIndex = findIndex(sequenceList, currentSong) + 1\n\n  let fsIndex = findIndex(sequenceList, song)\n\n  sequenceList.splice(sequenceCurrentIndex, 0, song)\n\n  if (fsIndex > -1) {\n    if (sequenceCurrentIndex > fsIndex) {\n      sequenceList.splice(fsIndex, 1)\n    } else {\n      sequenceList.splice(fsIndex + 1, 1)\n    }\n  }\n\n  commit(types.SET_PLAYLIST, playlist)\n  commit(types.SET_SEQUENCE_LIST, sequenceList)\n  commit(types.SET_CURRENT_INDEX, currentIndex)\n  commit(types.SET_FULL_SCREEN, true)\n  commit(types.SET_PLAYING_STATE, true)\n}\n```\n\n浅复制数组的几种方法： \n\n1. 拓展运算符\n1. concat()\n1. slice()\n1. for...of 遍历数组\n\n# 函数防抖\n\n意为在某段持续时间内，不断地触发事件，但**只执行**最后一次回调函数的调用。\n\n实现：\n\n```js\n/**\n * @param  {Function} fn     要实现函数防抖的原函数\n * @param  {Number}   delay  延迟时间\n * @return {Function}        添加防抖功能的包装函数\n */\nfunction debounce (fn, delay = 200) { // 延迟默认值 200ms\n  let _timer = null // 匿名函数保持了对 _timer 变量的引用\n  return function (...args) { // rest 参数，保存传入参数，用于向 fn 传递参数\n    if (_timer) {\n      clearTimeout(_timer)\n      _timer = null\n    }\n    _timer = setTimeout(() => { // 这里的箭头函数中调用的 this 是外部匿名函数的 this\n      fn.apply(this, args) // 指定 this 和参数，若不使用 apply 指定，那么 this 将指向 window\n    }, delay)\n  }\n}\n```\n***注***：一个**易错点**就是 setTimeout 中为**箭头函数**时，因为箭头函数自身是没有 this 对象的，它内部的 this 对象是外部的 this 对象，那么此时可**直接调用**匿名包装函数的 this（这也是箭头函数的一个典型应用）。但若 setTimout 中是**非箭头函数**时，必须先在**外部引用**匿名函数的 this，即 `_that = this`，然后再用 `apply()` 方法指定调用 fn 时的 this 对象。\n\n以上示例中，`debounce 函数`起**修饰作用**，用于定义一个闭包变量存储定时器和传入延迟载荷，返回的匿名函数也是 `fn 函数`的一个**修饰**，用于判断是否执行函数。其中 `...args` 为 ES6 `rest 参数`，它定义了在调用匿名函数时，由传入的参数组成的**真**数组（对于 arguments 伪数组而言）。\n\n其中在 `setTimeout` 任务分发器中，是一个**异步调用**，那么必须指定调用 fn 的 this 和调用 fn 的包装匿名函数的传入参数。这是为了保证在使用防抖函数后调用 fn 与在没有使用防抖函数时调用 fn 的 this 对象和 arguments 对象**一致**。若不指定那么执行fn 时的 this 将指向 window，并且调用 fn 时无法正确传入 arguments 参数对象。\n\n```js\n// Vue.js 中使用函数防抖\n\ncreated () {\n  // watch 中真正的回调函数是 debounce() 返回的匿名函数\n  this.$watch('query', debounce (newQuery => {\n    this.$emit('queryChange', newQuery)\n  }, 200))\n}\n\n```\n在以上示例中，`debounce()` 表示了函数被调用，那么真正的回调函数是 `debounce()` 返回的匿名包装函数。因为 fn 的 this 与匿名包装函数的 this 是保持一致（使用 apply 指定的）的，那么 fn 的 this 此时是指向 Vue 实例组件的，`rest 参数`为由 `newValue` 和 `oldValue` 组成的数组。\n\n[示例配置][debounce]，[示例使用][debounce1]\n\n[参考][debounce2]\n\n[debounce]:https://github.com/lbwa/vue-sonar/blob/master/src/common/js/util.js#L16-L26\n\n[debounce1]:https://github.com/lbwa/vue-sonar/blob/master/src/base/base-search-box.vue#L34-L38\n\n[debounce2]:https://github.com/sakila1012/blog/issues/17\n\n# vuex 与 localStorage 的区别\n\n> Q:既然 localStorage 和 sessionStorage 能做到数据维护,为什么还要引入vuex!这个问题问得好,Vuex的目的用来维护同级组件间的数据通讯,拥有一个共同的状态树;\n\n仅仅活在SPA的里面的伪多页(路由)内, 这种东东明明然 localStorage 和sessionStorage也可以做到,还能做到跨页面数据维护..还不会被浏览器刷新干掉...\n为什么还要引入 vuex, 我个人觉得原因只有这么一个,\"可维护性\"和\"易用性\"及\n怎么理解呢?\n\n可维护性: 因为是单向数据流,所有状态是有迹可循的...数据的传递也可以及时分发响应\n易用性: 它使得我们组件间的通讯变得更强大,而不用借助中间件这类来实现不同组件间的通讯\n\n而且代码量不多,若是你要用 ls 或者 ss,你必须手动去跟踪维护你的状态表...虽说可行,但是代码量会多很多,而且可读性很差...\n是不是每个项目都需要用到vuex?答案是否定的,小型项目上这个反而是累赘..这东西一般是用在中型项目+的,因为里面涉及需要维护的数据比较多,同级组件间的通讯比较频繁\n若是用到vuex的项目记得**结合** ss 或者 ls 来达到某些**状态持久化**!!!为什么看下面!\n\nQ:vuex的**用户信息**为什么还要存一遍在浏览器里(sessionStorage or localStorage)\n\n因为 vuex的 store 干不过刷新啊.保存在浏览器的缓存内,若用户刷新的话,值再取一遍呗\n\n[来源][localStorage-src]\n\n[localStorage-src]:https://juejin.im/post/59fa9257f265da43062a1b0e\n\n# 不同组件有不同功能\n\n不同组件有不同功能，对于在组件中发生不是自己组件的职能任务时，派发事件和载荷，让关心载荷的组件去完成任务。\n\n# 本地存储\n\n1. localforage 异步读取与写入\n\n适配 vue，由 Mozilla 开发\n\n弊端：无法在 vuex state 中设置读取（原因：异步机制）\n\n2.  store.js 同步读取与写入\n\n# 拓展小图标点击区域\n\n``` scss\n// 拓展小图标点击区域\n@mixin extend-click () {\n  position: relative;\n  &::before {\n    content: '.';\n    position: absolute;\n    top: -10px;\n    left: -10px;\n    right: -10px;\n    bottom: -10px;\n  }\n}\n```\n\n# 定制 CSS3 动画过程\n\n使用 CSS3 animation 和 @keyframe\n\nanimation 来定义 animation-timing-function，其中 animation-timing-function 可由 @keyframe 来定制动画过程\n\n## 比较 animation 和 transition\n\ntransition 关注 CSS property 的变化，即在 CSS 属性变化时控制动画\n\n```scss\n.test {\n  transition: opacity 1s;\n}\n```\n\nanimation 关注元素本身动画流程和控制\n\ntransition + transform ＝ 两个关键帧的 animation\n\n## 总结\n\n追求复杂动画效果使用 animation；优先使用 transition 来定义动画。\n\n# vue 事件修饰符\n\n.self\n\n``` html\n<!-- 只当在 event.target 是当前元素自身时触发处理函数 -->\n<!-- 即事件不是从内部元素触发的 -->\n<div v-on:click.self=\"doThat\">...</div>\n```\n\n# 提交 aciton 时需要携带多个载荷\n\nvuex 提价 action 只允许携带**一个**载荷，当有多个参数需要传递时，使用一个对象作为载荷，多个参数作为该对象的属性\n\n# 当提交一次 mutation / action 是触发多次提交的原因\n\n1. 事件可能冒泡到父容器，父容器的监听器同样触发了相同的 mutation / action\n\n这种意外触发很隐蔽。\n\n总结：当组件中有很多同一事件的监听器时，要注意他们之间的关系，看他们的事件触发是否会影响到其他监听器的意外触发\n\n2. watcher 的影响\n\n# transition-group 绑定 key 值\n\ntransition-group 绑定 key 值若是默认 `(item, index) of items` 中的 index ，那么动画始终出现在列表的最后一项，解决方案是自定义一个 key 值，如 item 的某个不会复现的属性值\n\n# 基础组件的整体定位\n\n基础组件的定位交由基础组件外层容器元素来执行，这样的好处是将基础组件与定位解耦，复用性更强\n\n# 编译打包优化\n\n## 优化源码\n\n### 路由懒加载(组件按需异步加载)\n\n原理：webpack 代码分割（适用于项目打包文件 app.xxxxx.js 过大的问题）\n\n# CDN 静态资源加载\n\nwebpack 中关于 public path [介绍][webpack-public-path]\n\n设置 assetPublicPath 地址，[参考一][assetPublicPath1],[参考二][assetPublicPath2]\n\n[webpack-public-path]:https://doc.webpack-china.org/guides/public-path/\n\n[assetPublicPath1]:https://github.com/lbwa/vue-sonar/blob/master/build/webpack.base.conf.js#L30-L32\n\n[assetPublicPath2]:https://github.com/lbwa/vue-sonar/blob/master/config/index.js#L53\n"},{"to":"180329-css-bfc","data":"\n## 块级格式化上下文定义与形成\n\n> 块级格式化上下文（block formatting context）在 CSS3 中被称为 [flow root][flow-root]。\n\n块级格式化上下文是指，当元素满足特定条件就会形成一个**单独**的盒模型渲染模式**区域**（[参考一：MDN][refer-1]，[参考二：W3C][refer-2]）。\n\n默认地，每个视口初始**只**创建一个 BFC（该 BFC 即根元素 BFC ，它也计算后代（不仅仅是子代）浮动元素高度）。除非元素设置特定样式创建新的 BFC 。\n\n特定条件是指：\n\n1. 根元素，即`<html>`。\n1. `position`值不为`staic`或`relative`（可理解为值为 `absolute` 或 `fixed`）\n1. `float`不为`none`（即不为默认值）\n1. `overflow`不为`visible`（即不为默认值）\n1. `display`为`table-cell`、`table-caption`、`inline-block`、`flex`、`inline-flex`之一\n\n（注：`position：sticky` 粘性定位是相对定位（`relative`）和固定定位（`fixed`）的混合。元素在跨越特定阈值前为相对定位，之后为固定定位。）\n\n当一个元素满足以上条件之一，那么该元素将在普通流（[normal flow][normal-flow]，`w3c`是**没有**文档流一说的）创建一个新的 BFC。创建了块级格式化上下文的元素中的所有内容都会被包含到该 BFC 中（清除浮动的原理）。这里注意 `display: table` 是不会创建新的 BFC 的，该特性只会创建一个匿名框（[参考][anonymous-boxes]），而是匿名框中的 `display: table-cell` 创建新的 BFC。\n\n## 块级格式化上下文的特点\n\n1. BFC 是一个独立的CSS渲染区域，其内部与外部互不影响\n1. BFC 中元素是按照垂直方向从上至下排列\n1. BFC 中子元素相对于 BFC 元素是左对齐的（从右向左布局，则右对齐）\n1. 不同的块级格式化上下文的 margin 不会叠加，即外边距叠加只发生在**同一 BFC** 内。（应用：防止外边距叠加）\n1. 块级格式化上下文不会与浮动元素重叠。（常见应用：当二者为兄弟元素时，创建 BFC 可阻止元素被浮动元素覆盖）\n1. 块级格式化上下文中可以包含浮动元素。但 BFC 中是**不包含**绝对定位 等 BFC 的。（常见应用：父元素添加 .clearfix 类来定义一个 BFC 使该元素计算 BFC 高度时**包含**其子浮动元素，而不是因为子元素因浮动而脱离普通流，父元素进而“高度坍塌”）\n\n（注：BFC 阻止浮动元素重叠，此时 BFC 与 浮动元素一般是兄弟元素；BFC 清除浮动，此时 BFC 与 浮动元素一般是父子元素）\n\n<strong style=\"color: red\">重要</strong>：经试验，在同为脱离普通流的绝对定位和固定定位形成的 BFC 是<strong style=\"color: red\">不会</strong>被外层 BFC 包含的。在脱离普通流形成的 BFC 中（左或右浮动，绝对和固定定位）<strong style=\"color: red\">只有</strong>浮动元素 BFC 会被外层 BFC 在计算高度时，包含在内。\n\n绝对定位形成的 BFC 与 根元素 BFC：\n![pa](https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/css-bfc/pa.gif)\n\n固定定位形成的 BFC 与 根元素 BFC：\n![pa](https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/css-bfc/pf.gif)\n\n浮动形成的 BFC 与 根元素 BFC：\n\n![pa](https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/css-bfc/fl.gif)\n\n在以上特点中有一个问题是，<strong style=\"color: red\">为什么 BFC 可以包含浮动元素，并在计算时包含浮动元素的高度？</strong>\n\n原因：参考[W3C 计算元素高度][height-for-BFC]，有以下：\n\n> In addition, if the element has any floating descendants whose bottom margin edge is below the element's bottom content edge, then the height is increased to include those edges. Only floats that participate in this block formatting context are taken into account, e.g., floats inside absolutely positioned descendants or other floats are not.\n\n其中特别的有，` Only floats that participate in this block formatting context are taken into account`，简而言之就是只有 BFC 中的浮动元素才会被 BFC 计算高度。\n\n即对于该 BFC 中的普通流，我们可以总结出在创建一个新的 BFC 时，会将其**所有**的子元素（对于已脱离普通流的元素，仅包含脱离 BFC 的浮动元素）都会被包含在该 BFC （限定在特定的一个 CSS 渲染区域内）中。这也是<strong style=\"color: red\">清除浮动的原理</strong>。\n\n结论：对于第三点应用，因为有独立的块级格式化上下文**可以包裹**浮动元素（计算浮动元素高度），所以达到一种将浮动元素“拉回”普通流计算高度的效果。\n\n补充拓展：对于块级非替换元素的高度计算规则（[参考三][ignored-element]）：\n\n> Only children in the normal flow are taken into account (i.e., floating boxes and absolutely positioned boxes are ignored, and relatively positioned boxes are considered without their offset). Note that the child box may be an anonymous block box.\n\n只有在普通流中的子元素才包含在元素计算高度中。\n\n### BFC 中元素布局的特点（[W3C BFC][refer-2]）：\n\n> In a block formatting context, each box's left outer edge touches the left edge of the containing block (for right-to-left formatting, right edges touch). This is true even in the presence of floats (although a box's line boxes may shrink due to the floats), unless the box establishes a new block formatting context (in which case the box itself may become narrower due to the floats).\n\n在一个 BFC 中，每个子盒模型的左外边缘都是挨着包含块的左边缘（对于从右到左的布局，是子盒模型的右外边缘挨着包含块的右边缘）。这在已经存在的浮动元素**中**（注：浮动元素也是一个 BFC ）也是这样（尽管一个盒模型的**行框**（注：文本行）可能因为浮动而收缩）,除非在盒模型中建立了一个新的 BFC （这种情况下该盒模型（的行框）因为其中的新建了浮动而可能变得更窄）。\n\n以上，简而言之为，在 BFC 中除非新建一个新的 BFC 浮动元素，否则在同一 BFC 中的每一个盒模型的左外边缘**都是左对齐**于包含块的**左边缘**。（若排列格式为从右到左，那么是右对齐）\n\n总结布局特点：\n\n1. BFC 中元素是按照垂直方向从上至下排列\n1. BFC 中子元素相对于 BFC 元素是左对齐的（从右向左布局，则右对齐）\n\n### 总结\n\n综上，我们可以将 BFC 理解为元素在满足一定条件后在普通流中形成了一个**单独的盒子**，这个盒子里面的布局和外面的布局是**相互独立，互不影响**的。\n\n\n## 区分清除浮动和闭合浮动\n\n浮动元素的特点：\n\n1. 不属于普通流（normal flow）\n1. 可左右移动\n1. 移动至触碰另一个浮动框的边缘或包含块的边缘\n1. 不影响兄弟块级元素的布局，影响兄弟行内元素的文本的排列\n1. 原文档中的普通流就表现得像浮动元素不存在一样，那么当浮动元素高度超过包含块时，包含块高度不会自动适应变化（“高度坍塌”）\n\n最后一点，也是闭合浮动的意义所在，闭合浮动是为了防止高度坍塌，使浮动元素的包含框表现出正常的高度。\n\n清除浮动仅仅是指 `clear: both`。\n\n闭合浮动是指创建一个新的 BFC （即原来浮动元素浮动之前的包含块）包含清除浮动的元素，使其浮动元素被新的 BFC 计算高度，恢复 BFC 的正常高度计算。常用方法是在浮动元素的父元素添加一个`.clearfix`类来闭合浮动。\n\n闭合浮动的类名 `.clearfix ` 的代码如下：\n\n```scss\n.clearfix {\n  display: inline-block;\n  &:after {\n    display: block;\n    content: '.'; // 点的兼容性优于空格\n    height: 0;\n    line-height: 0;\n    clear: both;\n    visibility: hidden;\n  }\n}\n```\n\n原理：[::after][after]伪元素表示创建被选择元素的排在最后的一个子元素。以上代码创建了一个块级元素区域（防止影响包含块中的普通流布局）表示两边清除浮动。因为清除了浮动，那么伪元素将排在浮动元素之下。这样达到一种将浮动元素的位置**空出来**的效果。对于外层的包含块`.clearfix`的普通流虽然**只**包含了`::after`，但因有`::after`空出位置，`.clearfix`这时也就间接计算了内部浮动子元素的高度，也就相当于闭合了内部的浮动。\n\n总结：闭合浮动是效果，效果是浮动元素重新被计算高度（[W3C 计算 BFC 中元素高度][height-for-BFC]）。清除浮动仅仅是清除了浮动，决定其他非浮动元素的布局。清除浮动仅仅只是闭合浮动的一种方法中的一个步骤。\n\n[refer-1]:https://developer.mozilla.org/en-US/docs/Web/Guide/CSS/Block_formatting_context\n\n[refer-2]:https://www.w3.org/TR/CSS2/visuren.html#block-formatting\n\n[flow-root]:https://www.w3.org/TR/css3-box/#block-level0\n\n[normal-flow]:https://www.w3.org/TR/CSS2/visuren.html#normal-flow\n\n[anonymous-boxes]:https://www.w3.org/TR/CSS21/tables.html#anonymous-boxes\n\n[height-for-BFC]:https://www.w3.org/TR/CSS2/visudet.html#root-height\n\n[ignored-element]:https://www.w3.org/TR/CSS2/visudet.html#normal-block\n\n[after]:https://developer.mozilla.org/zh-CN/docs/Web/CSS/::after\n"},{"to":"180328-summary-of-eleme-candy","data":"\n## 真正的 1 像素边框\n\n原理： 伪类 + 缩放（根据不同像素比）\n\n利用一个 class 加入 HTML 文档\n\n```scss\n@mixin bottom-1px($color) {\n  position: relative;\n  &:after {\n    display: block;\n    position: absolute;\n    left: 0;\n    bottom: 0;\n    width: 100%;\n    border-bottom: 1px solid $color;\n    content: ''\n  }\n};\n\n// 引用 mixin 时，同时向该 class 添加以下 scale 类名来缩放伪类\n// media 查询前缀，需要手动添加，postcss 的 autoprefixer 不会补全 media 查询条件\n\n@media (min-device-pixel-ratio: 1.5), (-webkit-min-device-pixel-ratio: 1.5) {\n  .scale {\n    &:after {\n      transform: scaleY(0.7);  // 1.5 * 0.7 约等于 1 像素\n    }\n  }\n};\n\n@media (min-device-pixel-ratio: 2), (-webkit-min-device-pixel-ratio: 2) {\n  .scale {\n    &:after {\n      transform: scaleY(0.5);\n    }\n  }\n};\n```\n\n总结：@include bottom-1px() 要与 scale **配合使用**\n\n## 组件生命周期中的 ajax 请求\n\napp.vue 中 created 函数是异步请求，那么初始化时第一次传递给 sellerData  的就是 sellerDetail 的初始值，即 {} ，在 created 异步请求返回后，回调函数内 sellerDetail 变化，那么重新传递 sellerData 值，此时传递正常数据值。由此，在示例中，初始化时会 props 值会变化两次\n\nJSON 中的地址在使用时要 v-bind 绑定，才能调用JSON 中的地址，否则src特性值为变量名字符串\n\n```html\n<img :src=\"item.url\"> <!-- v-bind 绑定 src 属性 -->\n```\n\n## 消除标签之间的空白\n\n设置容器元素的 font-size（该属性可被后代元素继承） 设为 0 ，再将容器内的后代元素设置正常的font-size，那么各个元素之间的空白将消失\n见 preview.gif\n\n![pa](https://raw.githubusercontent.com/lbwa/lbwa.github.io/vue/source/images/post/note-for-food-app/preview.gif)\n\n\n若后代元素不设置 font-size ，那么后代元素的字将消失，因为在后代元素不设置 font-size 的情况下，后代元素将继承祖先元素的 font-size \n\n因此，容器元素和的 font-size 要与后代元素的 font-size 配合使用\n\n## 对 vertical-align 和 line-height 探究\n\nCSS 的属性 [vertical-align][vertical-align] 用来指定行内元素（inline）或表格单元格（table-cell）元素的垂直对齐方式。不能用于块级元素。\n\n```scss\nvertical-align: top; // 把元素顶端与整行的顶端对齐，该属性设置的是元素在该行中的行为\n```\n\n当 webfont 与文字没有对齐时，设 webfont 为行内块元素，且设置 vertical-align: top（源自 BaseRatingsSelector）\n\n[line-height][line-height] 是可继承属性\n\n图片默认在盒模型中以顶端基线为准对齐，文字默认以底端基线对齐 => vertical-align: top 或 bottom;将他们对齐\n\n注： 内含文字和图片的容器元素不要设置行高！\n\n[vertical-align]:https://developer.mozilla.org/zh-CN/docs/Web/CSS/vertical-align\n\n[line-height]:https://developer.mozilla.org/zh-CN/docs/Web/CSS/line-height\n\n## 文字超出指定宽度省略为 ...\n\n示例代码：\n```scss\nwhite-space: nowrap;\ntext-overflow: ellipsis;\noverflow: hidden;\n```\n\n### 文字省略和 font-size: 0 的效果兼容\n\n当使用单行超出部分省略时，font-size：0 将导致**省略号消失**，那么解决办法是不使用 font-size: 0 而是将两个span 写在同一行，而不是分开两行写，这样就是不使用 font-size: 0 也能去掉两个标签之间的空白的方法。\n\n盒模型内容 content 区域不包括 [before / after][Pseudo-elements]（创建一个被选择元素的第一个或最后一个子元素） 伪元素区域,他们的尺寸是单独设置。即使设置了 box-sizing：border-box也不包括。\n\n[Pseudo-elements]:https://developer.mozilla.org/en-US/docs/Web/CSS/Pseudo-elements\n\n## css sticky footer 实现\n\n法一：不使用绝对定位，添加一个容器撑开 footer\n\n```scss\n.seller-detail {\n  position: fixed;\n  z-index: 100;\n  top: 0;\n  left: 0;\n  width: 100%;  // fixed 布局的包含块是视口，故计算结果是视口宽度\n  height: 100%;  // 原理同上，故计算结果是视口高度\n  .detail-wrapper {\n    // 推开 footer 的容器，css sticky footer 的关键，高度不能写死，否则其子元素，即真\n    // 正的内容区域可能突破父元素\n    min-height: 100%;\n    width: 100%;\n    // 真正的内容区域\n    .seller-detail-main {\n      // 必须是 padding 给 footer 留出空间，否则可能与 footer 区域重叠\n      padding-bottom: 64px;\n    }\n  }\n  .close-detail {\n    height: 32px;\n    width: 32px;\n    margin: -64px auto 0 auto;\n    clear: both;\n    font-size: 32px;\n  }\n}\n```\n\n主要原理：内容外容器，即包装层，.detail-wrapper 用于撑满整个屏幕，即将 footer 撑开，使 footer 保持视口在底部。容器内内容块 .seller-detail-main 要有一个 padding-bottom 留给 footer ，用于在内容区域超过视区（滚动出现）之后 footer 不会遮挡内容区域\n\n法二： 使用绝对定位，使用父元素撑开 footer\n\n```html\n<div class=\"wrapper\">\n    <div class=\"content\"></div><!-- 页面主体内容区域 -->\n    <div class=\"footer\"></div><!-- 需要做到 Sticky Footer 效果的页脚 -->\n</div>\n```\n``` scss\nhtml, body {\n    height: 100%;\n}\n.wrapper {\n  position: relative;\n  min-height: 100%;  // 关键，使其可以随内容区变化，撑开 footer\n  padding-bottom: 50px;  // 预留 footer 高度，防止重叠\n  box-sizing: border-box;\n  .footer {\n    position: absolute;\n    bottom: 0; // 当绝对定位的参照元素高度变化时，将跟随移动，达到 sticky footer 效果\n    height: 50px;\n  }\n}\n```\n\n主要原理：绝对定位 .footer 使其脱离普通流，定位于 .wrapper，那么由 .wrapper 担任撑开 footer 的角色。\n在内容区小于 wrapper 时，footer 将保持在视口底部，当 .content 区大于 wrapper 时，wrapper 将被 .content 撑开，wrapper 被撑开，此时，footer 也跟着被定位（因为 `bottom: 0` 的存在）到 .wrapper 底部，达到跟随的目的。\n\n两个方法的本质**区别**是：法一是用一个容器\"**抵开**\" footer，法二是使用绝对定位的 `bottom: 0` **跟随**被撑开的绝对定位的参照元素（此参照元素的高度**一定不能**写死，否则高度不能变化，那么 sticky footer 也就失效了）。\n\n其他方法：flexbox 纵向布局、calc(100vh - footer的高度)\n\n## vue 组件引用父元素的循环单项\n\n示例代码： AppHeader.vue 中列表循环商家优惠信息\n\n```html\n<ul v-if=\"sellerData.supports\" class=\"seller-detail-supports\">\n  <li\n    class=\"supports-item\"\n    v-for=\"(item, index) of sellerData.supports\"\n    :key=\"index\"\n  >\n    <span :class=\"['icon', classMap[sellerData.supports[index].type]]\"></span>\n    <span class=\"text\">{{sellerData.supports[index].description}}</span>\n  </li>\n</ul>\n```\n\n示例中，体现了父元素中显示声明的循环单项（index）可在其后代元素中使用\n\n\n## 在初始化组件后，向 vue 中的对象添加属性的方法\n\n参考：[深入 vue 响应式原理][vue-reactive]\n\nvue 本身不能够响应（监听）已有对象中添加或删除属性的行为，要**添加响应式属性**的方法有：\n\n1. 使用 `Vue.set()` (别名是 `vm.$set`，其中 vm 是 vue 实例)方法添加/删除属性。\n2. 使用 `Object.assign()` 来创建一个新的对象，使新对象包含原对象的属性和新属性，注意，不能使用 `Object.assign()` 方法直接将新属性添加至原对象，否则是非响应式属性，**不会**触发数据更新。\n\n[vue-reactive]:https://cn.vuejs.org/v2/guide/reactivity.html#检测变化的注意事项\n\n## vue 中 computed 最佳实践\n\n（参考：[vue doc][vue-doc]）\n\n结论：computed 的最佳实践：在计算属性中**不应该**有修改 data 对象的（赋值）语句出现\n\n原因：因为 computed 属性设定的角色定位是**仅仅**是一个 getter ，不包括setter，为不偏离 getter 的角色定位，故将对 this.scroll 的初始化（在 computed 中赋值：this.scroll = new BScroll(...)）提炼出为一个方法，通过调用这个方法来初始化 this.scroll 且不叛离 computed 属性的 getter 角色定位。否则，报错 Unexpected side effect in “某计算属性名” computed property\n\n[vue-doc]:https://cn.vuejs.org/v2/guide/computed.html#计算属性的-setter\n\n## 制作弹出的详情页\n\n购物车详情页（从 tab 组件中弹出）构建步骤：\n\n基本结构：\n```html\n<transition name=\"fold\">\n  <div class=\"cart-list scale\" v-show=\"showList\">\n\n    <div class=\"list-header\">\n      <h1 class=\"title\">购物车</h1>\n      <span class=\"clear-cart\" @click=\"cleaner\">清空</span>\n    </div>\n    <!-- ref 下的第一个子元素即滚动的目标元素 -->\n    <div class=\"list-content\" ref=\"scroll\">\n      <ul>\n        <li\n        class=\"item\"\n        v-for=\"(item, index) of goodsInCart\"\n        :key=\"index\">\n          <div class=\"name\">{{ item.name }}</div>\n          <div class=\"price\">\n            <span>￥{{ item.price * item.quantity }}</span>\n          </div>\n\n          <div class=\"cart-wrapper\">\n            <BaseCartBtn :singleGood=\"item\"/>\n          </div>\n\n        </li>\n      </ul>\n    </div>\n\n  </div>\n</transition>\n```\n\n### 确定详情页展开的目标位置\n```scss\n.cart-list {\n  // 整个购物车相对于屏幕视口 fixed 定位，详情页是相对于购物车绝对定位\n  position: absolute;\n  left: 0;\n  top: 0;\n  z-index: -1;\n  width: 100%;  //宽度撑满屏幕，计算视口宽度得出\n  // -100% 相对于当前高度做 -100% 偏移，组件的常态位置\n  transform: translate3d(0, -100%, 0);\n}\n```\n\n这一步的重点是：定位 和 相对于自身做 -100% 的偏移， -100% 的偏移可自适应向上展开合适的高度\n\n### 确定详情页内的基本布局样式，添加展开动画\n\n重要样式：\n\n```scss \n&.fold-enter-active, &.fold-leave-active {\n  transition: all .5s;  // 定义动画过度过程中的样式\n}\n&.fold-enter, &.fold-leave-to {\n  transform: translate3d(0, 0, 0); // 定义弹出动画起始位置和折叠时的动画的目标位置\n}\n```\n\n此处是定义详情页自购物车中 0 位置向之前定义的 -100% 位置过渡，即**目标状态是常态**！！此时设常态为 `display: none` 即可，这样就达到了详情页自 tab 组件中弹出过渡到完整状态。\n\n### 总结\n\n前提：[transition][transition] 封装组件，一般与 (1)条件渲染(使用 v-if)； (2)条件展示(使用 v-show)； (3)动态组件组件； (4)根节点配合使用。\n\n本质：在动画过程中不断插入类名来体现动画效果，是由这些插入的类名来控制动画效果的。\n\n由购物车详情页的构建，我们可以拓展总结出，vue 的动画原理（`定义组件的进入和离开状态的动画`）是向目标元素插入特定类，`将由 vue 设定类的状态过渡到常态或当缓存（或销毁）发生时由常态过渡到一个自定义目标状态`。\n\n进入（创建）时，`自定义名-enter`（定义起始状态）、`自定义名-enter-to`（定义进入态的目标状态）和`自定义名-enter-active`（定义进入时中间过渡状态）此类表示进入态过渡至常态。\n\n离开（被缓存或销毁）时，`自定义名-leave`（定义离开时的起始状态）、`自定义名-leave-to`（定义离开态的目标状态）和`自定义名-leava-active`（定义离开时中间过渡状态）由常态过渡到类所定义的一个目标态。\n\n注：\n\n1. 常态是固定不变的，通过修改进入态或目标态，即可做到过渡动画。\n1. `自定义名-enter-to` 和 `自定义名-leave-to` 与常态的区别是，他们会**在动画结束时被移除**。\n1. transition 使用的前提条件定义了动画结束之后，组件的真正\"归处\"(如被隐藏、创建、或销毁等)。\n\n[transition]:https://cn.vuejs.org/v2/guide/transitions.html\n\n## better scroll 原理\n\n1. 初始化 better-scroll 传入需要滚动的元素的**父元素**，better-scroll将滚动该父元素的第一个子元素\n1. 如有必要，将该父元素定高（即**父元素不能由子元素撑开**，目的是让子元素有可能超出父元素宽度，否则子元素无法滚动），且设置超出部分隐藏，即 overflow: hidden 。\n1. 当检测到父元素的第一个子元素高度高于该父元素高度时，better-scroll 将设置 transform: translate3d(x, y, z) 移动滚动区域，达到滚动效果。\n\n注： 在 vue 中使用 better-scroll 必须等到 DOM 更新之后（vue 有自己的任务队列，是异步更新 DOM，在 this.$nextTick 中初始化 better-scroll）才能挂载 better-scroll，这样 better-scroll 才能正确计算父元素高度。当 DOM 结构改变时，使用 scroll.refresh() 重新计算父元素高度\n\n### 使用 better-scroll 添加滚动\n\n添加滚动的结构是 vue 中 ref 的**第一个子元素**区域\n\n重要样式有：\n\n```scss\n.list-content {\n  max-height: 217px;   // 设置最大高度\n  overflow: hidden;  // 达到最大高度超出部分隐藏，滚动交由 better-scroll 组件\n  // ...\n}\n```\n\nJavaScript 代码：\n\n```js\n// vue methods 选项内\ninitScroll (show) {\n  if (show) {\n    // vue 有自己的任务队列，为异步更新DOM，只有更新了 DOM 才能初始化 better-scroll\n    this.$nextTick(() => {\n      if (!this.scroll) {\n        // this.$refs.scroll的第一个子元素即为滚动目标元素\n        this.scroll = new BetterScroll(this.$refs.scroll, {\n          click: true  // 支持原生点击事件\n        })\n      } else {\n        this.scroll.refresh()\n      }\n    })\n  }\n},\n```\n\n## 父组件调用子组件的方法\n``` html\n<child ref=\"child\"> <!-- child 值不要用连字符 -->\n```\n``` javascript\nthis.$refs.child.show()  // 调用子组件 child 的 show 方法\n```\n\n## 布局时防止图像加载的闪烁\n\n问题：模块内有一张图，该图因为要自适应不同的屏幕，故**不能定高**，而且要留有空间给图像加载，以防止图像加载出来布局改变（常称为闪烁，因为没有加载出来前，盒模型没有内容无法撑起），如何布局？\n\n以下都是针对**块级元素**来说，行内元素不能设置 width 和 height\n\n思路：用盒模型 padding / margin **设置百分比值**代替内容区撑起高度，先占位\n\n解决方案：设定目标块的 padding-top 或者 padding-bottom 的值为 100%，该百分数是图像比例。\n\n原因：padding / margin 的百分比值计算结果是相对于包含块的 **width 值**。其中包含 padding 和 margin **所有部分**都是以包含块的内容区宽度为参照计算最后结果的。\n\n```scss\n.img-list-wrapper {\n  position: relative;\n  width: 100%;\n  // 占用图片高度，防止图像加载完成造成的闪烁，需要与父元素 相对定位 和子元素 的绝对定\n  // 位配合使用\n  padding-top: percentage(90 / 378);\n  overflow: hidden;\n  white-space: nowrap;\n  .img-list {\n    position: absolute;\n    top: 0;\n    left: 0;\n    // ...\n  }\n  // ...\n}\n```\n\n### 参考及拓展\n\n参考：(1)[w3c margin/padding][w3c-margin/padding](2)[css standard margin/padding][css-standard-margin/padding]\n\n拓展： 图片自适应 ———— 解决方案：margin / padding 百分数（按比例自适应）\n\n拓展：CSS3 新特性 [vh][css3-vh] 单位（视口高度的 1/100，vw 同理）也可达到相同的效果，但要考虑兼容性。\n\n[css-standard-margin/padding]:https://drafts.csswg.org/css-box/#property-index\n\n[w3c-margin/padding]:https://www.w3.org/TR/CSS21/box.html#pahdding-properties\n\n[css3-vh]:https://developer.mozilla.org/zh-CN/docs/Web/CSS/length\n\n## CSS 中 width 和 height 百分比属性值的计算结果\n\n（以占用普通流的元素的 width 为例）\n\n现象：当包含块的 width 设置为 100% 且有效时，那么包含块的子元素的宽度加上子元素的 margin 和 padding 值（如有）等于包含块的 width 计算后的值。\n\n原因：当 C 的包含块 A 设置 width: 100% 时， 100% 的计算是基于包含块 A 的**父元素 B 的 width**的（[w3c box model][box-model]）。当包含块的父元素 B 宽度为默认值（即 B 没有明确指定 width），即 auto 时，而 B 的宽度又是基于其父元素，那么直至根元素都是 auto 值的话，那这里可理解为**子元素 C 撑起了其祖先元素**。因此可以得到，此时包含块 A 的宽度 100% 的计算结果对象可由 A 的父元素 width 转化为 B 的后代元素所撑起的宽度（此宽度包含边距），即此时 B 的后代元素 C 的内容区 width + 边距 margin / padding 等于包含块 A 的 width: 100% 的计算值。\n\n现象：非内联元素的 width 默认值计算\n\n原因：内联元素无法设置 width 和 height。非内联元素的 width 默认值是 auto ，意思是，将元素本身宽度(即内容区宽度)加上元素本身的 margin / padding 之和等于父元素的 content width。\n\n###width: auto 与 width: 100% 的区别\n\n当元素 A 设置了 width 属性时，\n\n百分数的计算是基于元素的父元素 width 计算的，与元素 A 的自身边距无关，最后结果是 A **可能撑破**父元素。\n\nauto 即为默认值时，有等式：A 的 width + margin / padding === A 的父元素 width 是恒成立的，即此时的 A 是**不会**撑破 父元素的。\n\n拓展：根元素（`<html>`）的包含块是视口（viewport），那么根元素的包含块的 width 是一定固定存在的。即`<html>`的 width: 100% 即为包含块视口的宽度。\n\n拓展： 关于包含块（containing block）的概念，不能简单地理解成是父元素。如果是静态定位和相对定位（位于普通流中），包含块一般就是其父元素。但是对于绝对定位（position: absolute）的元素，包含块应该是离它最近的 position 为 absolute、relative、或者 fixed 的祖先元素。对固定定位（position: fixed）的元素，它的包含块是视口（viewport）。\n\n（以上元素的 height 同理，都是基于父元素的 height 来计算的）\n\n[box-model]:https://www.w3.org/TR/CSS21/visudet.html#propdef-width\n\n## 使用 global event bus\n\n当有多个组件有同一事件 global event bus 监听器时， 另外的组件不能通过 global event bus 传递事件，因为会触发所有的监听器。因为 global event bus 是**全局**的，他不受某一组件的控制\n\n## 常用构建组件的技巧\n\n构建组件： \n\n1. 有哪些数据需要维护（传递）\n1. 组件结构\n\n样式及激活与未激活状态，一般是同色不同透明度的切换。\n\n```scss\n.all-ratings, .positive-ratings {\n  margin-right: 8px;\n  &.active {  // 激活时添加 active 类\n    color: $color-empty;\n    background: rgba(0, 160, 220, 1);\n  }\n}\n```\n\n## 理解 BFC 和闭合浮动\n\n独立为一篇文章，链接如下：\n\n[理解 BFC 和闭合浮动][css-bfc]\n\n[css-bfc]:https://lbwa.github.io/blog/writings/180329-css-bfc/\n"},{"to":"180312-vue.js-reusability-and-composition","data":"\n# 混入\n\n## 基础\n\n混入可理解为在一个组件中调用另外一个包含组件选项的**对象**。可类比 Sass 中的 `@mixin` 混合宏、DOM 中的 `DocumentFragment` 类型。这里可以得到，混入是为了增强 Vue 中的选项复用性。\n\n在创建 Vue 实例时，使用`mixins`选项来引入混入对象。\n\n```js\nconst CustomMixin = {\n  created () {\n    this.hello()\n  },\n  methods: {\n    hello () {\n      console.log('App is running now !')\n    }\n  }\n}\n\nnew Vue({\n  el: '#app',\n  mixins: [CustomMixin],  // 使用 mixins 选项来引入混入对象\n})\n```\n\n## 选项合并\n\n1. 在混入时，各个选项的合并是**浅合并**（如，指向对象的指针就只会复制指针而不是复制对象，并没有开辟新的内存地址），在选项发生冲突时以组件数据优先。\n1. 同名钩子函数将混合为一个数组，因此**都**将被调用。另外，混入对象的钩子将在组件自身钩子**之前**调用。\n1. 值为对象的选项，例如 `methods`, `components` 和 `directives`，将被混合为**同一个**对象。两个对象键名冲突时，取组件对象的键值对。\n\n\n## 全局混入\n\n谨慎使用全局混入，因为一旦混入，将影响到**所有**之后创建的 Vue 实例。\n\n# 自定义指令\n\n使用 `Vue.directive()` 来创建全局自定义指令。在创建 Vue 实例时使用 `directive` 选项来创建局部自定义指令。\n\n格式如下：\n\n```js\n// 注册一个全局自定义指令 `v-focus`\nVue.directive('focus', {   // 调用时加前缀 V-\n  // 当被绑定的元素插入到 DOM 中时\n  inserted: function (el) {\n    // 聚焦元素\n    el.focus()\n  }\n})\n// 局部自定义指令\ndirectives: {\n  focus: {   // 调用时加前缀 V-\n    // 指令的定义\n    inserted: function (el) {\n      el.focus()\n    }\n  }\n}\n``` \n\n``` html\n<input v-focus>\n```\n\n# 渲染函数 & JSX\n\n## 基础\n\n渲染函数的作用是**渲染视图**，又称为`render 函数`。\n\n在 `vue-cli` 的 `webpack` 模板中的 `main.js` 中有以下声明：\n```js\nnew Vue({\n  el: '#app',\n  components: { App },  // 表示实例中有哪些组件可用\n  template: `<App/>`    // 表示要渲染哪些可用组件，这里形如 <App></App>\n})\n```\n以上代码中，\n\ncomponents 选项，包含 Vue 实例可用组件的哈希表。即 `components` 选项表示声明了实例中存在哪些组件。（参考[官方 issue][template-role]、[API:components选项][api-components]）\n\ntemplate 选项，表示选项的值`一个字符串模板`作为 Vue 实例的标识使用。模板将会**替换**挂载的元素。挂载元素的内容都将被忽略，除非模板的内容有分发插槽。即该选项`表示要渲染哪些组件`。（参考[官方 issue][template-role]、[API:template选项][api-template]）\n\n以对 `components` 和 `template` 两个选项作用的理解，那么 `渲染函数` 代替的是 `template` 选项的作用，达到**定制化渲染**的作用。\n\n## 虚拟 DOM \n\nVue 通过建立一个**虚拟DOM**对真实的DOM发生的变化保持追踪。在 `render 函数` 中传入一个 `createElement 函数(简写为 h)`（[vue-JSX 使用文档][h-injection]、[Vue 文档][JSX]）来生成模板。\n\n`createElement 函数` 返回的是 `虚拟节点 VNode`， 它包含的信息会告诉 Vue 页面上需要渲染什么样的节点，以及子节点。\n\n## createElement 参数\n\n`createElement` 参数至多包含 3 个部分。\n\n**一个**要创建的元素标签名（类型：字符串/对象/函数返回值）；\n\n**一个**包含模板相关属性的 data 对象（类型：对象）；\n\n**一个**子节点（类型：字符串/数组），且这个子节点也是由另外的 `createElement 函数` 构成。\n\n其中，data 对象和子节点为可选参数。\n\n格式如下：\n\n```js\n// @returns {VNode}\ncreateElement(\n  // {String | Object | Function}\n  // 一个 HTML 标签字符串，组件选项对象，或者一个返回值\n  // 类型为 String/Object 的函数，必要参数\n  'div',\n\n  // {Object}\n  // 一个包含模板相关属性的数据对象\n  // 这样，可以在 template 中使用这些属性。可选参数。\n  {\n    // 此处写入数据对象\n    // https://cn.vuejs.org/v2/guide/render-function.html#深入-data-对象\n  },\n\n  // {String | Array}\n  // 子节点 (VNodes)，由 `createElement()` 构建而成，\n  // 或使用字符串来生成“文本节点”。可选参数。\n  [\n    '先写一些文字',\n    createElement('h1', '一则头条'),\n    createElement(MyComponent, {\n      props: {  // 组件 props\n        someProp: 'foobar'\n      }\n    })\n  ]\n)\n```\n\n## JSX\n\nJSX 最初出现在 `React.js` 中。JSX 语法指在 JS 代码中**直接**嵌入 HTML。JSX 的出现颠覆了以往的 MVC 思想，MVC 是侧重视觉上分离，注重 HTML 与 JS 的分离。但局限性就是，当有大量的 JS 和 HTML 模板时，其中错综复杂的逻辑将导致难以维护。\n\nReact 官方认为应该**侧重于关注组件整体**，应该**从功能上**将各个组件分离开来，组件是和模板紧密关联的，组件模板和组件逻辑分离让问题复杂化。正是基于侧重`从功能上分离组件`的思维，诞生了 JSX 语法。JSX 把 HTML 模板直接嵌入到 JS 中，侧重的是从功能上将各个组件分离，注重的是组件整体。JS 本身不支持直接包含 HTML 的语法，所以要通过工具将 JSX 编译(在 Vue 中使用[babel 插件][babel-plugin-transform-vue-jsx])输出为 JS 代码才能使用。\n\n在 Vue 中使用 JSX 可缓解大量调用 `render 函数`的情况。\n\n[Vue-JSX 使用文档][vue-jsx]\n\n\n\n[template-role]:https://github.com/vuejs-templates/webpack/issues/575\n\n[api-components]:https://cn.vuejs.org/v2/api/#components\n\n[api-template]:https://cn.vuejs.org/v2/api/#template\n\n[h-injection]:https://github.com/vuejs/babel-plugin-transform-vue-jsx#h-auto-injection\n\n[JSX]:https://cn.vuejs.org/v2/guide/render-function.html#JSX\n\n[vue-jsx]:https://github.com/vuejs/babel-plugin-transform-vue-jsx#usage\n\n[babel-plugin-transform-vue-jsx]:https://github.com/vuejs/babel-plugin-transform-vue-jsx\n"},{"to":"180308-event-loop","data":"\n# 事件循环 event loop\n\n单线程的实现方式就是事件循环（`event loop`）。\n\n存在两种 `event loops`（[W3C][event loops]），即一种在 `browsing context` 下的事件循环，一种是在 `web workers` 下的循环。本文讨论在 `browsing context` 下的事件循环。\n\n[event-loop-blog]:https://lbwa.github.io/blog/writings/180308-event-loop/\n\n## 事件循环定义\n\n依据标准中对进程模型的流程描述（[来源][processing-model]）可得出，在完成一个宏任务，并清空因宏任务产生的微任务队列时，称之为一个事件循环。\n\n[event loops]:https://www.w3.org/TR/html5/webappapis.html#event-loop\n\n## 任务源\n\n- 宏任务（macrotask）：\n    \n    1. script\n    \n        - 整体代码（[来源][ECMA-Script-records]），即代码执行的基准执行上下文（[拓展阅读][post-execution-context]）\n\n        - 该宏任务的目的在于，将整体代码段（或理解为模块）推入执行上下文栈（`execution context stack`）中。\n        \n            - 执行上下文栈初始会设置 `script` 为 `当前正在运行执行上下文`（`running execution context`），这期间可能因执行而创建新的执行上下文，那么就会依据模块内的代码不断的设置 **当前正在运行执行上下文**（`running execution context`），这样模块内的代码就会依次得以执行（此处主要是[执行上下文][post-execution-context] 中 `Running execution context 的更替` 的实际应用）。\n            \n            - 比如设置一些事件监听程序，一些声明，执行一些初始任务。在执行完成该任务时，会建立词法作用域等一系列相关运行参数。\n    \n    2. setTimeout，setInterval，setImmediate（服务端 API）\n    \n    3. I/O\n    \n        - 可拓展至 Web API（[来源][generic-task-sources]）：\n        \n            1. DOM 操作\n\n            2. 网络任务\n\n                - Ajax 请求\n            \n            3. history traversal\n\n                - history.back()\n            \n            4. 用户交互\n\n                - 其中包括常见 DOM2（`addEventListener`）和 DOM0（`onHandle`）级**事件监听回调函数**。如 `click` 事件回调函数等。\n\n                - 特别地，事件需要冒泡到 `document` 对象之后并且事件回调执行**完成后**，才算该宏任务执行完成。否则一直存在于执行上下文栈中，等待事件冒泡并事件回调完成（来源：Jake Archibald blog - [level 1 boss fight][jake-blog]）。\n    \n    - **UI rendering**\n\n- 微任务（microtask）:\n\n    1. process.nextTick（[Node.js][process.nextTick]）\n    \n    2. Promise 原型方法（即 `then`、`catch`、`finally`）中被调用的回调函数\n\n    3. MutationObserver（[DOM Standard][mutation-observer]）\n\n        - 用于监听节点是否发生变化\n\n    4. Object.observe(已废弃)\n\n- **特别注明**：在 `ECMAScript` 中称 `microtask` 为 `jobs`（[来源][ECMAScript-jobs]，其中 [EnqueueJob][EnqueueJob] 即指添加一个 `microtask`）。\n\n`macrotask` 和 `microtask` 中的每一项都称之为一个 **任务源**。\n\n以上分类中，每一项执行时均占用`当前正在运行执行上下文`（`running execution context`）（线程）。如，可理解为浏览器渲染线程与 JS 执行共用一个线程。\n\n**依据标准拓展**：\n\n- 在 `W3C` 或 `WHATWG` 中除非特别指明，否则 `task` 即是指 `macrotask`。\n\n- 根据 `W3C`（[来源][micro-task-source]）关于 `microtask` 的描述，只有两种微任务类型：单独的回调函数微任务（solitary callback microtasks），复合微任务（compound microtasks）。那么即在 `W3C` 规范中**所有**的**单独的回调函数**都是**微任务**类型。\n\n    - solitary callback：Promise 原型的原型方法，即 `then`、`catch`、`finally` 能够调用单独的回调函数的方法。\n\n    - compound microtask：\n    \n        1. MutationObserver（[DOM Standard - 4.3.2 步骤 5][mutation-observer]）\n\n        2. process.nextTick（Only for [Node.js][process.nextTick]）\n\n            - > all callbacks passed to process.nextTick() will be resolved before the event loop continues.\n\n- 特别指明，`Web API` （event loops 章节在标准中是属于 Web API 大类）是属于宏任务类型，如 `Ajax` 属于 `I/O`（来源：[using a resource][using-a-resource]），但 `Ajax` 调用的 `Promise` 类型回调函数都是微任务类型。\n\n[ECMA-Script-records]:https://www.ecma-international.org/ecma-262/#script-record\n\n[generic-task-sources]:https://www.w3.org/TR/html5/webappapis.html#generic-task-sources\n\n[ECMAScript-jobs]:http://www.ecma-international.org/ecma-262/#sec-performpromisethen\n\n[EnqueueJob]:http://www.ecma-international.org/ecma-262/#sec-enqueuejob\n\n[micro-task-source]:https://www.w3.org/TR/html5/webappapis.html#microtask\n\n[using-a-resource]:https://www.w3.org/TR/html5/webappapis.html#task-queues\n\n[mutation-observer]:https://dom.spec.whatwg.org/#queue-a-mutation-record\n\n[jake-blog]:https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n\n[process.nextTick]:https://nodejs.org/en/docs/guides/event-loop-timers-and-nexttick/#process-nexttick\n\n## 任务队列 task queue\n\n任务队列分为 `宏任务队列` 和 `微任务队列`。一个事件循环中可能有一个或多个任务队列。因为在执行一个宏任务时，可能产生微任务调用，即产生新的微任务队列。\n\n**相同类型**的任务源的任务被调用时进入相同的任务队列，反之进入不同的任务队列。\n\n### 标准（W3C and WHATWG）中的队列模型\n\n**注**：\n\n- 依据标准[描述][macro-task-queue]，除非特别指明是 `microtask queue`，那么我们一般常说的任务队列（`task queue`）都是指 `宏任务队列`（`macrotask queue`）。\n\n- 每个事件循环都有一个 `当前执行中的任务`（`currently running task`），用于轮询队列中的任务（`handle reentrancy`）。\n\n- 每个事件循环都有一个 `已执行 microtask 检查点标志`（`performing a microtask checkpoint flag`）（初始值一定为 false）表示已经执行了 `microtask` 检查点，用于阻止执行 `microtask checkpoint` 算法的可重入调用。\n    \n    1. 可重入调用（[reentrant invocation][reentrant-invocation]）是指，算法在执行过程中意外中断时，在当前调用未完成的情况下被再次从头开始执行。一旦可重入执行完成，上一次被中断的调用将会恢复执行。\n\n    2. 设置该检查点的原因是：\n\n        - 执行微任务时，可能会调用其他回调函数，当其他回调函数时，并在弹出执行上下文栈时，会断言当前执行上下文栈是否为空，若为空时，那么就会再一次执行 `microtask checkpoint`（来源：[perform a microtask checkpoint - step 2.3][microtask-checkpoint]、[clean up after running script][clean-up-after-running-script]），若没有设置检查点执行标志的话就会再次进入 `microtask queue` 重复执行 `microtask`。\n\n[macro-task-queue]:https://www.w3.org/TR/html5/webappapis.html#microtask\n\n[reentrant-invocation]:https://en.wikipedia.org/wiki/Reentrancy_(computing)\n\n[microtask-checkpoint]:https://html.spec.whatwg.org/multipage/webappapis.html#perform-a-microtask-checkpoint\n\n[clean-up-after-running-script]:https://html.spec.whatwg.org/multipage/webappapis.html#clean-up-after-running-script\n\n（[来源][processing-model]）\n\n1. 在 `browsing context` 事件循环的情况下（与第 8 步并列），选择当前 `task queue` 中**最早**加入的 task。如果没有任务被选中（即当前 `task queue` 为空），那么直接跳转到第 6 步 `Microtasks`\n    \n    - 如 `Ajax` 请求返回数据时，若当前 `task queue` 为空时，将直接跳转执行回调函数微任务。\n\n2. 设置当前事件循环的 `当前执行中的任务` 为第 1 步被选出的 task。\n\n3. `Run`：执行当前被选出的 task（即 task 进入最上层[执行上下文栈][post-execution-context] `execution context stack`）。\n\n4. 重置当前事件循环的 `当前执行中的任务` 为默认值 null。\n\n5. 从当前的 `task queue` 中移除在第 3 步执行过的任务。\n\n6. `Microtasks`：执行 `microtask` 检查点。\n\n    - 当 `已执行 microtask 检查点标志` 为 false 时：\n\n        1. 设置 `已执行 microtask 检查点标志` 为 true。\n\n        2. `操作（handling) microtask 队列`：在当前 `microtask queue` 为空时，跳转到步骤 `Done` 之后。\n\n        3. 选中 `microtask queue` 中最早加入的 `microtask`。\n\n        4. 设置当前事件循环的 `当前执行中的任务` 值为上一步选中的 `microtask`。\n\n        5. `Run`：执行选中的 `microtask`（进入最上层[执行上下文栈][post-execution-context]（来源1：[HTML Standard EnqueueJob 7.6][enqueue-job]、来源2：[ECMAScript EnqueueJob 步骤4][ECMAScript-enqueue-job-step-4]））。\n\n        6. 重置置当前事件循环的 `当前执行中的任务` 值为 null。\n\n        7. 从 `microtask queue` 中移除第 5 步 `Run` 被执行的 `microtask`，回到第 3 步 `操作（handling) microtask 队列`。\n\n            - **重点**：为在一个事件循环中，总是要**清空**当前事件循环中的微任务队列**才会进行重渲染**（`Vue.js` 的 DOM 更新原理）。\n\n        8. `Done`：对于每一个 `responsible event loop` 是当前事件循环的环境设置对象（`environment setting object`），向它（环境设置对象）告知关于 `rejected` 状态的 `Promise` 对象的信息。\n        \n            - 个人理解为触发浏览器 `uncaught` 事件，并抛出 `unhandled promise rejections` 错误（[W3C][unhandled-promise-rejections]）。\n\n            - 此步骤主要是向开发者告知存在未被捕获的 `rejected` 状态的 `Promise`。\n\n        9. 执行并清空 `Indexed Database`（用于本地存储数据的 API） 的修改请求。\n\n        10. 重置 `已执行 microtask 检查点标志` 为 false。\n\n    - 当一个复合微任务（`compound microtask`）执行时，客户端必须去执行一系列的复合微任务的`子任务`（subtask）\n\n        1. 设置 parent 为当前事件循环的 `当前执行中的任务`。\n\n        2. 设置 `子任务` 为一个由一系列给定步骤组成的新 microtask。\n\n        3. 设置 `当前执行中的任务` 为 `子任务`。这种微任务的任务源是微任务类型的任务源。这是一个复合微任务的 `子任务`。\n\n        4. 执行 `子任务`（进入[执行上下文栈][post-execution-context]）。\n\n        5. 重置当前事件循环的 `当前执行中的任务` 为 parent。\n\n7. 更新 DOM 渲染。\n\n    - 一个宏任务 task **至此**整体执行结束（包含调用，执行，重渲染），也是一个**事件循环结束**。\n\n8. （与第 1 步并列）如果当前的事件循环是 `web works` 的事件循环，并且在当前事件循环中的 `task queue` 为空，并且 `WorkerGlobalScope` 对象的 `closing` 为 true，那么将摧毁当前事件循环，并取消以上的事件循环步骤，并恢复执行一个 `web worker` 的步骤。\n\n9. 回到第 1 步执行下一个事件循环。\n\n[processing-model]:https://www.w3.org/TR/html5/webappapis.html#event-loops-processing-model\n\n[enqueue-job]:https://html.spec.whatwg.org/#enqueuejob(queuename,-job,-arguments):queue-a-microtask\n\n[ECMAScript-enqueue-job-step-4]:http://www.ecma-international.org/ecma-262/#sec-enqueuejob\n\n[unhandled-promise-rejections]:https://www.w3.org/TR/html5/webappapis.html#notify-about-rejected-promises\n\n### 示例\n\n以一个示例讲解事件循环：\n\n```js\n// script\n// 1\nconsole.log('I am from script beginning')\n\n// 2\nsetTimeout(() => { // 该匿名函数称为匿名函数a\n  console.log('I am from setTimeout')\n}, 1000)\n\n// 3\nconst ins = new Promise((resolve, reject) => {\n  console.log('I am from internal part')\n  resolve()\n})\n\n// 4\nins.then(() => console.log('I am from 1st ins.then()')).then(() => console.log('I am from 2nd ins.then()'))\n\n// 5\nconsole.log('I am from script bottom')\n```\n\n以上整个代码段即是，`macro-task` 中的 `script` 任务源。\n\n执行原理（依据 Chrome 66 的 V8 实现）如下：\n\n1. 整个代码段 `script` 进入执行上下文栈（亦称调用栈，`call stack`（[来源][post-execution-context]）），执行 1 处代码调用 `console.log` 函数，该函数进入调用栈，之前 `script` 执行上下文执行暂停（冻结），转交执行权给 `console.log`。`console.log`成为[当前执行中的执行上下文][post-execution-context]（`running execution context`）。`console.log` 执行完成立即弹出调用栈，`script` 恢复执行。\n\n2. `setTimeout` 是一个任务分发器，该函数本身会立即执行，延迟执行的是其中传入的参数（匿名函数 a）。`script` 暂停执行，内部建立一个 1 秒计时器。`script` 恢复执行接下来的代码。1 秒后，再将匿名函数 a 插入宏任务队列（根据宏任务队列是否有之前加入的宏任务，可能不会立即执行）。\n\n3. 声明恒定变量 `ins`，并初始化为 `Promise` 实例。特别地，`Promise` 内部代码会在本轮事件循环立即执行。那么此时， `script` 冻结，开始执行 `console.log`，`console.log` 弹出调用栈后，`resolve()` 进入调用栈，将 `Promise` 状态 `resolved`，并之后弹出调用栈，此时恢复 script 执行。\n\n4. 因为第 3 步，已经在本轮宏任务完成前 `resolved` ，否则，将跳过第 4 步向本轮事件循环的微任务队列添加回调函数（[来源][promise-standard]）。调用 `ins` 的 `then` 方法，将第一个 `then` 中回调添加到 `微任务队列`，继续执行，将第二个 `then` 中回调添加到 `微任务队列`。\n\n5. 如同 1 时的执行原理。\n\n6. `script` 宏任务执行完成，弹出执行上下文栈。此时，微任务队列中有两个 `then` 加入的回调函数等待执行。另外，若距 2 超过 1 秒钟，那么宏任务队列中有一个匿名函数 a 等待执行，否则，此时宏任务队列为空。\n\n7. 在当前宏任务执行完成并弹出调用栈后，开始**清空**因宏任务执行而产生的微任务队列。首先执行 `console.log('I am from 1st ins.then()')`，之后执行 `console.log('I am from 2nd ins.then()')`。\n\n8. 微任务队列清空后，开始调用下一宏任务（即进入下一个事件循环）或等待下一宏任务加入任务队列。此时，在 2 中计时 1 秒后，加入匿名函数 a 至宏任务队列，此时，因之前宏任务 script 执行完成而清空，那么将匿名函数 a 加入调用栈执行，输出 `I am from setTimeout`。\n\n**注**：`JavaScript` 中在某一函数内部调用另一函数时，会暂停（冻结）当前函数的执行，并将当前函数的执行权转移给新的被调用的函数（具体解析见[拓展阅读][post-execution-context]）。\n\n示例总结：\n\n1. **在一个代码段（或理解为一个模块）中**，所有的代码都是基于一个 `script` 宏任务进行的。\n\n2. 在当前宏任务执行完成后，**必须**要清空因执行宏任务而产生的`微任务队列`。\n\n3. 只有当前微任务队列清空后，才会调用下一个宏任务队列中的任务。即进入下一个事件循环。\n\n4. `new Promise` 时，`Promise` 参数中的匿名函数是**立即执行**的。被添加进`微任务队列`的是 `then` 中的回调函数。\n\n    - **特别地**，只有 `Promise` 中的状态为 `resolved` 或 `rejected` 后（[Promise 标准][promise-then]），才会调用 `Promise` 的原型方法（即 [then][promise-then]、`catch`（因为是 `then` 的[语法糖][promise-catch]，所以与 `then` 同理）、`finally`（`onfinally`时[触发][promise-finally]）），才会将回调函数到添加微任务队列中。\n\n5. `setTimeout` 是作为任务分发器的存在，他自身执行会创建一个计时器，只有待计时器结束后，才会将 `setTimeout` 中的第一参数函数添加至`宏任务队列`。换一种方式理解，`setTimeout` 中的函数**一定不是在当前事件循环**中被调用。\n\n以下是在客户端（Node.js 可能有不同结果）的输入结果：\n\n```markup\nI am from script beginning\nI am from internal part\nI am from script bottom\nI am from 1st ins.then()\nI am from 2nd ins.then()\nI am from setTimeout\n```\n\n[promise-then]:https://promisesaplus.com/#point-26\n\n[promise-catch]:https://www.ecma-international.org/ecma-262/#sec-promise.prototype.catch\n\n[promise-finally]:https://tc39.github.io/ecma262/#sec-promise.prototype.finally\n\n## 事件循环拓展应用 —— 异步操作\n\n1. 定时任务：setTimeout，setInterval\n\n2. 请求数据：Ajax 请求，图片加载\n\n3. 事件绑定\n\n一般地，在 JS 开发过程中，凡是可能造成代码阻塞的地方都可根据实际情况考虑使用异步操作。比如，数据获取等等。\n\n[post-execution-context]:https://lbwa.github.io/blog/writings/180507-execution-context/\n\n[promise-standard]:https://promisesaplus.com/\n\n# 参考\n\n`JavaScript 语言精粹(修订版)`\n\n[w3c Event loop][w3c]\n\n[HTML5 Standard][html5]\n\n[ECMA Jobs and Job Queues][job-queues]\n\n[Tasks, microtasks, queues and schedules][blog0]\n\n[Great talk at JSConf 2014 on the event loop][video]\n\n\n[1]:https://stackoverflow.com/questions/25915634/difference-between-microtask-and-macrotask-within-an-event-loop-context\n\n[2]:http://www.ituring.com.cn/article/66566\n\n[w3c]:https://www.w3.org/TR/html5/webappapis.html#event-loops\n\n[html5]:https://html.spec.whatwg.org/multipage/webappapis.html#event-loops\n\n[es6]:http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n\n[promise]:http://www.ecma-international.org/ecma-262/6.0/#sec-performpromisethen\n\n[job-queues]:http://www.ecma-international.org/ecma-262/6.0/#sec-jobs-and-job-queues\n\n[blog0]:https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/\n\n[video]:https://www.youtube.com/watch?v=8aGhZQkoFbQ\n"},{"to":"180306-learning-vuex","data":"\n# 核心概念\n\nvuex 就是将 vue 中需要管理的状态，全部集中到一个容器中，集中管理。下文代码中 store 指代 vuex 容器实例（`const store = new Vuex.Store({ ... })`），同时在组件中可使用`this.$store`来访问 vuex 容器实例。注意，在通过`this.$store`来访问各个选项时，选项名末尾除state外，都必须有`s`。\n\nVuex 通过 store 选项，提供了一种机制将状态从根组件\"注入\"到每一个子组件中（需调用`Vuex.use(Vuex)`）。通过在**根实例**中注册`store`选项，该 store 实例会注入到根组件下的**所有**子组件中，且子组件可以通过`this.$store`访问到。\n\n## state —— 存储状态的容器\n\nstate 用于缓存状态（计算属性）数据。可**类比**于 vue 实例中的 data 数据对象。\n\n特点：\n\n1. 具有响应式变化的特点，最简单读取 vuex 实例（store）的状态的方法是，在计算属性中返回某个状态。如下所示:\n```js\ncomputed: {\n  count () {\n    return store.state.count\n  }\n}\n```\n但是，一般的用法是，通过**store选项**注入到 vue 组件中。\n2. [mapState 辅助函数][mapState]用于读取多个状态，生成计算属性（状态）\n\n## getter —— 处理旧状态生成新状态\n\ngetter 可**类比** vue 实例中的 computed 选项，可称为是 store 的计算属性。读取 state 中的数据A，经 getter 中的处理函数处理后返回生成一个新的状态数据B（A的计算属性）。\n\ngetter 暴露一个`store.getter`对象，这里`store`指的是 vuex 的实例对象，可写作`this.$store`或`$store`。getter 对象中包含了一些处理 state 中状态的处理函数。这些处理函数将返回一个新的状态数据，这些新的状态数据是**储存于 getter 对象中的**。\n\ngetter 中的处理函数接受 state 中的状态数据作为**第一参数**，另外可选的，可将 getter 中的其他 getter 作为**第二参数**\n\n`mapGetters`[辅助函数][mapGetters]仅仅是将 store 中的 getter 映射到局部计算属性。\n\n`mapGetters`的实现和`mapState`很类似，不同的是`mapGetters`函数的参数**不能是函数**，只能是一个字符串。对比如下：\n\n```js\nimport { mapState, mapGetters } from 'vuex'\nexport default {\n  // ...\n  computed: mapState({\n    // ...\n    // mapState 中可以传入函数\n    // 若要访问局部状态 state 必须借助一个普通函数\n    countPlusLocalState (state) {\n      return state.count + this.localCount\n    }\n  })\n}\n// 等价于\nexport default {\n  // ...\n  computed: {\n    // ...\n    countPlusLocalState () {// this.$store.state 即为局部状态容器\n      return this.$store.state.count + this.localCount\n    }\n  }\n}\n\nexport default {\n  // ...\n  computed: {\n  // 使用对象展开运算符将 getter 混入 computed 对象中\n    ...mapGetters([\n      'doneTodosCount',// mapGetters 中不能传入函数\n      'anotherGetter',\n      // ...\n    ])\n  }\n}\n// 等价于\nexport default {\n  // ...\n  computed: {\n    doneTodosCount () {\n      return this.$store.getters['doneTodosCount']\n    },\n    anotherGetter () {\n      return this.$store.getters['anotherGetter']\n    }\n  }\n}\n\n```\n\n## Mutation —— 修改旧状态\n\n### 含义及作用\n\n更改 vuex 的 store 中的状态的**唯一方法**是提交 mutation。可**类比**vue中的事件，提交 mutation **类比**触发事件(this.$emit(‘事件名’))。\n\n每个 mutation 都有一个字符串类型的**事件类型(type)**和一个回调函数（接受 state 作为第一参数），该回调函数即是更改 state 状态的**关键**。回调函数的名称**即是**事件类型。\n\n这种 mutation 中定义事件类型和回调函数的方式**可看作**是自定义事件注册。但**不能直接调用** mutation 中的回调函数。\n\n### 使用方法\n\n不能直接调用 mutation handler，可类比调用`this.$emit`方法触发某自定义事件。那么，使用 mutation handler 的方法如下：\n\n```js\nstore.commit('mutations 选项中的回调函数名')\n```\n\n>`store.commit()`可传入一个可选项第二参数，作为载荷。 载荷的作用是带入 mutation handler 中作为参数使用。\n\n另外，还可以使用对象风格的提交方式（其中必包含事件类型 type ），该对象将整体传入 mutation 对象。如下所示提交 mutation 的三种方法：\n\n```js\nstore.commit('increment')\n// 或者写为\nstore.commit('increment', { amount: 10 })\n// 或者写为\nstore.commit({\n  type: 'increment', // 将用于匹配对应的回调函数\n  amount: 10 // 将作为 回调函数 的参数使用\n})\n```\n\n综上，在组件中使用`this.$store.commit('xxx')`来提交 mutation。或使用`mapMutations`将组件的 methods 映射为`store.commit`调用（需要在根节点注入 store）\n```js\nimport { mapMutations } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapMutations([\n      // 将 `this.increment()` 映射为 `this.$store.commit('increment')`\n      'increment',\n\n      // `mapMutations` 也支持载荷：\n      'incrementBy'\n    ]),\n    ...mapMutations({\n      // 将 `this.add()` 映射为 `this.$store.commit('increment')`\n      add: 'increment'\n    })\n  }\n}\n```\n\n### 注意事项\n\n1. mutations 选项中的方法是不分组件的 , 假如你在 A.js 文件中的定义了\nfn 方法 , 在其他文件（B.js等等）中的一个 fn 方法 , 那么\n$store.commit('fn') 会**执行所有**的 fn 方法。\n1. mutations 选项中的操作**必须是同步**的。\n\n## Action —— 可包含异步的“Mutation”\n\naction 与 mutation 根本作用都是修改状态，不同之处在于：\n1. action 提交的是 mutation，而不是直接修改状态\n1. action 可以包含任意异步操作\n\n**本质上**，action 是通过提交 mutation 来修改状态的，最终还是回归到**只有** mutation 能够修改 state 中的状态。\n\nactions 选项中的回调函数接受的**参数**是一个与 store 实例对象具有相同方法和属性的 context 对象。\n\n常见[action 注册][action]如下：\n\n```js\nconst store = new Vuex.Store({\n  state: {\n    count: 0\n  },\n  mutations: {\n    increment (state) {\n      state.count++\n    }\n  },\n  actions: {\n    increment (context) { // comtext 与 store 有相同的属性和方法\n      context.commit('increment') // action 通过提交 mutation 来修改状态\n    }\n  }\n})\n```\n\n据[vuex 官方文档][action]，有这么一段话：\n\n> Action 函数接受一个与 store 实例具有相同方法和属性的 context 对象，因此你可以调用 context.commit 提交一个 mutation，或者通过 context.state 和 context.getters 来获取 state 和 getters。\n\n因为在[分发 action][action]时要使用到`store.dispatch`来触发 action 中的函数，那么我们给 action 对象中的函数定义时需要一个名字，该函数名作为分发 action 的**依据**。此时，该函数的参数对象会**获得与 store 实例相同的方法和实例**，而且因为有 ES6 的[解构赋值][destructuring]的存在，那么之前注册 actions 选项的代码与下面的代码等价：\n\n```js\nactions: {\n\n  /**\n   * 默认的 action 对象中的函数的参数对象将获得与 store 实例相同的方法和属性（容器实例\n   * 默认有 commit 方法），那么 { commit } 对象是存在有 commit 方法的(因为 ES6 解构\n   * 赋值)。commit 不仅仅是属性，还是方法。\n   */\n\n  increment ({ commit }) {\n    commit('increment')\n  }\n}\n```\n\n### 分发 action\n\naction 通过`store.dispatch`方法触发分发。\n\n```js\nstore.dispatch('actions 中的回调函数')\n```\n\n这里可总结为：\n1. action 中函数通过`this.$store.dispatch('xxx')`触发执行。\n1. action 中函数内部通过`context.commit('xxx')`触发提交`mutations`\n\n根据 action 本质还是提交 mutation 来说，不直接分发 mutation 的原因在于 mutation 必须是同步执行的。那么，分发 action 的**意义**在于可在 action 内部中**执行异步操作**。\n\n在组件中使用`this.$store.dispatch('xxx')`分发 action，或者使用`mapActions`辅助函数将组件的 methods 映射为 `store.dispatch` 调用（需要先在根节点注入 store ）：\n\n```js\nimport { mapActions } from 'vuex'\n\nexport default {\n  // ...\n  methods: {\n    ...mapActions([\n      // 将 `this.increment()` 映射为 `this.$store.dispatch('increment')`\n      'increment',\n\n      // `mapActions` 也支持载荷：\n      // 映射为 `this.$store.dispatch('incrementBy', amount)`\n      'incrementBy'\n    ]),\n    ...mapActions({\n      // 将 `this.add()` 映射为 `this.$store.dispatch('increment')`\n      add: 'increment'\n    })\n  }\n}\n```\n\n### 组合 action\n\n前文提到，action 对象内部可执行异步操作，那么如何知道其对象内部的处理函数何时执行结束？\n因为只有知道执行结束才能组合其他 action 中的处理函数，用于处理复杂的异步情况。\n\n首先，必须明白`store.dispatch`可以处理 被触发的 action 内部的处理函数返回的 Promise，简而言之，`store.dispatch`**可以**处理 Promise。并且`store.dispatch`方法本身仍旧**返回 Promise 对象**。\n\n```js\nactions: {\n  actionA ({ commit }) {\n    return new Promise((resolve, reject) => { // actionA 函数返回一个 Promise\n      setTimeout(() => {\n        commit('someMutation')\n        resolve()\n      }, 1000)\n    })\n  }\n}\n\n// store.dispatch 方法可处理 Promise 对象，那么有以下代码成立\nstore.dispatch('actionA').then(() => {\n  // ...\n})\n\n// store.dispatch 方法可处理 Promise 对象且本身返回 Promise ，那么可在 action 中可以\n// 调用其他的 action\nactions: {\n  // ...\n  actionB ({ dispatch, commit }) {\n    return dispatch('actionA').then(() => {\n      commit('someOtherMutation')\n    })\n  }\n}\n```\n\n因为有进化版的 Promise，即[async/await][async]，aysnc 函数本身返回一个 Promise 对象，那么我们可以据此组合 action：\n\n```js\n// 假设 getData() 和 getOtherData() 返回的是 Promise\n\nactions: {\n  async actionA ({ commit }) {\n    commit('gotData', await getData())\n  },\n  async actionB ({ dispatch, commit }) {\n    await dispatch('actionA') // 等待 actionA 完成\n    commit('gotOtherData', await getOtherData())\n  }\n}\n```\n\n## module —— 将 store 分割成模块\n\n每个模块可拥有自己的 store 容器，其中包含属于自己模块的 state、mutation、action、getter。store 容器中可使用 module 选项来**包含其他模块的 store 容器**。\n\n### 模块内的局部状态\n\n对于模块内部的 mutation 和 getter，接收的第一个参数是模块的**局部状态对象**。\n\n```js\nconst moduleA = {\n  state: { count: 0 },\n  mutations: {\n    increment (state) {\n      // 这里的 `state` 对象是模块的局部状态，指向 state: { count: 0 }\n      state.count++\n    }\n  }\n}\n```\n\n对于模块内部的 action，局部状态通过`context.state`暴露出来，根节点状态则为`context.rootState`（参数对象简写成以下代码格式的原因见 Action 章节简介）：\n\n```js\nconst moduleA = {\n  // ...\n  actions: {\n    // state 是局部状态，commit 是提交 mutation 的方法，rootState 是根节点状态\n    incrementIfOddOnRootSum ({ state, commit, rootState }) {\n      if ((state.count + rootState.count) % 2 === 1) {\n        commit('increment')\n      }\n    }\n  }\n}\n```\n\n对于模块内部的 getter，根节点状态会作为第三个参数暴露出来：\n\n```js\nconst moduleA = {\n  // ...\n  getters: {\n    // state 是模块内的局部状态，getters 是调用其他的 getter，rootState 是根节点状态\n    sumWithRootCount (state, getters, rootState) {// 这里是三个参数，而不是一个对象\n      return state.count + rootState.count\n    }\n  }\n}\n```\n\n### 命名空间\n\n默认情况下，模块内部的 action、mutation 和 getter 是注册在**全局**命名空间的。\n\n通过在 module 选项中添加`namespaced: true`来使模块成为成为**命名空间模块**，当模块被注册之后，它所有的 `getters`、`actions`、`mutations` 都会自动根据模块注册的路径**调整**命名。\n\n```js\nnew Vuex.Store({\n  modules: {\n    moduleA: {\n      // namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）\n      namespaced: true\n      //...\n      mutations: {\n        getSomeState (state) {\n          // ...\n        }\n      }\n    }\n  }\n})\n```\n\n在以上示例中，`namespaced` 选项限定了当前模块下的 `getters` 和 `mutations` 和 `actions` 的命名空间（或者理解为作用域），使得要调用它们必须先调用它们的模块。即 `this.$store.commit('moduleA/getSomeState')`。\n\n```js\n// 组件内\n...mapMutations([\n  'moduleA/getSomeState'\n])\n\n// 调用 Mutations\nthis['moduleA/getSomeState']()\n```\n\n或者在组件中另外定义名称\n\n```js\n// 组件内\n...mapMutations({\n  getSomeState: 'moduleA/getSomeState'\n})\n\n// 调用 Mutations\nthis.getSomeState()\n```\n\n设置命名空间的好处是，可在不同的模块之间取**同名**的 `mutations` 等函数而不会冲突，它们也会获取自己命名空间的 `state`。\n\n#### 命名空间内访问全局内容\n\n特别地，在命名空间内，`rootState` 和 `rootGetters` 将作为**第三**和**第四**参数传入 `mutations`，在 `actions` 中作为 `context` 的属性传入，那么可在命名空间内调用 `rootState` 和 `rootGetters` 得到全局的 `state` 和 `getters`。\n\n在命名空间内调用全局的 `mutations` 和 `actions` 时，**必须**添加第三参数 `{ root: true }` 来调用全局函数。否则调用的是命名空间内的函数。\n```js\nnew Vuex.Store({\n  modules: {\n    moduleA: {\n      // namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）\n      namespaced: true\n      //...\n      actions: {\n        getMoreState: {\n          // context 包含了命名空间的所有 state, getters, mutations, actions,\n          // dispatch, commit, rootState, rootGetters\n          // 或根据需要写成形如 { commit } 的形式\n          handler (context) {\n            // ...\n\n            // 调用命名空间的 someOtherAction\n            context.dispatch('someOtherAction')\n\n            // 调用全局空间中的 someOtherAction，载荷为 null，即没有载荷\n            context.dispatch('someOtherAction', null, { root: true })\n          }\n        }\n      }\n      // ...\n    }\n  }\n})\n```\n\n#### 命名空间内注册全局 action\n\n在注册时，添加 `root: true` 选项。\n\n```js\nnew Vuex.Store({\n  modules: {\n    moduleA: {\n      // namespaced 选项限定了模块下的 mutations 和 actions 的命名空间（作用域）\n      namespaced: true\n      //...\n      actions: {\n        getMoreState: {\n          root: true,\n          // context 包含了命名空间的所有 state, getters, mutations, actions, \n          // dispatch, commit, rootState, rootGetters\n          handler (context) {\n            // ...\n          }\n        }\n      }\n      // ...\n    }\n  }\n})\n```\n\n#### 兄弟命名空间调用\n\n```js\nnew Vuex.Store({\n  modules: {\n    moduleA: {\n      namespaced: true,\n      //...\n      mutations: {\n        getSomeState (state) {\n          // ...\n        }\n      }\n      // ...\n    },\n\n    moduleB: {\n      namespaced: true,\n      actions: {\n        editModuleAState ({ commit }) {\n          // 补全命名空间路径，并指明 { root: true }\n          commit('moduleA/getSomeState', someDate, { root: true })\n        }\n      }\n    }\n  }\n})\n```\n\n由示例可知，兄弟命名空间的调用可通过全局调用 `{ root: true }` 来完成。\n\n[mapState]:https://vuex.vuejs.org/zh-cn/state.html\n\n[mapGetters]:https://vuex.vuejs.org/zh-cn/getters.html\n\n[action]:https://vuex.vuejs.org/zh-cn/actions.html\n\n[destructuring]:http://es6.ruanyifeng.com/#docs/destructuring#%E5%87%BD%E6%95%B0%E5%8F%82%E6%95%B0%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC\n\n[async]:http://es6.ruanyifeng.com/#docs/async\n"},{"to":"180227-compare-commonjs-with-esm","data":"\n> 在学习`Vue.js`中模块开发时，遇到一些关于 `CommonJS` 与`ES6`模块语法加载机制异同的相关知识欠缺的问题，经过查阅后补全知识缺口。现将自己对二者的异同之处的理解总结复盘如下。\n\n# CommonJS 简介\n\n在 CommonJS 中每一个文件都是一个**模块**。\n\n### 定义模块\n\n在每个模块（文件）内，module 变量表示当前模块，module变量的 exports 属性即为当前模块暴露给外部的数据接口，该值为一个对象。\n\n### 加载模块\n\n在 CommonJS 中，加载模块即是调用用`module.exports`变量的**值的副本**。\n\n使用`require('模块名或地址')`来加载模块。其中参数类型为字符串，默认参数文件类型为`.js`。\n\n> `/` 表示从根目录开始，是相对于根目录的路径（对于项目来说，这是[绝对路径][0]）。例如，`/dist`表示**根目录**下的`dist`文件夹。可类比`HTML`文档中的`<base>`标签，其所在文档之后的标签中的`/`表示从`<base>`指定的默认地址（指定了根目录）开始查找。\n\n> `./` 表示相对路径，即当前模块所在目录下。\n\n> `../` 表示相对路径，即当前模块的上一级父目录。\n\n### 入口文件（模块之间的调用是如何开始的）\n\n一般有一个主文件（入口文件），在项目文件夹下的`index.html`中引入加载该文件，之后在入口文件中会触发加载其他模块。\n\n### 模块缓存/加载机制\n\nCommonJS 模块的重要特性是**加载时执行**，即脚本代码在调用`require()`加载模块的时候，就会全部执行模块，然后在内存生成一个对象（该对象包含如模块id，该模块输出对象等等一系列信息）。\n\n第一次加载某个模块时，Node 会**缓存**该模块的输出值。在加载该模块输出值时调用的是**缓存**中该模块的`module.exports`值的**副本**。即使再次执行`require()`，也不会再次执行该模块，而是到**缓存**之中取值。也就是说，CommonJS 模块无论加载多少次，都只会在第一次加载时运行一次，以后再加载，就返回第一次运行的结果，除非手动清除系统缓存。即**CommonJS模块可多次加载，但只执行一次。**\n\n# CommonJS 与 ES6 模块的异同\n\n## 共同点\n\n### 模块之间同步加载\n\nCommonJS 加载模块是同步的，只有当前模块加载完毕，才会开始加载下一个模块。\n\nES6 模块[加载规则][1]在浏览器中是模块之间是同步的，对于渲染DOM是异步的。即浏览器中`<script>`的`type=\"module\"`相当于默认开启了`<script>`的`defer`属性（不阻塞DOM渲染，在渲染完成后执行模块），在 Node 中的 ES6 模块加载机制与在浏览器中的处理方法是**相同**的。\n\n二者模块加载的顺序是**按照代码出现的顺序同步加载**的。\n\n### 查找模块\n\n>目前，Node 的 import 命令只支持加载本地模块（file:协议），不支持加载远程模块。\n\n如果模块名不含路径，那么 `import` 命令会去`node_modules`目录寻找这个模块。\n\n在使用`vue-cli`构建`vue`单文件组件时，有部分JavaScript文件有以下一行代码：\n\n```js\n// 在构建时，若只有模块名，则将会去 node_modules 目录下寻找vue模块\n// 当前模块的 Vue 变量将被赋值被加载模块的默认输出对象（即export default {...}）\nimport Vue from 'vue'\n// 另一种写法如下\nimport Vue from \"../node_modules/vue/dist/vue.min.js\"\n// 上面import语句与下句调用require方法，作用相同\n// 不同之处在于import只能用在模块开头，require方法可用在模块任意位置\nconst vue = require('vue')\n```\n\n如果模块名包含路径，那么`import`命令会按照路径去寻找这个名字的脚本文件。\n\n如果脚本文件省略了后缀名，比如`import './foo'`，Node 会依次尝试四个后缀名：`./foo.mjs`、`./foo.js`、`./foo.json`、`./foo.node`。如果这些脚本文件都不存在，Node 就会去加载`./foo/package.json`的main字段指定的脚本。如果`./foo/package.json`不存在或者没有main字段，那么就会依次加载`./foo/index.mjs`、`./foo/index.js`、`./foo/index.json`、`./foo/index.node`。如果以上四个文件还是都不存在，就会抛出错误。\n\n在webpack设置模块（`webpack.config.js`）中的输出对象（`module.exports = {...}`）中的路径查找（如对象中的output选项），`__dirname`（最前是两个下划线，如同ES6中`__proto__`属性）表示当前模块文件所在的文件夹路径，`__filename`表示当前模块文件所在的文件夹路径加文件名。\n\n> 拓展：Node原生提供一些核心模块：http、fs、os、path、url、querystring等，Node在加载核心模块时，不需要传入路径，因为`Node.js`已经将核心模块的文件代码编译到了二进制可执行文件中，核心模块在Node中加载的优先级是最高的。\n\n### 作用域\n\n他们每个模块都具有自己独立的作用域，模块中的代码是在模块内部的作用域执行的。模块中的顶层变量外部是不可见的。\n　　\n## 不同点\n\n### 对被加载模块的输出值的引用方式不同\n\n>CommonJS 模块输入的是被加载模块**输出值的副本**，ES6 模块输入的是被加载模块**输出值的引用**。\n\n具体解释为 CommonJS 输入的是 Node 缓存中被加载模块的输出值的副本，那么在被加载模块中值的变化将**不会影响**到输入值。此时，模块的引入值与被加载模块的输出值已经没有直接的联系。\n\n> 拓展：将CommonJS被加载模块的输出值设为输出一个**取值函数**，而不是一个静态值，那么此时，该输出值可起到动态引用被加载模块内部变量的作用。这与ES6 模块的输出效果相同。\n\nES6 模块中**不会缓存**第一次加载模块的结果，而是动态地去被加载的模块取值。当前模块引入变量总是**绑定**在其所在模块（被加载模块）。模块引入的变量是**只读**的，且本质为一个被加载模块的输出值的**引用**。\n\n### 二者的运行机制的差异\n\n>CommonJS 模块是运行是加载，ES6 模块是编译时的输出接口。\n\nES6 模块在遇到加载命令`import`就会生成一个**只读引用**，等到脚本真正执行至取值语句时，再根据这个只读引用，到被加载的那个模块中取值。即**使用值时才取值，否则只建立数据引用**。\n\nCommonJS 模块的加载机制详见前文[模块缓存/加载机制][2]\n\n## 参考\n\n[ECMAScript 6 入门][3]\n\n[0]:https://stackoverflow.com/questions/24028561/relative-path-in-html\n\n[1]:http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99\n\n[2]:https://lbwa.github.io//blog/writings/180227-compare-commonjs-with-esm/#模块缓存-加载机制\n\n[3]:http://es6.ruanyifeng.com/#docs/module-loader#%E5%8A%A0%E8%BD%BD%E8%A7%84%E5%88%99\n"},{"to":"180224-learning-vuejs-essentials","data":"\n# 简介\n\n　　在HTML文档中，类似v-bind的特性被称为指令。指令带有前缀v-。以表示它们是Vue提供的特性。它们会在渲染的DOM上应用特殊的响应式行为。看起来Vue应用看起来非常像字符串模板，此时数据与DOM建立了关联，所有的东西都是响应式的。在Vue.js编程中，数据都是以对象的属性存储，即在Vue.js中存在数据对象用于存储数据。\n\n# 常用指令\n\n## 条件与循环\n\n`v-for`指令可以绑定数组的数据来渲染一个项目列表。\n\n## 处理用户输入\n\n`v-on`指令添加一个事件监听器，通过它调用在Vue实例中的定义的方法。\n 在Vue中操作DOM时，所有实际操作DOM都是Vue来操作，开发人员不会触碰DOM，所以开发时，只需关注逻辑层面即可。\n\n`v-model`指令，用来实现表单输入和应用状态之间的双向绑定。他的作用是修改表单控件的value值，同时监听所在表单控件的input事件，在该指令后添加.lazy修饰符可改为监听change事件。\n\n# Vue实例\n\n　　当一个Vue实例被创建时，它像Vue的响应式系统加入了其data对象中所能找到的所有属性（所有可枚举属性？）。只有这些属性发生变化时，视图才会产生“响应”（视图重绘），即匹配更新为新的值。若之后再向data对象中添加的属性不是“响应式”的。\n\n综上，只有创建Vue实例时的`data`对象中的属性才是“响应式”的，后期添加响应式属性使用` Vue.set(object, key, value)`又可写作 `vm.$set(object,key,value)`,其中vm是实例名，或在创建实例时添加一个该属性的默认值（具体见列表渲染中对象更改检测注意事项）。\n\n那么，如何达到在创建实例之后，在未来某一时刻还会向data对象添加属性并产生视图更新的目的？解决的方法就是设置一些初始值，未来只需要修改某一初始值就可以达到响应式更新视图的目的。\n\n注：`Object.freeze( )`（该方法表示参数对象是永不可变的，不可新增、修改、删除该对象的某一属性）会阻止修改现有的属性。也就意味着响应系统之后就无法追踪变化。\nVue实例除了数据属性之外，还暴露了一些实例属性和方法，这些属性都是以$开头，以便将用户定义的属性区分开来。\n\n## 实例生命周期钩子\n\n含义：给用户在实例的某个时期（比如，创建实例后，销毁实例后）运行自己代码的机会。\n注：在实例声明周期钩子中，**不要用箭头函数**，因为箭头函数的this是借用外层作用域的this，箭头函数本身是没有this对象的。\n\n# 模板语法\n\n## 插值\n\n### 文本\n\n数据绑定最常见的形式是使用`Mustache`语法（双大括号）的文本插值：\n`<span>{ {msg} }</span>`\n`Mustache`标签将被替换为对应数据对象（即`Vue`参数中的对象的data属性，该属性是一个对象）上`msg`属性的值。\n\n无论何时，绑定的`msg`属性变化时，插值处的的内容都会更新。\n\n在标签中添加`v-once`指令，就会执行一次性赋值，后续数据对象中绑定的属性更新时，插值处内容将不会更新。\n\n### 原始HTML\n\n据前所述，双大括号将数据解释为普通文本，而非HTML代码。为输出真正的HTML代码，需要使用v-html指令。\n\n### 特性\n\nMustache语法不能作用在HTML特性上，遇到这种情况要（响应式赋值）使用v-bind指令：\n\n```html\n<!-- html -->\n<div id=\"app\">\n  <span v-bind:id=\"dynamicId\" >testing text</span>\n  <button v-bind:disabled=\"isDisabled\">Testing button</button>\n</div>\n```\n\n```js\n// JavaScript\nlet vm = new Vue({\n   el:'#app',\n   data: {\n      dynamicId:'testing-id',\n      isDisabled: true\n   }\n});\n```\n\n在布尔特性下，它们的存在即暗示为true，`v-bind`工作起来与上述不同。在示例中，当`isDisabled`为false时，将不会被包含在渲染出的`<button>`标签中。\n\n### 使用JavaScript表达式\n\n对于所有的数据绑定，`Vue.js`都提供完全的JavaScript表达式的支持。\n在Mustache语法中只支持表达式，不支持流控制。 　\n\n```js\n\n// 这是语句，不是表达式\n{ { let a = 1; } }\n\n// 流控制不会生效，请使用三元表达式代替\n{ { if(true) { msg } } }\n\n```\n\n模板表达式都是存在于一个沙盒中，该沙盒只存在一些默认的全局变量白名单，如`Math`、`Date`。在模板表达式中无法访问用户定义的全局变量。\n\n### 指令\n\n指令是带有`v-前缀`的特殊属性。指令属性的值预期是单个JavaScript表达式（`v-for`除外）。\n指令的职责是当表达式的值改变时，将其产生的连带影响，响应式的作用于DOM。\n\n### 缩写\n\n`v-bind`可直接省略，`v-on`可缩写为`@`　\n\n`v-bind:id = \"myId\" `缩写为 `:id=\"myId\"`　\n\n`v-on:click = \"doSomething\" `缩写为` @click=\"doSomething\"`\n\n计算属性和侦听器\n一般只在Mustache语法中写入显而易见的JavaScript表达式，否则在Mustache语法中请使用计算属性或方法。\n\n```html\n<!-- html -->\n<div id=\"app\">\n  <p>{ {reverseMsg} }</p>\n  <p>{ {reverseString()} }</p>\n</div>\n```\n\n```js\n// JavaScript\nlet vm = new Vue({\n    el: '#app2',\n    computed: {\n      /**\n       * 相当于某属性的getter函数，有缓存的作用，在依赖的数据值未改变的情况下，不会重新\n       * 执行函数，否则执行更新\n       */\n      reverseMsg: function () {\n        return 'computed'.split('').reverse().join('');\n      }\n    },\n    methods: {\n      // 每次调用都会重新计算函数返回值\n      reverseString: function () {\n        return 'methods'.split('').reverse().join('');\n      }\n    }\n  });\n```\n\n# 计算属性和侦听器\n\n## 计算属性\n\n### 计算属性vs方法\n\n　　二者在写法上，都是存储在一个对象中，都是一个函数。\n\n　　二者的区别在于，计算属性是**基于它们的依赖进行缓存**的，相当于某属性的getter函数（计算属性函数本身默认只包含一个get方法），**只有**在该属性所依赖的数据**值改变**时，才会重新计算，否则不计算。而对于方法，当每次重绘渲染发生时，都将**总是**再次执行函数，不论值是否改变，即**方法不依赖值的改变而执行**。\n\n综上，**推荐使用计算属性**，若不希望调用缓存则使用方法。\n\n## 侦听器\n\n　　Vue 通过 watch 选项提供了一个更通用的方法，来响应数据的变化。 在大多数情况（同步执行）下，使用计算属性，在特殊情况（异步执行，如侦听`Ajex`或开销较大时需要侦听的情况）下监听则可建立一个自定义监听器。\n\n使用场景：当需要在数据变化时执行异步或开销较大的操作时，这个方式是最有用的。\n\n个人理解：可类比JavaScript中的事件处理程序。\n\n# Class 和 Style 绑定\n\n### 对象语法（切换class）\n\n给`v-bind:class`传入一个对象，以**动态地切换**class\n`<div v-bind:class = \"{ active: isActive }\"></div>`\n以上表示active这个class是否存在取决于isActive的布尔值。\n`v-bind:class`可与普通class**共存**。\n\n# 列表渲染\n\n## 数组更新检测注意事项\n\n由于 JavaScript 的限制，Vue 不能检测以下变动的数组：\n\n1. 当你利用索引直接设置一个项时，例如：\n`vm.items[indexOfItem] = newValue`\n\n2. 当你修改数组的长度时，例如：\n`vm.items.length = newLengt`\n为了解决第一类问题，以下两种方式都可以实现和 `vm.items[indexOfItem] = newValue`相同的效果，同时也将触发状态更新：\n\n```js\n// Vue.set\nVue.set(example1.items, indexOfItem, newValue)\n// Array.prototype.splice\nexample1.items.splice(indexOfItem, 1, newValue)\n```\n\n为了解决第二类问题，你可以使用 splice：\n`example1.items.splice(newLength)`\n\n## 对象更改检测注意事项\n\n还是由于 JavaScript 的限制，Vue 不能检测对象属性的添加或删除：\n\n```js\nvar vm = new Vue({\n  data: {\n    a: 1\n  }\n})\n// `vm.a` 现在是响应式的\n\nvm.b = 2\n// `vm.b` 不是响应式的\n```\n\n对于已经创建的实例，Vue 不能动态添加根级别的响应式属性。但是，可以使用 `Vue.set(object, key, value)` 方法向嵌套对象添加响应式属性。例如，对于：\n\n```js\nvar vm = new Vue({\n  data: {\n    userProfile: {\n      name: 'Anika'\n    }\n  }\n})\n```\n\n你可以添加一个新的 age 属性到嵌套的 userProfile 对象：\n`Vue.set(vm.userProfile, 'age', 27)`\n你还可以使用 vm.$set 实例方法，它只是全局 Vue.set 的别名：\n`vm.$set(vm.userProfile, 'age', 27)`\n有时你可能需要为已有对象赋予多个新属性，比如使用 `Object.assign()` 或 `_.extend()`。在这种情况下，你应该用两个对象的属性创建一个新的对象。所以，如果你想添加新的响应式属性，不要像这样：\n\n```js\nObject.assign(vm.userProfile, {\n  age: 27,\n  favoriteColor: 'Vue Green'\n})\n```\n\n你应该这样做：\n\n```js\nvm.userProfile = Object.assign({}, vm.userProfile, {\n  age: 27,\n  favoriteColor: 'Vue Green'\n})\n```\n\n# 事件处理\n\n## 事件修饰符\n\n在事件处理程序中调用 `event.preventDefault()` 或  `event.stopPropagation()`是非常常见的需求。尽管我们可以在方法中轻松实现这点，但更好的方式是：方法只有纯粹的数据逻辑，而不是去处理 DOM 事件细节。\n\n为了解决这个问题，`Vue.js `为 ` v-on` 提供了事件修饰符。之前提过，修饰符是由点开头的指令后缀来表示的。\n\n注：使用修饰符时，顺序很重要；相应的代码会以同样的顺序产生。因此，用`@click.prevent.self` 会阻止所有的点击，而 `@click.self.prevent` 只会阻止对元素自身的点击。\n\nVue 还对应 addEventListener 中的 passive 选项提供了 `.passive`修饰符。\n\n```html\n\n<!-- 滚动事件的默认行为 (即滚动行为) 将会立即触发 -->\n<!-- 而不会等待 `onScroll` 完成  -->\n<!-- 这其中包含 `event.preventDefault()` 的情况 -->\n<div v-on:scroll.passive=\"onScroll\">...</div>\n\n```\n这个 `.passive `修饰符尤其能够提升移动端的性能。\n不要把` .passive `和 `.prevent` 一起使用，因为` .prevent` 将会被忽略，同时浏览器可能会向你展示一个警告。请记住，`.passive`会告诉浏览器你不想阻止事件的默认行为。\n\n# 表单输入绑定\n\n## 基础用法\n\n`v-model`指令用于表单元素的上创建双向数据绑定（即用于代替原来value属性的作用，表示当前表单元素的值）。他是根据控件类型 自动选取正确的方法来更新元素。\n\n`v-model`本质是**语法糖**，它的作用是修改表单控件的value值，同时监听所在表单控件的input事件，在该指令后添加`.lazy`修饰符可改为监听change事件。\n\n`<input  v-bind:value=\"something\"  v-on:input=\"something = $event.target.value\"`\n`v-model`会忽略所有表单元素的` value`、`checked`、`selected` 特性的初始值而总是将 Vue 实例的数据（`data对象`）作为数据来源。你应该通过 JavaScript 在组件的 `data`选项中声明初始值。\n\n### 多个复选框\n\n本质：将多个复选框，绑定到同一数组，否则选择其中一个，就会选择所有。\n\n将`v-model`的`data`对象属性初始化为一个数组，那么该多个复选框将是可以多选的。\n\n注：在表单控件中，选中控件（非文字空间，如多选框、单选框）将改变Vue实例的数据对象的值（因为表单元素与Vue数据对象是双向绑定的，此行为也间接修改了v-model值），则将数据对象值修改为表单控件value的值，但修改value的值是不会改变v-model的值。因为v-model的值只取决于Vue实例的数据对象。\n\n在表单控件中，若要绑定多个数据，那么将他们绑定至同一数组中，若绑定单个数据，则绑定至以一个字符串。\n\n## 值绑定\n\n含义：对于单选、复选以及选择框的选项，`v-model`绑定的值通常是静态字符串（对于复选按钮也可以是布尔值），进一步，可用`v-bind`指令将一个动态属性（该值可以不是字符串）绑定在`v-model`值上。其中，单选/复选按钮本身value值只能是布尔值，这是在Vue内部维护的。`v-model`值只是表单控件的value属性的一个体现。\n\n```html\n<!-- html -->\n<div id=\"app5\">\n    <!-- 注：在复选框中值绑定，必须绑定为 true-value 和 false-value 这两个属性，否则\n    值绑定失效 -->\n    <input\n     id=\"testValue\"\n     type=\"checkbox\"\n     v-model=\"toggle\"\n     v-bind:true-value=\"Yes\"\n     v-bind:false-value=\"No\"\n    >\n    <label for=\"testValue\">Test value</label>\n    <p>You have selected { {toggle} }</p>\n</div>\n```\n\n```js\n// JavaScript\nlet vm5 = new Vue({\n    el: '#app5',\n    data: {\n      toggle: true,\n      Yes: 'Yes',\n      No: \"No\",\n    }\n  });\n```\n\n　　另外，注意因为提交表单时，提交的是表单控件的value的属性值。这里的 `true-value`和 `false-value` 特性并不会影响输入控件的 value 特性，因为浏览器在提交表单时并不会包含未被选中的复选框。如果要确保表单中这两个值中的一个能够被提交，(比如`yes`或`no`)，请换用单选按钮。\n\n在复选框中值绑定，必须绑定为`true-value`和`false-value`这两个属性(除非修改源码，否则不能自定义这两个属性名)，否则值绑定失效。在其他value为非布尔值的表单控件中，直接将特定值绑定到value属性。\n\n## 修饰符\n\n### .number\n\n　　如果想自动将用户的输入值转为数值类型，可以给` v-model `添加 `number` 修饰符：\n`<input v-model.number=\"age\" type=\"number\">`\n这通常很有用，因为即使在` type=\"number\" `时，HTML 输入元素的值也总会返回（某个数字的字符串形式）字符串。\n\n```js\n// 当没有.number修饰符时，返回某个字符串的String类型形式\ntypeof vm.age === 'String'\n\n// 有.number修饰符时，返回某个字符串的Number类型形式\ntypeof vm.age === 'Number'\n```\n\n注：此时的type必须是`number`。\n\n# 组件\n\n## 使用组件\n\n### 全局注册\n\n```js\n// 全局注册组件，component方法不带s\nVue.component('my-component', {\n  template: '<div>A custom component!</div>'\n})\n\n// 创建根实例（应用组件的范围）\nnew Vue({\n  el: '#example'\n})\n```\n　　组件在注册之后，便可以作为自定义元素 `<my-component></my-component>` 在一个实例的模板中使用。注意确保在初始化根实例之前注册组件。\n\n### 局部注册\n\n示例代码如下：\n\n```html\n<!-- html -->\n<div id=\"app1\">\n  <my></my>\n</div>\n```\n\n```js\n// JavaScript\nconst child = {\n  template: '<div>A anther component!</div>'\n};\n\nnew Vue({\n  el: '#app1',\n  components: {\n    'my': child\n  },\n});\n```\n\n**注：全局注册时，component属性不带s，局部注册时components属性带s。**\n\n### DOM模板解析注意事项\n\n当使用 DOM 作为模板时 (例如，使用 el 选项来把 Vue 实例挂载到一个已有内容的元素上)，你会受到 HTML 本身的一些限制，因为 Vue 只有在浏览器解析、规范化模板之后才能获取其内容。尤其要注意，像` <ul>`、`<ol>`、`<table>`、`<select> `这样的元素里允许包含的元素有限制，而另一些像 `<option> `这样的元素只能出现在某些特定元素的内部。\n\n应当注意，如果使用来自以下来源之一的字符串模板，则没有这些限制：\n - `<script type=\"text/x-template\">`\n - JavaScript 内联模板字符串\n - vue 组件\n因此，请尽可能使用字符串模板。\n\n这样不可以\n\n```html\n<body>\n  <div id=\"app\">\n    <select>\n         <optioncomp></optioncomp>\n    </select>\n  </div>  \n  <script src=\"lib/vue.js\"></script>\n  <script>\n    new Vue({\n      el: '#app',\n        components:{\n         'optioncomp':{\n            template: '<option>a</option>'\n          }\n        }\n    })\n   </script>\n</body>\n```\n\n但是用is特殊属性可以：\n\n```html\n<body>\n  <div id=\"app\">\n      <select>\n          <option is=\"optioncomp\"></option>\n      </select>\n  </div>\n  <script src=\"lib/vue.js\"></script>\n  <script>\n    new Vue({\n      el: '#app',\n      components:{\n        'optioncomp':{\n          template: '<option>a</option>'\n        }\n      }\n    })\n  </script>\n</body>\n```\n\n或者temp模板标签也可以\n\n```html\n<body>\n  <div id=\"app\">\n    <select>\n      <option is=\"optioncomp\"></option>\n    </select>\n    <!--模板内容存放区域-->\n    <script type=\"x-template\" id=\"optioncompTemp\">\n      <option >a</option>\n    </script>\n  </div>\n  <script src=\"lib/vue.js\"></script>\n  <script>\n    new Vue({\n      el: '#app',\n        components:{\n          'optioncomp':{\n            template: '#optioncompTemp'\n          }\n        }\n    })\n  </script>\n</body>\n```\n\n或者内联模板字符串\n\n```html\n<body>\n  <div id=\"app\">\n    <selectcomp></selectcomp>\n  </div>\n  <script src=\"lib/vue.js\"></script>\n  <script>\n    Vue.component('optioncomp',{\n      template: '<option >a</option>'\n    });\n    new Vue({\n      el: '#app',\n      components:{\n        'selectcomp':{\n          template: `<select><optioncomp></optioncomp></select>`\n        }\n      }\n    })\n    </script>\n</body>\n```\n\n类型为单页应用的组件文件xxx.vue的情况暂略。\n\n### 组件中的data对象必须是函数\n\n原因：首先明白，只有在创建Vue实例时，才会创建对data对象的引用。\n　　若是data对象不是函数，那么在多处使用该组件（创建Vue实例）时，将造成多处的组件使用的是**同一**data对象。若是data是函数，那么在多处使用该组件时，在创建Vue实例时执行data函数，此时才会真正的创建仅仅属于每个组件自己的data对象，那么此时多处的组件都有自己的data对象（即每使用一次该组件都会重新创建一个新的data对象），这些data对象是相互独立，互不影响的，达到解耦。\n\n```js\n// 在局部组件中添加data对象\nconst child = {\n  template: `<div>{ {fn} }</div>`,\n  data: function() {\n    return {\n      fn: '这里是局部组件的data对象'\n    };\n  }\n};\n\nnew Vue({\n  el: '#app1',\n  components: {\n    'my': child\n  },\n});\n\n// 在全局组件中添加data对象\nVue.component('global', {\n  template: '<button @click=\"counter += 1\">{ {counter} }</button>',\n  data: function() {\n    return {\n      counter: 0\n    };\n  }\n});\n\nnew Vue({\n  el: '#app2'\n});\n```\n\n在全局或者局部组件中，data 函数必须和 template 属性在同一对象中。\n\n### camelCase vs. kebab-case\n\nHTML 特性是不区分大小写的。所以，当使用的不是字符串模板时，camelCase (驼峰式命名) 的 prop 需要转换为相对应的 kebab-case (短横线分隔式命名)：\n```js\nVue.component('child', {\n  // 在 JavaScript 中使用 camelCase\n  props: ['myMessage'],\n  template: '{ { myMessage } }'\n})\n\n\n```\n如果你使用字符串模板，则没有这些限制。\n\n## prop\n\n静态prop作用是传递引用数据，父子组件将同步变化，**侧重点是同步变化**\n\n应用场景：\n\n　　当父组件中的某一属性的属性值需要传递至子组件（组件模板）中Mustache值（即建立一个子组件与父组件的引用时，或称指针）时，需要通过组件的props数组接口传递该值。\n\n　　若不使用props数组接口，则将父组件的属性的属性值称为非prop特性，他们将以非prop特性传递到子组件（组件模板），成为子组件模板中的标签的属性。\n\n> 当父组件中 props 某一项更新时，更新后的新值将自动传入子组件\n\n### 动态 prop\n\n动态prop作用是动态修改prop，与静态prop不同的是，动态prop的侧重点是**动态修改prop**\n\n```html\n<!-- html -->\n<div id=\"app4\">\n  <input type=\"text\" v-model=\"parentMsg\">\n  <br>\n  <child :my-msg=\"parentMsg\"></child>\n</div>\n```\n\n```js\n// JavaScript\nlet vm4 = new Vue({\n    el:'#app4',\n    data:{\n      parentMsg:''\n    },\n    components:{\n\n      'child':{\n        props:['myMsg'],\n        template: `{ {myMsg} }`,\n      }\n\n    },\n  });\n```\n\n数据传输如下：\n\n>v-model <=>(此处双向绑定) data数据对象中的parentMsg => v-bind:my-msg读取data数据中的parentMsg => 得到my-msg的属性值 => 传递给组件中prop属性 => templata中的Mustache语法（双大括号插值）真正调用prop接口的值。\n\n其中v-model的属性值与input输入框双向绑定。\n\n借鉴上面的示例，我们可以将**父组件的方法**经 Vue 实例中的 prop 传递给子组件。\n```html\n<!-- parent.vue -->\n<div id=\"app\">\n  <custom :methods=\"myMethods\"></custom>\n</div>\n```\n```js\n// child.vue\nexport default {\n  // 此处传递 methods 的值是一个对象（函数 myMethods），而不是固定思维中的基本类型值\n  props: ['methods']\n  // ...\n}\n```\n\n### 区分父组件与子组件\n\n**说法一：**\n       由Vue.js官方文档（[组件——自定义事件][1]），其中第一句是“我们知道，父组件使用 prop 传递数据给子组件。”，这句话个人理解为父组件数据通过Vue实例的参数对象的prop特性数组将数据传递给子组件。而因为在Vue实例中，自定义标签根据Vue实例的prop属性接口提供数据给组件模板，以此推断，父组件指的是自定义标签，子组件指的是Vue实例中的模板（或者说是Vue实例渲染出的标签，即组件对象中的template属性值）。　\n\n**说法二：**\n       由官方文档（[组件——组件组合][2]），其中第一段，尤其是`常见的父子组件关系是组件A在他的模板中使用了组件B`，那么我们可推断当存在一种包含关系时，某一组件A的模板中包含组件B，那么我们称组件A数组件B的父组件，B是A的子组件。\n\n**总结：**\n       据官方文档（[组件——编译作用域][3]）如下：\n在深入内容分发 API 之前，我们先明确内容在哪个作用域里编译。假定模板为：\n\n```html\n<child-component>\n  { { message } }\n</child-component>\n```\n　　message 应该绑定到父组件的数据，还是绑定到子组件的数据？答案是父组件。组件作用域简单地说是：\n父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。\n　　我们应该将对父组件与子组件的定义的想法更加拓宽一点，父子组件应该是一个相对概念。说法一和说法二都是正确的。个人觉得，对于父子组件的定义应该为，子组件一定由父组件产生，子组件只能存在父组件中。如上例，`<child-component>`的父组件为Vue实例挂载的元素（即`new Vue( )`中的参数对象中的`el属性值`），`<child-component>`是Vue实例挂载元素的子组件。而在组件定义中 ，`<child-component>`是组件模板（组件定义中的`template`属性）的父组件，组件模板为`<child-component>`的子组件。所以我们对于父子组件的定义不应该过于狭隘，父子组件应该是一个相对的概念。参照系不同，那么对于同一个组件到底是父组件还是子组件是不同的。\n\n### 单向数据流\n\n　　Prop 是单向绑定的：当父组件的属性变化时，将传导给子组件，但是反过来不会（反过来是通过事件传递数据，详见自定义事件）。这是为了防止子组件无意间修改了父组件的状态，来避免应用的数据流变得难以理解。\n　　另外，每次父组件更新时，子组件的所有 prop 都会更新为最新值（因为二者之间通过`props数组`，二者之间存在数据引用）。这意味着你不应该在子组件内部改变 prop。如果你这么做了，Vue 会在控制台给出警告。\n在两种情况下，我们很容易忍不住想去修改 prop 中数据：\n1. Prop 作为初始值传入后，子组件想把它当作局部数据来用；\n2. Prop 作为原始数据传入，由子组件处理成其它数据输出。\n\n对这两种情况，正确的应对方式是：\n1. 定义一个局部变量，并用 prop 的值初始化它：\n\n```js\nprops: ['initialCounter'],\ndata: function () {\n  return { counter: this.initialCounter }\n}\n```\n\n2. 定义一个计算属性，处理 prop 的值并返回：\n\n```js\nprops: ['size'],\ncomputed: {\n  normalizedSize: function () {\n    return this.size.trim().toLowerCase()\n  }\n}\n```\n\n注意在 JavaScript 中对象和数组是引用类型，指向同一个内存空间，如果 `props`是一个对象或数组，在子组件内部改变它会影响父组件的状态。\n\n## 非prop特性\n\n**非prop特性作用是传递静态值，如父组件（自定义标签）的属性**\n\n含义：\n\n　　自定义标签中的属性（非Mustache值，即非双括号值，若需要建立父组件（自定义标签）与子组件（组件模板）之间的数据引用（或理解为指向子组件Mustache值的指针），则需要通过prop特性传递）指可以直接传入组件，而不需要定义相应的`props`。在形如`<mine data-line=\"red\" style=\"color:red;\"></mine>`的自定义标签中，当此时的Vue实例中的`props`属性没有定义名为`data-line`、`style`的接口时，那么我们称`data-line`、`style`属性为**非prop特性**。若在`props`中有调用，则是**props特性**。总而言之，以`props属性`中有没有出现属性A的名字来判断一个属性A是否是非prop特性。\n\n**应用场景：**要建立父子组件的数据引用（同步变化）时，通过`props数组`将父组件数据传递至子组件。要将父组件的属性，直接传递给子组件时，直接通过非prop特性传递。\n父组件向子组件传递数据是单向传递。子组件向父组件传递数据是通过事件传递（详见下文自定义事件）。\n\n应用：替换/合并现有的特性\n\n若存在组件模板（子组件）：\n\n`<p style=\"background: #fff;\">There is nothing</p>`\n\n自定义标签（父组件）为：\n\n`<mine data-line=\"red\" style=\"color:red;\"></mine>`\n\n　　在组件模板和自定义标签中存在同名特性时，除class和style特性在传递给组件模板的值会合并同名特性的特性值外，其他同名特性均会将传递的自定义标签的特性值覆盖组件模板中的同名特性值，使得组件被破坏。\n\n示例如下：\n\n```html\n<!-- html -->\n<div id=\"app6\">\n  <mine data-line=\"red\" style=\"color:red;\"></mine>\n</div>\n```\n\n```js\n// JavaScript\nlet vm6 = new Vue({\n    el:'#app6',\n    components:{\n      \"mine\":{\n        template:`<p data-line=\"blue\" style=\"background: #fff;\">Nothing here</p>`,\n      }\n    }\n});\n```\n\n渲染结果为：\n\n红色的 `Nothing here`\n\n由上可知，模板中的 data-line 特性值被覆盖，style 特性的值与自定义标签中的同名特性合并。\n\n## 自定义事件\n\n应用场景：使用Vue的自定义事件可以达到子组件与父组件通信的目的。（父组件与子组件通过Vue实例中prop特性将数据传递给子组件）。\n\n```html\n<!-- html -->\n<div id=\"app7\">\n    <p>{ {total} }</p>\n    <counter @increment=\"incrementTotal\"></counter>\n    <counter @increment=\"incrementTotal\"></counter>\n    <counter @increment=\"incrementTotal\"></counter>\n    <counter @increment=\"incrementTotal\"></counter>\n</div>\n```\n\n```js\n// JavaScript\nlet vm7 = new Vue({\n    el:'#app7',\n    data:{\n      total:0\n    },\n    components:{\n      'counter':{\n        template:`<button @click=\"incrementCounter\">{ {counter} }</button>`,\n        data: function() {\n          return {\n            counter: 0,\n          };\n        },\n        methods: {\n          // 子组件计数\n          incrementCounter:function () {\n            this.counter += 1;\n            // 触发父组件事件\n            this.$emit('increment');  // 此处子组件与父组件（外部）完全解耦\n          },\n        },\n      }\n    },\n    methods:{\n      incrementTotal:function() {\n        this.total += 1;\n      }\n    },\n  });\n```\n\n数据传递如下：\n>点击`<button>` => 执行incrementCounter函数 => this.counter += 1;this.$emit('increment') => 『子组件中的数据传递结束，子组件通过$emit方法触发事件向父组件传递数据，给父组件一个信息，让父组件开始在父组件内部传递数据』 =>`<counter> ` => 执行incrementTotal函数 => this.total += 1;\n\n### Prop 验证\n\n我们可以为组件的 prop 指定验证规则。如果传入的数据不符合要求，Vue 会发出警告。这对于开发给他人使用的组件非常有用。\n要指定验证规则，需要用对象的形式来定义 prop，而不能用字符串数组：\n\n```js\nVue.component('example', {\n  props: {\n    // 基础类型检测 (`null` 指允许任何类型)\n    propA: Number,\n    // 可能是多种类型\n    propB: [String, Number],\n    // 必传且是字符串\n    propC: {\n      type: String,\n      required: true\n    },\n    // 数值且有默认值\n    propD: {\n      type: Number,\n      default: 100\n    },\n    // 数组/对象的默认值应当由一个工厂函数返回\n    propE: {\n      type: Object,\n      default: function () {\n        return { message: 'hello' }\n      }\n    },\n    // 自定义验证函数\n    propF: {\n      validator: function (value) {\n        return value > 10\n      }\n    }\n  }\n})\n```\n\ntype 可以是下面原生构造器：\n* String\n* Number\n* Boolean\n* Function\n* Object\n* Array\n* Symbol\n\ntype 也可以是一个自定义构造器函数，使用 instanceof 检测。\n当 prop 验证失败，Vue 会抛出警告 (如果使用的是开发版本)。注意 prop 会在组件实例创建之前进行校验，所以在 default 或 validator 函数里，诸如 data、computed 或 methods 等实例属性还无法使用。\n\n### 自定义组件的 v-model\n\n（2.2.0 新增 ）\n默认情况下，一个组件的` v-model `会使用 `value prop` 和 input 事件。但是诸如单选框、复选框之类的输入类型可能把 value 用作了别的目的。model 选项可以避免这样的冲突：\n\n```js\nVue.component('my-checkbox', {\n  //以下model选项作用是自定义v-model属性\n  model: {\n    prop: 'checked',\n    event: 'change'\n  },\n// 以下当props值为一个对象时，是为了指定验证规则\n// 以下props对象表示checked值为布尔值，value值为字符串\n  props: {\n    checked: Boolean,\n    // 这样就允许拿 `value` 这个 prop 做其它事了\n    value: String\n  },\n  // ...\n})\n```\n\n## 使用插槽分发内容（slot/作用域插槽）\n\n### 简介\n\n有如下示例：\n\n```html\n<app>\n  <app-header></app-header>\n  <appfooter></appfooter>\n</app>\n```\n\n我们在使用如上例的组件时，传递给app的内容是由`<app>`的父组件决定的。\n\n以下列举其几种应用场景：\n\n1. 在一些开发过程中，我们可能会需要弹出通知（通知组件），那么这些通知又可分为警告通知、普通通知、错误通知等等类型（不同的通知类型可理解为通知组件的子组件），但是他们都是属于通知类型的（是各种通知类型的父组件）的。\n\n2.下拉菜单中按钮上的显示切换的应用（待补充）\n\n综上，可将`slot插槽`的作用总结为以下：\n\n　　为了组合这些子组件，我们可以使用特殊的`<slot>`元素作为特殊的原始内容的分发接口。父组件集中接收了所有子组件可能需要的内容。通过识别子组件`<slot>`的name属性来决定传递给对应子组件的内容。以上过程解释了如何通过`<slot>`方式向子组件分发内容。此过程常称为**内容分发**。\n\n　　以上的中心思想是，增强组件的**复用性**。相对于prop特性，slot插槽的组件是侧重**不需要引用数据**的更新的，但是需要多处使用**相同结构组件**时，就可使用slot插槽。\n\n### 编译作用域\n\n>遵循原则：父组件模板的内容在父组件作用域内编译；子组件模板的内容在子组件作用域内编译。\n\n### 具名插槽\n\n示例代码如下：\n\n```html\n<div id=\"app9\">\n  <app-layout>\n    <!-- slot属性对应子组件模板中的同名slot元素 -->\n    <!-- 父组件内容在父组件作用域内编辑 -->\n    <h1 slot=\"header\">这里可能是一个页面的标题</h1>\n    <p>主要内容的一个段落</p>\n    <p>另一个主要段落</p>\n    <!-- 若子组件中不包含slot接口，那么父组件中的slot属性的标签将被丢弃 -->\n    <p slot=\"footer\">这里有一些联系信息</p>\n  </app-layout>\n</div>\n```\n\n```html\nlet vm9 = new Vue({\n  el:'#app9',\n  components:{\n    'app-layout':{\n      template:`\n      <div class=\"container\">\n        <header>\n        <!-- 子模板中的slot元素与父组件中的同名slot属性对应 -->\n          <slot name=\"header\"></slot>\n        </header>\n        <main>\n        <!-- 父组件中没有slot属性的元素将匹配以下子组件中的匿名插槽 -->\n          <slot></slot>\n        </main>\n        <footer>\n          <slot name=\"footer\"></slot>\n        </footer>\n      </div>\n      `,\n    }\n  },\n});\n```\n\n渲染结果为：\n\n```html \n<div id=\"app\">\n  <div class=\"container\">\n    <header>\n      <h1>这里可能是一个页面的标题</h1>  <!-- 与 slot=\"header\" 对应-->\n    </header>\n    <main>\n      <p>主要内容的一个段落</p>    <!-- 与没有 slot 属性的内容对应-->\n      <p>另一个主要段落</p>\n    </main>\n    <footer>\n      <p>这里有一些联系信息</p>   <!-- 与 slot=\"footer\" 对应-->\n    </footer>\n  </div>\n</div>\n```\n\n>依据以上示例，可总结为，在设计组合使用的子组件时，依据父组件（自定义标签）中的slot属性与子组件（组件模板）模板中slot标签的对应关系来设计不同的复用子组件的显示（渲染）。\n\nslot插槽的侧重点在**设计子组件如何复用**\n\n### 作用域插槽\n\n（2.1.0以上版本）\n\n>作用：作用域插槽仅仅是依靠prop对象（**数据作为prop对象的属性传递给父组件**）给子组件**提供**一个向父组件传递数据的**机会**。普通prop属性本身只是父组件向子组件的通道，并不接受子组件向父组件传递数据。\n\n示例代码如下：\n\n```html\n<div id=\"app10\">\n  <child>\n    <!-- 拥有slot-scape属性的template标签表示是作用域插槽的模板 -->\n    <!-- slot-scape属性的值作为一个变量固定接收子组件传递过来的props属性值。 -->\n    <template slot-scope=\"props\">\n      <span>hello from parent</span>\n      <span>{{ props.text }}</span>\n    </template>\n  </child>\n</div>\n```\n\n```js\nlet vm10 = new Vue({\n  el:'#app10',\n  components:{\n    'child':{\n      props:['props'] // 此处可省略，作用域插槽的模板会固定接收props属性值(prop对象)\n      template:`\n      <div class=\"child\">\n      <!-- 子组件中slot作用域插槽与父组件slot-scope属性绑定，向父组件传递数据 -->\n        <slot text=\"hello from child\"></slot>\n      </div>\n      `,\n    },\n  },\n});\n```\n\n>由示例可知，子组件经由prop对象“插到”父组件上，故称**此时**的prop为作用域插槽。\n\n**与prop特性（props属性）、非prop特性（仅仅比较数据传递方向）、slot插槽的异同**\n\n不同：传递数据的方向不同\n\n　　由示例可知，与prop特性、非prop特性和slot插槽（**父组件向子组件传递数据**）不同的是，作用域插槽提供了一种**由子组件向父组件传递数据**的可能，即由子组件开始渲染DOM的可能。\n\n　　作用域插槽与普通slot插槽不同之处在于，作用域插槽**并不管**经过prop对象**传递给父组件的是什么内容**，以及父组件要如何分发内容。这是普通slot插槽的事情。作用域插槽仅仅是提供给子组件一个经prop对象向父组件传递数据的机会。其中，子组件数据**以prop对象的属性**传递到父组件中。因为prop对象本身只允许父组件向子组件传递数据。\n\n相同：均为父组件属性与子组件插槽绑定\n\n　　作用域插槽**本质**上可看作是与普通slot插槽传递数据方向相反的**slot具名插槽**，在父组件中，slot-scope属性将父组件与子组件的slot标签绑定。这一绑定数据传递的方式与父组件（自定义标签）中普通slot属性与子组件（组件模板）的同名slot具名（有name属性的slot标签）（或匿名）插槽绑定的方式是一致的。\n\n>在 2.5.0+，slot-scope 能被用在任意元素或组件中而不再局限于 template 标签。\n\n一个简单应用，将slot插槽与作用域插槽结合起来：自定义如何渲染列表的每一项：\n\n```html\n<div id=\"app11\">\n  <my-list :item=\"items\">\n    <li slot=\"item\" slot-scope=\"props\" class=\"my-fancy-item\">{{props.text}}</li>\n  </my-list>\n</div>\n```\n\n```js\nlet vm11 = new Vue({\n  el:'#app11',\n  data:{\n    // 父组件中自定义标签的items属性值，与插槽无关\n    items:'parent-list-items'\n  },\n  components:{\n    'my-list':{\n      template:`\n      <ul>\n        <slot name=\"item\"\n        v-for=\"item in items\"\n        :text=\"item.text\">\n        如果你看到这句话说明子组件中的slot插槽(name属性值)与父组件的slot属性(值)不能对\n        应，父组件接受到此数据（提示）无法对应分发，故没有li标签生成，但此提示仍然以文\n        本形式迭代输出。\n        </slot>\n      </ul>\n      `,\n\n      data: function() {\n        return {\n          // 此items是子组件中的items循环数据对象\n          items:[\n            {text:11},\n            {text:22},\n          ]\n        };\n      },\n\n    },\n  },\n});\n```\n\n在示例中的子组件，各属性的作用如下：\n\n1. name属性：将子组件中的slot标签中的name属性与父组件中的slot属性值匹配，形成一一对应的数据传递关系（也是迭代产出新标签的**关键**）。依据上一节，将父组件接受的内容（**由作用域插槽传递而来**）依据name属性（内容分发的凭证）分发到各个子组件。\n1. v-for属性：迭代子组件的数据对象。\n1. :text=\"item.text\"：接受v-for迭代产出的值，text属性经prop对象传递给父组件。\n1. 父组件中，slot-scope属性：仅仅用于给子组件**提供**一个向父组件传输数据的通道。 它并不管传递的是什么内容，以及父组件将如何分发内容。\n\n　　由此示例可知，slot插槽和作用域插槽的不同之处在于，slot插槽提供内容分发凭证（即子组件中slot标签的name属性）将父组件接收的内容分发给各个子组件。作用域插槽是仅仅给子组件一个经由prop属性向父组件传递数据的机会。作用域插槽**并不管**经过prop对象**传递给父组件的是什么内容**，以及父组件要如何分发内容。***这是slot插槽的事情***。\n\n## 动态组件\n\n使用保留的`<component>`元素，并对其`is`属性进行动态绑定，切换`is`属性的值可在同一个挂载点动态切换多个组件。\n\n### keep-alive\n\n在父组件外包围`<keep-alive>`可将被切换的组件保留在内存中，以避免被替换的组件在切换回来的时候重新渲染，达到缓存组件的目的。\n\n## 杂项\n\n### 编写可复用的组件\n\nVue 组件的 API 来自三部分 —— prop、事件、slot插槽：\n\n- **prop** 提供父组件向子组件传递数据的传输通道，数据是作为props数组的项来传递\n- **事件** 允许子组件向父组件传递数据，侧重于子组件的事件侦听器中通过`this.$emit('某一父组件事件')`方法来触发某一父组件的事件侦听器，从而执行父组件的某一任务。\n- **slot插槽** slot插槽用于将父组件收到的数据内容依据内容分发凭证（子组件中`slot`标签的name属性）分发给各个子组件。\n\n### 子组件引用（ref属性）\n\n使用[ref属性][4]作为子组件指定的一个引用id，这样就可在JavaScript中直接访问子组件。\n\n>因为`$refs`是非响应式，故应该避免在模板或计算属性中使用`$refs`。\n\n### 组件命名约定\n\n注册组件时，可使用kebab-case、camelCase、PascalCase\n\n在HTML模板中，始终使用kebab-case。\n\n### 内联模板\n\n若子组件有inline-template属性，那么组件将它本身的内容（子节点）代替组件模板渲染出来，而不是把它当作分发内容。\n\n```html\n<app inline-template>\n  <p>From custom element</p>\n</app>\n```\n\n```js\nnew Vue({\n  el:'app',\n  components: {\n    'app': {\n      /**\n       * 1.因为是组件模板向HTML文档渲染，故此时的子组件为自定义标签\n       * 2.因为子组件（自定义标签）中存在inline-template属性，以下组件模板将被子组件自\n       * 身的内容代替\n       */\n      template:`<div>There are something good</div>`\n    }\n  }\n});\n```\n\n渲染结果为：\n\n`From custom element`\n\n**作用：**即有了inline-template属性，我们可以决定是渲染自定义标签中的内容还是渲染组件模板中的内容。\n\n>在项目中，inline-template属性可能使模板的作用域难以理解。**最佳实践**为使用组件模板的template选项或在`.vue`文件中使用`template`元素。\n\n### X-Template\n\n除组件模板、内联模板外，第三种定义模本的方式是在JavaScript标签中使用`text/x-template`类型。并指定一个id属性。\n\n```html\n<script type=\"text/x-template\" id=\"hello-world-template\">\n  <p>Hello hello hello</p>\n</script>\n```\n\n```js\nVue.component('hello-world', {\n  template: '#hello-world-template'  // 此处引用了定义的模板\n})\n```\n\n>此法将组件模板与定义分离，不便于管理。故一般情况下应避免使用。\n\n### 对敌开销的静态组件使用 v-once\n\n当组件包含大量**静态**内容时，可使用 [v-once][5] 可缓存渲染结果。\n\n  [1]: https://cn.vuejs.org/v2/guide/components.html#%E8%87%AA%E5%AE%9A%E4%B9%89%E4%BA%8B%E4%BB%B6\n  [2]: https://cn.vuejs.org/v2/guide/components.html#%E7%BB%84%E4%BB%B6%E7%BB%84%E5%90%88\n  [3]: https://cn.vuejs.org/v2/guide/components.html#%E7%BC%96%E8%AF%91%E4%BD%9C%E7%94%A8%E5%9F%9F\n  [4]: https://cn.vuejs.org/v2/guide/components.html#%E5%AD%90%E7%BB%84%E4%BB%B6%E5%BC%95%E7%94%A8\n  [5]: https://cn.vuejs.org/v2/api/#v-once\n"},{"to":"180206-keyword-this","data":"\n# 一、ES5中this的值\n\n## 1.1 定义：this，指函数的调用上下文。\n\n在函数没有被调用的时候是无法确定函数中的this值的指向，只有当函数调用时才能确定函数中this值的指向。\n\n当函数被调用时，理解this值的指向有以下四种情况（函数中存在this）：\n\n**情况一**：函数没有被上一级对象调用时，那么他函数体内的this值指向window。\n\n**注**：在严格模式中默认的this值不是window，而是undefined。\n\n```js\nlet num = () => {\n   a = 10;\n   console.log(this);\n};\nnum();     // window\n```\n\n在上面的函数中，定义了一个函数num，在调用函数时，实际上是调用的window的属性num。\n\n**情况二**：函数被上一级（一个）对象调用时，那么该this值指向的是调用的对象，即指向上一级对象。\n\n```js\nlet num = {\n  a: 10,\n  fn: function() {\n    console.log(this);\n  }\n};\nnum.fn();    // num\n```\n\n在上面的代码中，fn只被对象num包围，在调用fn时，this指向调用fn的上一级对象，也就是对象num。\n\n**情况三**：函数外有多个对象包围时，尽管函数是被最外层的对象调用，那么函数中的this值只指向上一级对象。\n\n```js\nlet num = {\n  a: 10,\n  b: {\n    fn: function() {\n      console.log(this);\n    }\n  }\n};\nnum.b.fn();  // 对象b\n```\n\n　　由上可知，函数fn被对象b包围，而b又是对象num的属性之一，尽管是最外层对象num调用了函数fn（执行了这个调用行为的开端），而函数fn中的this值只会指向离他最近的上一级对象，也就是对象b。\n\n**情况四：先赋值，后执行**\n\n```js\nlet num = {\n  a: 10,\n  b: {\n    fn: function() {\n      console.log(this);\n    }\n  }\n};\nlet digit = num.b.fn\ndigit() // window   与情况三的差别在于，先赋值，后调用\n```\n\n　　this值始终指向最后调用它的对象，且只在调用函数时才能确定this的指向。这里首先是把num.b.fn函数赋值给digit，虽然fn是被对象b所引用，但并没有直接执行函数，而执行digit时才确定了this的指向，window调用了digit，所以指向window。\n\n```js\nvar length = 10;\nfunction fn() {\n  console.log(this.length)\n}\nvar obj = {\n  length: 5,\n  method: function (fn) {\n    fn() // 10\n    arguments[0]() // 2\n    fn.call(obj, 12) // 5\n  }\n};\nobj.method(fn, 1);\n```\n\n　　在上面的示例中，`obj.method(fn, 1);`执行的本质是`fn();` `arguments[0]();` `fn.call(obj, 12);`这三句。先理解三个语句，因为单线程的缘故，所以是在method中给栈添加任务执行三个函数，此时，method任务执行完成，下一个任务执行调用fn，此时，没有显示的指定的对象调用fn，故fn中的this指向window，所以结果为10。下个任务`arguments[0]()`; 表示调用method的参数对象arguments的第一项并执行，此时，arguments对象（只是类数组，并非Array实例）开始调用它的第一项，即fn，此时，fn有显示的调用对象，即arguments对象，此时，fn中的this指向arguments对象，因为arguments对象有两项，故返回2。第三句，显示的指明this指向obj对象，故返回obj.length，即5。\n\n**结论：**\n\n1. （个人理解）在函数a内执行函数b时，确切来说**真正调用执行b的还是window对象**，此时函数b内的this是指向window对象，函数a的作用是**告知引擎添加一个执行b的任务**。\n\n2. 当函数c是arguments对像的第 i 项时，`arguments[i]()`中的this指向的是arguments对象。  \n\n**补充：**\n\n　　在`《JavaScript语言精粹》修订版`P28中，对于没有显式的调用对象的函数调用，该被调用的函数内的this指向全局对象。作者认为这是JavaScript设计上的一个“错误”。  \n\n　　作者认为此时的函数调用中的this应该指向外部函数的this变量。其中当函数A内调用函数B时，首先执行函数A的语句，当执行到调用函数B语句时，暂停函数A内的语句执行，将控制权转交给函数B，先执行完函数B，然后再继续执行函数A（`《JavaScript语言精粹》修订版`P27）。\n\n**构造函数中的this**\n\n```js\nfunction Fn(){\n    this.user = \"Jack\";\n}\nvar a = new Fn();\nconsole.log(a.user); // Jack\n```\n\n　　根据官方文档[new运算符](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/new)中Description第2点的解释，使用new运算符调用构造函数时，构造函数中的this会指向实例化的对象。\n\n实践也可证明：\n\n```js\nfunction Foo() {\n  this.name =  'Jack';\n  console.log(this);\n}\nnew Foo(); // Foo {name:'Jack'}\n```\n\n　　此时控制台返回对象Foo {name:'Jack'} 2次，一个是 console.log(this); 的返回值，一个是实例化的返回值，即 this 在实例化时指向了实例化的对象（或者理解为new运算符将构造函数中的this值绑定到实例化对象上）。\n\n**结论**：函数体中的this始终指向最后调用它的那个对象。在构造函数中，this指向实例化的对象。\n\n## 1.2 实例化时，构造函数的this是如何绑定到实例化对象的呢？\n\n- 据`《JavaScript高级程序设计》第三版`P145，解释如下：\n\n创建新实例时，必须使用new运算符，创建会经历以下四个阶段：\n\n1. 创建一个新对象；\n\n2. 将构造函数和的作用域赋给新对象（因为这个新对象调用了构造函数，所以this就指向了这个新对象）；\n\n3. 执行构造函数中的代码（目的是为了给这个新对象添加属性）；\n\n4. 返回新对象。\n\n\n- 据`《JavaScript语言精粹》修订版`P47，使用new操作符去调用一个函数时，函数的执行方式将被修改，可将new操作符理解为一个方法，则有:\n\nNote:\n\n1. 下文Function.method(name,fn)表示给Function函数添加一个new的方法（method为书中自定义函数，并非JavaScript原生函数，表示给调用的对象添加一个名为name的方法（fn））\n\n2. 代码中的注释讨论的this是构造函数调用new这个方法时的this。　\n\n代码如下：\n\n```js\nFunction.method('new', function() {\n  // 创建一个新对象（对象that）， that和构造函数共用同一个对象\n  // this 指向（与new连用的）构造函数，Object.create()创建一个以参数为原型对象的对象\n  var that = Object.create(this.prototype);\n\n  // 调用构造器函数，绑定 -this- 到新对象（指that）上\n  // 此处存在apply方法，this 指向（与new连用的）构造函数，则以下语句表示，that调用以 \n  // arguments对象为参数对象的构造函数（指定构造函数中的this值为that），目的是给that\n  // 添加属性（或方法）\n  // 此处根据构造函数的函数体，函数体内可能有（或没有）return语句，则other可能是对象、\n  // 基本类型值、undefined、null\n  var other = this.apply(that, arguments);\n\n  // 如果它返回的不一个对象，就返回该(that)新对象，即优先返回构造函数中return语句返回\n  // 的对象，若return返回的不是对象，则忽视return返回值\n  return (typeof other === 'object' && other) || that;    // 1.3解释\n})\n```\n\n在以上代码中，that是一个中间对象，that的作用是执行Function构造函数，并将指向构造函数原型的指针复制给other（实例化对象）。\n\n回到之前的代码：\n　\n```js\nfunction Fn(){\n    this.user = \"Jack\";\n}\nvar a = new Fn();\nconsole.log(a.user); // Jack\n\n```\n\n由两本文献可知，实例化过程中，经历了以下过程：\n\n（由`var a = new Fn();`可知变量a复制了指向Fn()实例对象的指针，以下就以变量a指代Fn的实例。）\n\n1. 创建了一个新对象a（指向构建函数的原型对象），此时对象为空；\n\n2. 复制构造函数的作用域给新对象a；\n\n3. 然后执行构造函数，这是为了给新对象添加属性（因为在构造函数Fn中直接将属性赋给了this对象），那么是如何添加的呢？此时因为是新对象a调用了构造函数，所以构造函数内的this指向了新对象a，此时新对象a就获得了Fn的属性user；\n\n4. 返回新对象a。\n\n以上过程展示了在构造函数实例化的过程中，this的值是如何绑定在实例化的对象上的。\n\n## 1.3 在有return语句中的函数中this的值\n\n(据1.2创建实例经历的四个阶段，可得当存在变量a等于{ user:\"Jack\"}时，可认为构造函数的this指向构造函数的实例。)\n\n当函数的return语句返回一个对象时：　\n\n```js\nfunction Fn(){\n    this.user = \"Jack\";\n    return {};\n}\nvar a = new Fn(); // 返回的不是Fn的实例\nconsole.log(a.user); // undedined\nconsole.log(a); // {} 此时a并没有继承Fn的user属性，可见Fn函数内this并未指向a\n```\n\n当函数的return语句返回一个基本类型值时\n\n```js\nfunction Fn(){\n    this.user = \"Jack\";\n    return 1;\n}\nvar a = new Fn();\nconsole.log(a.user); // \"Jack\"\nconsole.log(a); // {user: \"Jack\"} 此时a继承Fn的user属性，可见Fn函数内this指向a\n```\n\n当函数的return语句返回null时\n\n```js\nfunction Fn(){\n    this.user = \"Jack\";\n    return null; // null是特殊对象值，但此时this仍指向构造函数实例a\n}\nvar a = new Fn();\nconsole.log(a.user); // \"Jack\"\nconsole.log(a); //  {user: \"Jack\"} 此时a继承Fn的user属性，可见Fn函数内this指向a\n```\n\n**结论**：构造函数本身也是函数，所以可以设置return语句的返回值，那么当函数的return语句返回一个对象时，this会指向这个return语句返回的对象，不会指向函数的实例。当return语句返回一个基本类型值（或null）时，会忽略这个基本类型值，指向函数的实例。\n\n# 二、箭头函数（ES6）中的this值\n\n箭头函数可以让this绑定定义时所在的作用域，而不是指向运行时所在的作用域。\n\n```js\nfunction foo() {\n  setTimeout(() => {\n    console.log('id:', this.id);\n  }, 100);}\n\nvar id = 21;\n\nfoo.call({ id: 42 }); // id: 42\n```\n\n　　在以上示例中，setTimeout参数中是一个箭头函数，定义生效时就是函数生成时，而真正的执行在100毫秒（因为JavaScript是单线程，所以在执行完foo后，由全局对象调用执行setTimeout参数中的函数）之后。若是普通函数的话，因为是全局对象调用，所以此时的this值指向window，foo.call({ id: 42 }); 返回21。在示例中，因为是箭头函数，所以this值在定义时就已经确定，总是指向定义生效时所在的对象，这里是{id:42}，所以返回 42。\n\n**推广：箭头函数可以让this指向固定化，这种特性很有利于封装回调函数**。\n\n一次在实践单例的过程中遇到的问题：\n\n简化代码如下：\n\n```js\nlet foo = () => {\n      let a = 111;\n      return {\n        a: a,\n        fn: () => {\n          console.log(this); // window对象\n          // 在某个环境中读取或写入而引用一个标识符时，必须通过搜索来确定该标识符实际代\n          // 表是什么。若找到，搜索停止。若没有，则该变量未声明\n          // fn中对变量a的赋值本质是，向上在作用域链中搜索，找到位于foo中的变量a，并在\n          // fn中对foo的变量a进行赋值\n          a = 222;  \n        },\n        num: () => {\n          console.log(this); // foo对象\n          console.log(a); // 222\n        }\n      };\n    };\nlet ins = foo();\nins.fn();\nins.num();\n```\n\n在以上箭头函数fn中，this指向函数定义时的外部环境。\n\n实际上在箭头函数中，自身并没有this对象，它所使用的this是外层代码块的this。实际上箭头函数可以起到绑定this值的作用。　　\n\n**推广：在箭头函数中，不存在真正属于他自己的this、arguments对象，因为不存在自己的this，所以不能使用call()、apply()、bind()方法修改箭头函数中的this值。**\n\n若要让num方法中的this指向foo，就使用原有的function声明代替箭头函数。这样在调用num方法时，最后调用该方法的对象是foo，所以此时的num方法中的this指向foo。\n\n```js\nlet foo = () => {\n      let a = 111;\n      return {\n        a: a,\n        fn: () => {\n          console.log(this); // window对象\n          a = 222;\n        },\n        num: function() {\n          console.log(this); // foo对象\n          console.log(a); // 222\n        }\n      };\n    };\nlet ins = foo();\nins.fn();\nins.num();\n```\n\n　　另外，**要将作用域中的变量和对象的属性和区分开，作用域只与函数定义时的位置有关，与运行过程无关**。在num方法中要输出变量a，则先在当前num方法中寻找变量a，若没有找到则沿着作用域链向上搜索变量a，则在foo的活动对象中找到变量a，然后返回输出变量a。要注意的一个细节是，a:111是foo的属性，不是变量，不要弄混淆了。\n"}]